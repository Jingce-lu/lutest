# 移动端的几个面试小问题

[[toc]]

## 1.安卓下大面积触摸会导致触发 touchmove 的问题

判断一下 touchstart 的上一次位置和当前位置是否一样，一样就使 move return 掉

```html
<body>
  <div class="page">
    <div id="box"></div>
  </div>
  <script type="text/javascript">
    var page = document.querySelector(".page");
    page.addEventListener("touchstart", function(e) {
      e.preventDefault();
    });
    var lastPoint = {};
    box.addEventListener("touchstart", function(e) {
      lastPoint = {
        x: e.changedTouches[0].pageX,
        y: e.changedTouches[0].pageY
      };
      this.innerHTML = "start";
      this.innerHTML += "<br/>x:" + e.changedTouches[0].pageX;
      this.innerHTML += "<br/>y:" + e.changedTouches[0].pageY;
    });
    box.addEventListener("touchmove", function(e) {
      if (
        e.changedTouches[0].pageX == lastPoint.x &&
        e.changedTouches[0].pageY == lastPoint.Y
      ) {
        return;
      }

      this.innerHTML += "<br/>move";
      this.innerHTML = "x:" + e.changedTouches[0].pageX;
      this.innerHTML += "<br/>y:" + e.changedTouches[0].pageY;
      lastPoint = {
        x: e.changedTouches[0].pageX,
        y: e.changedTouches[0].pageY
      };
    });
  </script>
</body>
```

## 2.移动端输入框被遮挡了怎么办

1. 在 focus 里去做：获取屏幕高度，比较输入框的底部是否超出了屏幕，超出就让外框向上移动超出的距离
2. 在 blur 里做：把外框回到原来位置

```html
<div class="page">
  <div class="info"></div>
  <input type="text" class="text" name="" />
</div>
<script type="text/javascript" src="js/mTween.js"></script>
<script type="text/javascript">
  (function() {
    var page = document.querySelector(".page");
    var text = document.querySelector(".text");
    var info = document.querySelector(".info");
    var old = 0;
    css(page, "translateY", 0);
    /*
    移动端输入框被遮挡的问题
      1) 在软件盘弹出之后（在focus中加个延迟时间），获取input的坐标
      2) 判断input是否遮挡
        1. 判断 input 是否在 可视区的高度以下
      3) 如果被遮挡了 就向上移动整个页面
        1. 用被软件盘遮挡的距离     
  */
    text.addEventListener("focus", function(e) {
      setTimeout(function() {
        //延迟一段时间之后，才可以获取到软键盘弹出之后的坐标
        var rect = text.getBoundingClientRect();
        var h = document.documentElement.clientHeight;
        old = css(page, "translateY");
        if (rect.bottom > h) {
          //info.innerHTML = "被遮挡了";
          var dis = rect.bottom - h;
          css(page, "translateY", old - dis);
        }
      }, 1000);
    });
    text.addEventListener("blur", function(e) {
      old = css(page, "translateY", old);
    });
  })();
</script>
```

## 3.移动端怎么固定横屏显示

检测手机竖屏的时候，元素给元素添加 90deg 的旋转<br>
检测手机横屏的时候，元素给元素的旋转再改为 0

## 4.事件点透

pc 端的鼠标事件在移动端也有效果，但是在移动端使用鼠标事件会有 300 毫秒的延迟，如果有两个元素是重叠的，点击之后上面那个元素消失了就会出现点透事件，如果下面元素有鼠标事件，就会被触发

因为执行过程：手指按下之后，会先执行 touch 事件，然后记录点击的坐标，300ms 之后，在该坐标上查找元素，如果该元素绑定了鼠标事件，就把事件执行了

解决办法： `e.preventDefault()`，或者延迟三百毫秒以上来处理事件

不推荐的解决方法：给单个空间添加阻止冒泡

## 5.解决安卓下点击了软键盘缩放之后，触发不了 input 的 blur 的问题

```html
<body>
  <input id="text" type="text" name="" />
  <div id="info"></div>
  <script type="text/javascript">
    (function() {
      var text = document.querySelector("#text");
      var info = document.querySelector("#info");
      text.onfocus = function() {
        //软键盘的弹出 会影响窗口的大小发生改变
        // 展开是 改变一次，收缩起来又改变一次
        window.addEventListener("resize", toResize);
      };
      function toResize() {
        window.removeEventListener("resize", toResize);
        window.addEventListener("resize", toBlur);
      }
      function toBlur() {
        window.removeEventListener("resize", toBlur);
        text.blur();
      }
    })();
  </script>
</body>
```

## 6.目前新版浏览器不支持 viewport 中的禁止缩放和最大缩放值限制

阻止默认事件

meta 标签上禁止缩放可以禁止绝大部分浏览器。

`<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimum-scale=1.0, maximum-scale=1.0">`

自从 safari 出了手势事件的时候，上面就没办法解决所有的问题。<br>
以下的方案，可以完美解决，既阻止了双击缩放，也阻止了手势缩放

```js
window.onload = function() {
  // 阻止双击放大
  var lastTouchEnd = 0;
  document.addEventListener("touchstart", function(event) {
    if (event.touches.length > 1) {
      event.preventDefault();
    }
  });
  document.addEventListener(
    "touchend",
    function(event) {
      var now = new Date().getTime();
      if (now - lastTouchEnd <= 300) {
        event.preventDefault();
      }
      lastTouchEnd = now;
    },
    false
  );

  // 阻止双指放大
  document.addEventListener("gesturestart", function(event) {
    event.preventDefault();
  });
};
```

## 7.多指操作的兼容

安卓下没有`gestures`事件，需要利用`e.touches`自己去封装。

```js
document.addEventListener("touchstart", function(e) {
  e.preventDefault();
});
/*
init:{
  el: 元素,
  start:fn,
  change:fn,
  end:fn
}
*/
(function() {
  var box = document.querySelector("#box");
  var startDeg = 0;
  var startScale = 0;
  css(box, "rotate", 0);
  css(box, "scale", 100);
  gesture({
    el: box,
    start: function(e) {
      startScale = css(box, "scale") / 100;
      startDeg = css(box, "rotate");
      this.style.background = "blue";
    },
    change: function(e) {
      css(this, "scale", e.scale * startScale * 100);
      this.innerHTML = e.rotation;
      css(box, "rotate", e.rotation + startDeg);
    },
    end: function(e) {
      this.style.background = "red";
    }
  });
})();
function gesture(init) {
  var el = init.el;
  var isGesture = false;
  var startDis = 0;
  var startDeg = 0;
  el.addEventListener("touchstart", function(e) {
    if (e.touches.length >= 2) {
      startDis = getDis(e.touches[0], e.touches[1]);
      startDeg = getDeg(e.touches[0], e.touches[1]);
      isGesture = true;
      init.start && init.start.call(el, e);
    }
  });
  el.addEventListener("touchmove", function(e) {
    if (isGesture && e.touches.length >= 2) {
      isGesture = true;
      var nowDis = getDis(e.touches[0], e.touches[1]);
      var nowDeg = getDeg(e.touches[0], e.touches[1]);
      e.scale = nowDis / startDis; //缩放值
      e.rotation = nowDeg - startDeg;
      init.change && init.change.call(el, e);
    }
  });
  el.addEventListener("touchend", function(e) {
    if (isGesture) {
      init.end && init.end.call(el, e);
    }
    isGesture = false;
  });
}
function getDis(Point, Point2) {
  return Math.sqrt(
    (Point.pageX - Point2.pageX) * (Point.pageX - Point2.pageX) +
      (Point.pageY - Point2.pageY) * (Point.pageY - Point2.pageY)
  );
}
function getDeg(Point, Point2) {
  var y = Point.pageY - Point2.pageY;
  var x = Point.pageX - Point2.pageX;
  return (Math.atan2(y, x) / Math.PI) * 180;
}
```

## 8.滑屏时的卡顿问题

阻止默认事件

```css
* {
  -webkit-overflow-scrolling: touch;
}
```

`-webkit-overflow-scrolling`控制元素在移动设备上面是否有滚动回弹效果，它可以设置成 auto 和 touch

- `auto`: 使用普通滚动, 当手指从触摸屏上移开，滚动会立即停止。
- `touch`: 使用具有回弹效果的滚动, 当手指从触摸屏上移开，内容会继续保持一段时间的滚动效果。继续滚动的速度和持续的时间和滚动手势的强烈程度成正比。<br>
  使用 touch 可以让滚动条有滚动回弹效果，就像是 ios 原生的滚动体验一样

## 9.transition 移动端的闪屏问题

把外框变成 3D 的，一般情况下不会遇到

## 10.使用了 3d 做动画之后，3d 元素下边的文字失真的问题

给上面动画的幻灯片什么的外层加上绝对定位，定位里面一层加上相对定位。

## 11.部分安卓下调用 file，只能调用到相册，不能调用摄像头

在 input 上加上一个`caption`属性，但是如果是`x5`或者是`ios`浏览器下就会出现只能调到摄像头的问题，所以要加一个判断，判断浏览器的版本，如果是 iso 浏览器或者 x5 浏览器，就把加 caption 属性这个 renturn 掉不加

## 12.audio 的不能自动播放问题

给 document 加上.play()

## 13.如何判断网络环境是无线还是流量

navigator 里面有所有和网络相关的东西

## 14.为什么移动端 click 会有 300 毫秒延迟？

因为移动端浏览器会有一些默认的行为，比如双击缩放、双击滚动。这些行为尤其是双击缩放，主要是为桌面网站在移动端的浏览体验设计的。而在用户对页面进行操作的时候，移动端浏览器会优先判断用户是否要触发默认的行为。

## 15.固定定位布局键盘挡住输入框内容？

分析：

● 在软件盘弹出之后（在 focus 中加个延迟时间），获取 input 的坐标

● 判断 input 是否遮挡

● 判断 input 是否在可视区的高度以下

● 如果被遮挡了，就向上移动整个页面

1. 通过绑定窗口改变事件,监听键盘的弹出。然后去改变固定定位元素的位置。默认键盘的宽度应该是页面的 2 分之一。所以我们位移的距离改成键盘的二分之一就可以。
   ```js
   window.onresize = function() {
     //$(".mian")就是固定定位的元素
     if (
       $(".mian")
         .css("top")
         .replace("px", "") != 0
     ) {
       $(".mian").css("top", 0);
     } else {
       var winHeight = $(window).height();
       $(".mian").css("top", -(winHeight / 4));
     }
   };
   ```
2. 通过定时器实时监听是否触发 input。如果触发 input 框，就把固定定位改变成静态定位。这样就会浏览器会总动把内容顶上去。

   ```js
   function fixedWatch(el) {
     //activeElement获取焦点元素
     if (document.activeElement.nodeName == "INPUT") {
       el.css("position", "static");
     } else {
       el.css("position", "fixed");
     }
   }

   setInterval(function() {
     fixedWatch($(".mian"));
   }, 500);
   ```

## 16.如何防止手机中页面放大和缩小？

`<meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" />`

## 17. 如何解决上下拉动滚动条时出现卡顿的现象？

```css
body {
  -webkit-overflow-scrolling: touch;
  overflow-scrolling: touch;
}
```

Android3+和 iOSi5+支持`CSS3`的新属性为`overflow-scrolling`

## 18.如何解决长时间按住页面闪退的现象？

```css
element {
  -webkit-touch-callout: none;
}
```

## 19.iphone 及 ipad 下输入框默认内阴影

```css
element {
  -webkit-tap-highlight-color: rgba(255, 255, 255, 0);
}
```

设置 alpha 值为 0 就可以去除本透明灰色遮罩，备注：transparent 的属性值在 android 下无效。

## 20.active 兼容处理即伪类：active 失效

方法一：body 添加 ontouchstart `<body ontouchstart=''>`

方法二：js 给 document 绑定`touchstart`或`touchend`事件

```html
<style>
  a {
    color: #000;
  }
  a:active {
    color: #fff;
  }
</style>

<a href="foo">bar</a>

<script>
  document.addEventListentener("touchstart", function() {}, false);
</script>
```

## 21.使用了 3d 做动画之后，3d 元素下边的文字失真的问题

给上面动画的幻灯片什么的外层加上绝对定位，定位里面一层加上相对定位。

## 22.举例说明微信端兼容问题有哪些？

1. 在 ios 微信端，当在输入框唤起键盘后，页面会抬升，输入完成键盘退出后，页面并没有自动恢复到原来的样子, 越接近页面底部越明显。
   解决方法是使用`document.documentElement.scrollIntoView(false)`,让页面自动回滚。
2. 微信自带的下拉出网站信息，苹果自带的滑动回弹，与 fixed 一起，非常非常酸爽
3. 微信视频最好使用全屏模式，否则会有结尾广告、不能被元素覆盖
4. 横屏的项目，微信支付时会竖屏，大部分苹果机支付后无法再横屏了
5. 微信小程序的 iPhoneX 适配, 因为 iPhoneX 底部没有虚拟按键，底部的横线会出现遮挡这时候就要处理下：
   大概思路就是获取到客户端设备，然后判断是 iPhoneX 就换样式。
   在 app.js 中添加一个检测当前设备是否是 iPhoneX 的变量：
   ```js
   globalData: {
     userInfo: null,
     isIphoneX: false//判断是否是iPhoneX
   },
   onShow: function() {
     var that = this;
     wx.getSystemInfo({
       success: function(res) {
         // console.log('手机信息res'+res.model)
         let modelmes = res.model;
         if (modelmes.search('iPhone X') != -1) {
           that.globalData.isIphoneX = true
         }
       },
     })
   }
   ```
   在需要做兼容的 xxx.js 中引入：
   ```js
   var app = getApp();
   Page({
     data: {
       isIphoneX: false
     },
     onLoad: function() {
       // 判断是否为iPhoneX
       var isIphoneX = app.globalData.isIphoneX;
       console.log(isIphoneX ? "是iPhoneX" : "不是iPhoneX");
       this.setData({
         isIphoneX: isIphoneX
       });
     }
   });
   ```
   然后在 xx.wxml 中对需要做兼容的元素做判断 ：
   ```html
   <view class="{{isIphoneX ? 'width30' : 'width10'}}"></view>
   ```
   然后在对应的 wxss 里设置好对应的类名就 ok 了，比较简单方便。

## 23.嵌入的 iframe 页面无法滚动

在 iframe 外层包裹一个 div,然后将其设置为可滚动

```html
<div style="webkit-overflow-scrolling: touch;overflow-y: scroll;">
  <iframe></iframe>
</div>
```

并且在禁止浏览器的默认行为，不然类似于微信滑动到底部的时候会和回弹的效果进行冲突

```js
$("body").on("touchmove", function(e) {
  e.preventDefault();
});
```
