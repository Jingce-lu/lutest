# 几个让我印象深刻的面试题

[[toc]]

## 1. 请问 a，b，c 分别输出什么？

```js
function fun(n, o) {
  console.log(o);
  return {
    fun: function(m) {
      return fun(m, n);
    }
  };
}
var a = fun(0);
a.fun(1);
a.fun(2);
a.fun(3);
var b = fun(0)
  .fun(1)
  .fun(2)
  .fun(3);
var c = fun(0).fun(1);
c.fun(2);
c.fun(3);
```

解答：

我们先来一步一步地看。首先是 a=fun(0)因为只传了一个参数，console 输出的是第二个参数的值，所以毫无疑问地输出 undefined。

然后到 a.fun(1)可以看出，这句话是调用前面 fun(0)返回回来的一个对象里面的函数 fun，这个 fun 又把 fun(m,n)返回出去。这个时候请注意：这个对象里的 fun 在返回之前调用了一下 fun(m,n)，所以 console 又会被执行，可以确定，它肯定不会输出传进去的 1，因为 1 作为第一个参数传到 fun(m,n)里，而 console 是输出第二个参数的。那么这次会输出啥呢？

好了，不给大家卖关子了，答案是 0。可能有人会问了，纳尼？为毛是 0，0 是哪来的？

要想看明白我的解释，前提是你得清楚闭包。这里用到了闭包。我们知道，闭包有个功能就是外部作用域能通过闭包访问函数内部的变量。其实在运行 a=fun(0)的时候，return 出来的对象里的函数 fun 把传进来的这个 0 作为第二个参数传到 fun 里面并返回出来这时 0 得到了保存。所以当运行 a.fun(1)的时候其实输出的是之前的 0。后面的那两个调用也和这个的原理一样，最后都是输出 0。

这里可能会有点绕，需要花点时间来看或者自行去调试。（我已经在尽力表达清楚了，如果还不懂的话就留言吧=.=）。

然后到 b，如果前面搞懂了这里就不难了。fun(0)运行的时候会 return 一个对象出去，后面的一串链式调用都是在调用前面函数返回的对象里的 fun，最终导致输出是 undefined 0 1 2 最后到 c，如果 b 都搞懂了，到这里基本就没什么难度了。分别会输出 undefined 0 1 1。如果还不懂的话建议单步调试一下，如果还是不懂可以在下面留言，我会尽最大能力给你解释。

## 2. 用尽可能多的方法找出数组中重复出现过的元素

例如：[1，2，4，4，3，3，1，5，3]

输出：[1，3，4]

```js
function repeat(arr) {
  var result = [];
  arr.sort().reduce(function(a, b) {
    if (a === b && result.indexOf(a) === -1) {
      result.push(a);
    }
    return b;
  });
  return result;
}
```

```js
function repeat(arr) {
  var result = [],
    map = {};
  arr.map(function(num) {
    if (map[num] === 1) result.push(num);
    map[num] = (map[num] || 0) + 1;
  });
  return result;
}
```

值得一提的是 map[num] = (map[num] || 0) + 1，这句代码的(map[num] || 0)如果 map[num]存在，则 map[num]+1 反之则 0+1，个人觉得用得很巧妙。

```js
let array = [1, 1, 2, 3, 3, 3, 4, 4, 5];

Array.from(new Set(array.filter((x, i, self) => self.indexOf(x) !== i)));

// es5

var array = [1, 2, 4, 4, 3, 3, 1, 5, 3];

array.filter(function(x, i, self) {
  return self.indexOf(x) === i && self.lastIndexOf(x) !== i;
});
```

## 3. 给定一些文档（docs）、词（words），找出词在文档中全部存在的所有文档

```js
var docs = [
  {
    id: 1,
    words: ["hello", "world"]
  },
  {
    id: 2,
    words: ["hello", "kids"]
  },
  {
    id: 3,
    words: ["zzzz", "hello"]
  },
  {
    id: 4,
    words: ["world", "kids"]
  }
];
findDocList(docs, ["hello"]); //文档1，文档2，文档3
findDocList(docs, ["hello", "world"]); //文档1
```

把第二个参数的数组用 join 合成一个字符串，然后用 forEach 遍历，分别把文档里的 words 也用 join 合成一个字符串，利用 search 方法找每个文档里的 words 是否包含有 arrStr。

```js
function findDocList(docs, arr) {
  let arrStr = arr.join(""),
    itemStr,
    result = [];
  docs.forEach(function(item) {
    itemStr = item.words.join("");
    if (itemStr.search(new RegExp(arrStr)) !== -1) {
      result.push("文档" + item.id);
    }
  });
  console.log(result);
}
findDocList(docs, ["hello"]); //文档1，文档2，文档3
findDocList(docs, ["hello", "world"]); //文档1

// ps: 有bug
// findDocList(docs, ["world", "hello"]); 出错
```

```js
// 改进
function findDocList(docs, arr) {
  let result = [];
  docs.forEach(item => {
    if (arr.every(k => item.words.includes(k))) {
      result.push("文档" + item.id);
    }
  });
  console.log(result);
}
```

## 4. 下面代码会输出什么？

```js
var test = (function(a) {
  this.a = a;
  return function(b) {
    return this.a + b;
  };
})(
  (function(a, b) {
    return a;
  })(1, 2)
);
console.log(test(1));
```

可以看到，这里有两个自执行函数。下面这个自执行函数执行完后向上面这个自执行函数传了个 1 所以 this.a=1，这里的 this 指向 window。然后这个自执行函数返回个函数给 test 变量。下面调用 test(1)，这个 1 传进来后相当于 return 1+1 所以就输出 2。

## 5. 不用循环，创建一个长度为 100 的数组，并且每个元素的值等于它的下标。

```js
Object.keys(Array.from({ length: 100 }));

// es5
Object.keys(Array.apply(null, { length: 100 }));
// ["0", "1", "2", "3", ...]

// return number
[...Array(100).keys()]; // [0,1,2,3...]
// or
Array.from(Array(100).keys());
```

## 6. 一个整数，它的各位数字如果是左右对称的，则这个数字是对称数。那么请找出 1 至 10000 中所有的对称数

```js
function symmetric() {
  var i = 1,
    str,
    newStr,
    result = [];
  for (; i < 1000; i++) {
    str = "" + i;
    newStr = result.map
      .call(str, function(item) {
        return item;
      })
      .reverse()
      .join("");
    if (str === newStr) {
      result.push(+str);
    }
  }
  return result;
}
```

```js
[...Array(10000).keys()].filter(x => {
  return (
    x.toString().length > 1 &&
    x ===
      Number(
        x
          .toString()
          .split("")
          .reverse()
          .join("")
      )
  );
});
```

```js
// 正则
[...Array(10000).keys()].filter(v => {
  return v === Number((String(v).match(/(^\d)(\d)?\2*\1$/) || [])[0]);
});

// 精简一下;
[...Array(10000).keys()].filter(v => {
  return (String(v).match(/(^\d)(\d)?\2*\1$/) || [])[0];
});

// 再精简一下;
[...Array(1e4).keys()].filter(v => (v + "").match(/(^\d)(\d)?\2*\1$/));
```

```js
[...Array(10000).keys()].filter(
  i => i > 10 && i == [...(i + "")].reverse().join("")
);
```

## 7. 以下代码输出结果是什么？

```js
var myObject = {
  foo: "bar",
  func: function() {
    var self = this;
    console.log("outer func : this.foo " + this.foo);
    console.log("outer func : self.foo " + self.foo);
    (function() {
      console.log("inner func : this.foo " + this.foo);
      console.log("inner func : self.foo " + self.foo);
    })();
  }
};
myObject.func();
```

```js
// outer func : this.foo bar
// outer func : this.foo bar
// inner func : this.foo undefined
// inner func : this.foo bar
```

## 8. 请写出以下正则表达式的详细规则说明

```js
/^(0[1-9]\d\d?)?[1-9]\d{6}\d?$/

/^(1[89]|[2-9]\d|100)$/i

/^[\w-]+@[a-z0-9-]+({[a-z]{2,6}}){1,2}$/i
```

第一个：首先^代表的是以它后面的一堆东西为开头\$代表以它前面一堆东西为结尾，在这里的意思就是以(0[1-9]\d\d?)?[1-9]\d{6}\d?为开头和结尾的字符串。然后到第一个括号里的意思是匹配第一个字符串为 0 第二个字符串为 1-9 第三个字符串为 0-9 第四个字符串可有可无，有的话匹配 1-9，然后这整个括号里面的内容可有可无。问号后面的意思是匹配第一个字符串是 1-9 然后后面 6 个字符串匹配 0-9 最后一个字符串可有可无，有的话匹配 0-9。

所以整理整理就是：匹配以 0 为第一个，1-9 为第二个，数字为第三个；第四个可有可无，有的话匹配数字；然后前面这一整坨可有可无。1-9 为第五个(如果前面那一坨没有的话，则从第一个算起)然后后面 6 个都是数字最后一个数字可有可无的字符串，且以它为开头和结尾。

下面是例子：

```js
022222222222; //true
002222222222; //false 因为第二个数字是 1-9
02222222222; //第一个括号最后一个数字或者最后面的数字省略
0222222222; //第一个括号最后一个数字和者最后面的数字省略
22222222; //第一个括号里的内容全部省略
02222222; //\d{6}没有满足。
```

第二个：匹配以 1 作为第一个，8 或 9 作为第二个又或者以 2-9 为第一个，数字为第二个又或者匹配 100 的字符串，并以他们为开头和结尾，忽略大小写。

还是例子比较直观：

```js
18; //true 匹配前面的1[89]
23; //true 匹配[2-9]\d
100; //true 匹配100
17; //false
230; //false
```

第三个：

匹配前面至少一个数字或字母或\_或-再匹配@然后再匹配至少一个字母或数字或-然后到再匹配{字母 2-6 个}1-2 个，的字符串，并以他们为开头和结尾忽略大小写。

这个用语言描述太难了，是我不会说话吗，上例子吧：

```js
3@d{aw}{ad} //true
-@-{ddd}{fs} //true
3@3{dw}{ddd} //true
3@3{dw} //false {字母2-6个}少了一个即({[a-z]{2,6}}){1,2}后面的{1,2}没满足
@3{dw}{ddd} //false [\w-]+没满足
33{dw}{ddd} //false 没@
dsa@ffff{dw}{d} //false ({[a-z]{2,6}})不符合
```

## 9. 请写出打乱数组方法

```js
function shuffle(arr) {
  let m = arr.length;
  while (m > 1) {
    let index = Math.floor(Math.random() * m--);
    [arr[m], arr[index]] = [arr[index], arr[m]];
  }
  return arr;
}
```

```js
function shuffle(arr) {
  for (let i = arr.length; i > 0; i--) {
    let j = Math.floor(Math.random() * i);
    [arr[i - 1], arr[j]] = [arr[j], arr[i - 1]];
  }
  return arr;
}
```

## 10. 写出 element.getElementsByClassName 的实现方法

先获取页面下的所有元素，然后用 split 将传进来的多个 class 分割成数组，然后利两层循环找出符合条件的元素（个人觉得这种方法效率实在低下，就当是抛砖引玉吧，欢迎留言）

代码：

```js
if (!document.getElementsByClassName) {
  document.getElementsByClassName = function(className) {
    var ele = [],
      tags = document.getElementsByTagName("*");
    className = className.split(/\s+/);
    for (var i = 0; i < tags.length; i++) {
      for (var j = 0; j < className.length; j++) {
        //如果这个元素上有这个class且没在ele里面(主要防止多个class加在一个元素上推进去两次的情况)
        if (tags[i].className === className[j] && ele.indexOf(tags[i]) === -1) {
          ele.push(tags[i]);
        }
      }
    }
    return ele;
  };
}
```

## 11. 请写出代码输出结果

```js
var handle = function(a) {
  var b = 3;
  var tmp = function(a) {
    b = a + b;
    return tmp;
  };
  tmp.toString = function() {
    return b;
  };
  return tmp;
};
alert(handle(4)(5)(6));
```

我们来一步一步看：首先是 handle(4)，到这里，程序开始运行，创建了一个 tmp 函数，同时把 tmp 函数的 toString 方法重写了，最后返回这个 tmp 函数。
注意：tmp 里的 a 不是传进去的 4，不要把 tmp 的 a 和 handle 的 a 搞混了，所以这里传的 4 啥也没干。

然后到第二步：handle(4)(5)，这里就是执行了 tmp 函数，这个时候 tmp 函数的 a 就是传进来的 5，·b 就是第一步函数执行的 b 即 3(不懂为何是 3 的同学再去了解了解闭包吧)，最后这个 b 就等于 8。

第三部重复第二步 8+6，最后 b 为 14，javascript 引擎最后自动调用了 toString 返回 b，所以结果是 14。

## 12. javscript 表达式"[]==''"的值是什么，为什么？

这题考察对 js==运算符的了解，我们知道==运算符如果两边值类型不一样会把它们转换为相同类型的值再来比较。这题左边是 object 类型，右边是 string 类型，所以会把左边的转化为 string 类型来比较，[].toString()就是''所以最后结果是 true。

## 13. Js 生成下面 html，点击每个 li 的时候弹出 1,2,3......

> //li onclick 事件都能弹出当前被点击的 index=?

```html
<ul id="testUrl">
  <li>index=0</li>
  <li>index=1</li>
</ul>
```

```js
var ul = document.createElement("ul"),
  lis = [];
ul.id = "testUrl";
for (var i = 0, li; i < 2; i++) {
  li = document.createElement("li");
  li.innerHTML = "index=" + i;
  ul.appendChild(li);
  lis.push(li);
}
ul.addEventListener("click", function(e) {
  alert(lis.indexOf(e.target));
  alert(e.target.innerHTML);
});
document.body.appendChild(ul);
```

## 14. map 方法是 ES5 中新增的，要求为 ES5 以下的环境增加个 map 方法

```js
Array.prototype.Mymap = function(fn, obj) {
  var resultData = [];
  var len = this.length;
  if (obj != undefined) {
    fn = fn.bind(obj);
  }
  for (let i = 0; i < len; i++) {
    resultData.push(fn(this[i], i, this));
  }
  return resultData;
};

// 2
Array.prototype.myMap = function(fn, context) {
  // 首先定义一个数组来保存每一项的运算结果，最后返回
  var temp = [];
  if (typeof fn !== "function") {
    throw new TypeError(`${fn} is not a function`);
  }

  for (let i = 0; i < this.length; i++) {
    // 将每一项的运算操作丢进fn里，
    // 利用call方法指定fn的this指向与具体参数
    temp.push(fn.call(context, this[i], i, this));
  }

  // 返回每一项运算结果组成的新数组
  return temp;
};
```

```js
if (!Array.prototype.map) {
  Array.prototype.map = function(callback, context) {
    var len = this.length,
      i = 0,
      result = [];
    if (typeof callback !== "function") {
      throw new TypeError(callback + " is not a function");
    }
    context = context || window;
    for (; i < len; i++) {
      this[i] !== undefined
        ? result.push(callback.call(context, this[i], i, this))
        : result.push(this[i]);
    }
    return result;
  };
}
```

```js
if (!Array.prototype.map) {
  Array.prototype.map = function(callback, thisArg) {
    var T, A, k;

    if (this == null) {
      throw new TypeError(" this is null or not defined");
    }

    // 1. 将O赋值为调用map方法的数组.
    var O = Object(this);

    // 2.将len赋值为数组O的长度.
    var len = O.length >>> 0;

    // 3.如果callback不是函数,则抛出TypeError异常.
    if (Object.prototype.toString.call(callback) != "[object Function]") {
      throw new TypeError(callback + " is not a function");
    }

    // 4. 如果参数thisArg有值,则将T赋值为thisArg;否则T为undefined.
    if (thisArg) {
      T = thisArg;
    }

    // 5. 创建新数组A,长度为原数组O长度len
    A = new Array(len);

    // 6. 将k赋值为0
    k = 0;

    // 7. 当 k < len 时,执行循环.
    while (k < len) {
      var kValue, mappedValue;

      //遍历O,k为原数组索引
      if (k in O) {
        //kValue为索引k对应的值.
        kValue = O[k];

        // 执行callback,this指向T,参数有三个.分别是kValue:值,k:索引,O:原数组.
        mappedValue = callback.call(T, kValue, k, O);

        // 返回值添加到新数组A中.
        A[k] = mappedValue;
      }
      // k自增1
      k++;
    }

    // 8. 返回新数组A
    return A;
  };
}
```
