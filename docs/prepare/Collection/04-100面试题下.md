# 2020 最新：100 道有答案的前端面试题（下）

[[toc]]

## 1. IIFE 写出执行结果,并解释原因

```js
var a = 1;
(function a() {
  a = 2;
  console.log(a);
})();
// 写出执行结果，并解释原因
```

```js
// 答案
ƒ  a () {
      a = 2;
      console.log(a);
}
```

**解析**  
立即调用的函数表达式（IIFE） 有一个 自己独立的 作用域，如果函数名称与内部变量名称冲突，就会永远执行函数本身；所以上面的结果输出是函数本身；

## 2. Math.min Math.max

```js
var min = Math.min();
max = Math.max();
console.log(min < max);
// 写出执行结果，并解释原因
```

**答案**  
false

**解析**

- 按常规的思路，这段代码应该输出 true，毕竟最小值小于最大值。但是却输出 false
- MDN 相关文档是这样解释的
  - Math.min 的参数是 0 个或者多个，如果多个参数很容易理解，返回参数中最小的。如果没有参数，则返回 `Infinity`，无穷大。
  - 而 Math.max 没有传递参数时返回的是`-Infinity`.所以输出 false

## 3. 变量 a 出现在 if 的条件, 类型转换比较

```js
var a = [0];
if (a) {
  console.log(a == true);
} else {
  console.log(a);
}
// 写出执行结果，并解释原因
```

**答案**  
false

**解析**  
1）当 a 出现在 if 的条件中时，被转成布尔值，而 Boolean([0])为 true,所以就进行下一步判断 a == true,在进行比较时，[0]被转换成了 0，所以 0==true 为 false  
数组从非 primitive 转为 primitive 的时候会先隐式调用 join 变成“0”，string 和 boolean 比较的时候，两个都先转为 number 类型再比较，最后就是 0==1 的比较了

```js
var a = [1];
if (a) {
  console.log(a == true);
} else {
  console.log(a);
}
// true
```

```js
!![]; //true 空数组转换为布尔值是 true,
!![0][0] == true; //true 数组转换为布尔值是 true //false 数组与布尔值比较时却变成了 false
Number([]); //0
Number(false); //0
Number(["1"]); //1
```

2）所以当 a 出现在 if 的条件中时，被转成布尔值，而 Boolean([0])为 true,所以就进行下一步判断 a == true,在进行比较时，js 的规则是：

1. 如果比较的是原始类型的值，原始类型的值会转成数值再进行比较
   ```js
   1 == true; //true   1 === Number(true)
   "true" == true; //false Number('true')->NaN  Number(true)->1
   "" = 0; //true
   "1" == true; //true  Number('1')->1
   ```
2. 对象与原始类型值比较，对象会转换成原始类型的值再进行比较。
3. undefined 和 null 与其它类型进行比较时，结果都为 false，他们相互比较时结果为 true。

## 4. Day4

```js
(function() {
  var a = (b = 5);
})();
console.log(b);
console.log(a);
// 写出执行结果，并解释原因
```

**答案**  
5 Error, a is not defined

**解析**  
在这个立即执行函数表达式（IIFE）中包括两个赋值操作，其中`a`使用`var`关键字进行声明，因此其属于函数内部的局部变量（仅存在于函数中），相反，`b`被分配到全局命名空间。  
另一个需要注意的是，这里没有在函数内部使用[严格模式](http://cjihrig.com/blog/javascripts-strict-mode-and-why-you-should-use-it/)(`use strict;`)。如果启用了严格模式，代码会在输出 b 时报错`Uncaught ReferenceError: b is not defined`,需要记住的是，严格模式要求你显式的引用全局作用域。因此，你需要写成：

```js
(function() {
  "use strict";
  var a = (window.b = 5);
})();
console.log(b);
```

再看一个

```js
(function() {
  "use strict";
  var a = (b = 5);
})();

console.log(b); //Uncaught ReferenceError: b is not defined

/*---------------------------*/

(function() {
  "use strict";
  var a = (window.b = 5);
})();

console.log(b); // 5
```

## 5. Day5

```js
var company = {
  address: "beijing"
};
var yideng = Object.create(company);
delete yideng.address;
console.log(yideng.address);
// 写出执行结果，并解释原因
```

**答案**  
beijing

**解析**  
这里的 yideng 通过 prototype 继承了 company 的 address。yideng 自己并没有 address 属性。所以 delete 操作符的作用是无效的。

**知识点**

1. delete 使用原则：delete 操作符用来删除一个对象的属性。
2. delete 在删除一个不可配置的属性时在严格模式和非严格模式下的区别:
   1. 在严格模式中，如果属性是一个不可配置（non-configurable）属性，删除时会抛出异常;
   2. 非严格模式下返回 false。
3. delete 能删除隐式声明的全局变量：这个全局变量其实是 global 对象(window)的属性
4. delete 能删除的：

   1. 可配置对象的属性
   2. 隐式声明的全局变量
   3. 用户定义的属性
   4. 在 ECMAScript 6 中，通过 const 或 let 声明指定的 "temporal dead zone" (TDZ) 对 delete 操作符也会起作用

   delete 不能删除的：

   1. 显式声明的全局变量
   2. 内置对象的内置属性
   3. 一个对象从原型继承而来的属性

5. delete 删除数组元素：
   1. 当你删除一个数组元素时，数组的 length 属性并不会变小，数组元素变成 undefined
   2. 当用 delete 操作符删除一个数组元素时，被删除的元素已经完全不属于该数组。
   3. 如果你想让一个数组元素的值变为 undefined 而不是删除它，可以使用 undefined 给其赋值而不是使用 delete 操作符。此时数组元素是在数组中的
6. delete 操作符与直接释放内存（只能通过解除引用来间接释放）没有关系。
7. 其它例子

   1. 下面代码输出什么？
      ```js
      var output = (function(x) {
        delete x;
        return x;
      })(0);
      console.log(output);
      ```
      答案：0，`delete` 操作符是将 object 的属性删去的操作。但是这里的 `x` 是并不是对象的属性， `delete` 操作符并不能作用。
   2. 下面代码输出什么？

      ```js
      var x = 1;
      var output = (function() {
        delete x;
        return x;
      })();
      console.log(output);
      ```

      答案：输出是 1。delete 操作符是将 object 的属性删去的操作。但是这里的 x 是并不是对象的属性， delete 操作符并不能作用。

   3. 下面代码输出什么?
      ```js
      x = 1;
      var output = (function() {
        delete x;
        return x;
      })();
      console.log(output);
      ```
      答案：报错 VM548:1 Uncaught ReferenceError: x is not defined,
   4. 下面代码输出什么？
      ```js
      var x = { foo: 1 };
      var output = (function() {
        delete x.foo;
        return x.foo;
      })();
      console.log(output);
      ```
      答案：输出是 undefined。x 虽然是全局变量，但是它是一个 object。delete 作用在 x.foo 上，成功的将 x.foo 删去。所以返回 undefined

## 6. Day6

```js
var foo = function bar() {
  return 12;
};
console.log(typeof bar());
// 写出执行结果，并解释原因
```

**答案**  
输出是抛出异常，bar is not defined。

**解析**  
这种命名函数表达式函数只能在函数体内有效

```js
var foo = function bar() {
  // foo is visible here
  // bar is visible here
  console.log(typeof bar()); // Work here :)
};
// foo is visible here
// bar is undefined here
```

## 7. Day 7

```js
var x = 1;
if (function f() {}) {
  x += typeof f;
}
console.log(x);
// 写出执行结果，并解释原因
```

**答案**  
1 undefined

**解析**  
条件判断为假的情况有：0，false，''，null，undefined，未定义对象。函数声明写在运算符中，其为 true，但放在运算符中的函数声明在执行阶段是找不到的。另外，对未声明的变量执行 typeOf 不会报错，会返回 undefined

## 8. Day8

```js
function f() {
  return f;
}
console.log(new f() instanceof f);
// 写出执行结果，并解释原因
```

**答案**  
false

**解析**  
a instanceof b 用于检测 a 是不是 b 的实例。如果题目 f 中没有 return f,则答案明显为 true;而在本题中 new f()其返回的结果为 f 的函数对象，其并不是 f 的一个实例。

```js
function f() {}
console.log(new f() instanceof f);
// 答案：true
```

## 9. Day9

```js
var foo = {
  bar: function() {
    return this.baz;
  },
  baz: 1
};
console.log(typeof (f = foo.bar)());
//写出执行结果，并解释原因
```

**答案**
undefined

**解析**
将 foo.bar 赋值给 f,相当于 f(),故其 this 指向 window

## 10. AMD、CMD 规范区别

- AMD 规范：是 RequireJS 在推广过程中对模块定义的规范化产出的
- CMD 规范：是 SeaJS 在推广过程中对模块定义的规范化产出的
- CMD 推崇依赖就近;AMD 推崇依赖前置
- CMD 是延迟执行;AMD 是提前执行
- CMD 性能好,因为只有用户需要的时候才执行;AMD 用户体验好,因为没有延迟,依赖模块提前执行了

## 11. SPA 单页页面的理解

SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。

- SPA 优点
  - 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；
  - 基于上面一点，SPA 相对对服务器压力小；
  - 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；
- SPA 缺点
  - 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；
  - 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；
  - SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。

## 12. Vue.js 中 keep-alive 的理解

- 一般结合路由和动态组件一起使用，用于缓存组件；
- 提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；
- 对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。
- keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，能避免重新渲染

## 13. Day 13

```js
const person = { name: "yideng" };
function sayHi(age) {
  return `${this.name} is ${age}`;
}
console.log(sayHi.call(person, 5));
console.log(sayHi.bind(person, 5));
```

**答案**

> yideng is 5 ƒ sayHi(age) {return `${this.name} is ${age}`;}

**解析**  
使用两者，我们可以传递我们想要`this`关键字引用的对象。 但是，

- `.call`方法会立即执行！
- `.bind`方法会返回函数的拷贝值，但带有绑定的上下文！ 它不会立即执行。

## 14. typeof

```js
[typeof null, null instanceof Object];
```

**答案**
[object, false]

**解析**

1） typeof 返回一个表示类型的字符串.

- typeof 的结果列表
  - Undefined "undefined"
  - Null "object"
  - Boolean "boolean"
  - Number "number"
  - String "string"
  - Symbol "symbol"
  - Function "function"
  - Object "object"

2）instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上.

## 15. Day 15

```js
function f() {}
const a = f.prototype,
  b = Object.getPrototypeOf(f);
console.log(a === b);
```

**答案**
false

**解析**

- f.prototype 是使用使用 new 创建的 f 实例的原型. 而 Object.getPrototypeOf 是 f 函数的原型.
- a === Object.getPrototypeOf(new f()) // true
- b === Function.prototype // true

## 16. Day 16

```js
function showCase(value) {
  switch (value) {
    case "A":
      console.log("Case A");
      break;
    case "B":
      console.log("Case B");
      break;
    case undefined:
      console.log("undefined");
      break;
    default:
      console.log("Do not know!");
  }
}
showCase(new String("A"));
```

**答案**  
'Do not know!'

**解析**  
switch 是严格比较, String 实例和 字符串不一样.

```js
var str1 = "str";
var str2 = new String("str");
console.log(typeof str1); // "string"
console.log(typeof str2); //"object"
```

## 17. Day 17

```js
console.log([2, 1, 0].reduce(Math.pow));
console.log([].reduce(Math.pow));
```

**答案**  
1 报错

**解析**

- arr.reduce(callback[, initialValue])
  - reduce 接受两个参数, 一个回调, 一个初始值
  - 回调函数接受四个参数 previousValue, currentValue, currentIndex, array
  - 需要注意的是 If the array is empty and no initialValue was provided, TypeError would be thrown.  
    所以第二个会报异常. 第一个表达式等价于 Math.pow(2, 1) => 2; Math.pow(2, 0) =>1

## 18. 请问变量 a 会被 GC 吗

```js
function test() {
  var a = 1;
  return function() {
    eval("");
  };
}
test();
```

**答案**  
不会回收

**解析**
因为 eval 会欺骗词法作用域，例如 `function test(){eval("var a = 1"}`,创建了一个 a 变量，不确定 eval 是否对 a 进行了引用，所以为了保险，不对其进行优化。相对，`try catch`,`with` 也不会被回收，with 会创建新的作用域。

## 19. Day 19

```js
const value = "Value is" + !!Number(["0"]) ? "yideng" : "undefined";
console.log(value);
```

**答案**  
yideng

**解析**

- +优先级大于？
- 所以原题等价于 'Value is false' ? 'yideng' : undefined'' 而不是 'Value is' + (false ? 'yideng' : 'undefined')

## 20. Day20

```js
var arr = [0, 1];
arr[5] = 5;
newArr = arr.filter(function(x) {
  return x === undefined;
});
console.log(newArr.length);
```

**答案**
0

**解析**

- `filter` 为数组中的每个元素调用一次 `callback` 函数，并利用所有使得 `callback` 返回 true 或[等价于 true 的值](https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy)的元素创建一个新数组。`callback` 只会在已经赋值的索引上被调用，对于那些已经被删除或者从未被赋值的索引不会被调用。那些没有通过 `callback` 测试的元素会被跳过，不会被包含在新数组中。
- 也就是说 从 2-4 都是没有初始化的'坑'!, 这些索引并不存在与数组中. 在 array 的函数调用的时候是会跳过这些'坑'的.

## 21. Day21

写出执行结果,并解释原因(以最新谷歌浏览器为准)

```js
async function async1() {
  console.log("async1 start");
  await async2();
  console.log("async1 end");
}
async function async2() {
  console.log("async2");
}
console.log("script start");
setTimeout(function() {
  console.log("setTimeout");
}, 0);
async1(); // 注意这里执行
new Promise(function(resolve) {
  console.log("promise1");
  resolve();
}).then(function() {
  console.log("promise2");
});
console.log("script end");
```

**答案：**

```
script start
async1 start
async2
promise1
script end
async1 end
promise2
setTimeout
```

**解析：**

**知识点：**
考察的是 js 中的事件循环和回调队列。注意以下几点

- 1.`Promise`优先于`setTimeout`宏任务。所以，`setTimeout`回调会在最后执行。
- 2.`Promise`一旦被定义，就会立即执行
- 3.`Promise`的`reject`和`resolve`是异步执行的回调。所以，`resolve()`会被放到回调队列中，在主函数执行完和`setTimeout`前调用。
- 4.`await`执行完后，会让出线程。`async`标记的函数会返回一个`Promise`对象

**迷惑点**

```js
async function async1() {
  console.log("async1 start");
  await async2();
  console.log("async1 end");
}
async function async2() {
  console.log("async2");
}
// 相当于
function async1() {
  return new Promise((resolve, reject) => {
    console.log("async1 start");
    async1().then(result => {
      console.log("async1 end");
    });
    resolve();
  });
}
function async2() {
  return new Promise(resolve => {
    console.log("async2");
    resolve();
  });
}
```

**执行流程分析**

- 1.首先，事件循环从宏任务(macrotask)队列开始，这个时候，宏任务队列中，只有一个 script(整体代码)任务；从宏任务队列中取一个任务出来执行。
  - a.首先执行 console.log('script start') ，输出 'script start' 。
  - b.遇到 setTimeout 把 console.log('setTimeout') 放到 macroTask 队列中。
  - c.执行 async1()， 输出 'async1 start' 和 'async2' ，把 console.log('async1 end') 放到 micro 队列中。
  - d.执行到 promise ， 输出 'promise1' ， 把 console.log('promise2') 放到 micro 队列中。
  - e.执行 console.log('script end') 。输出 'script end'
- 2.macrotask 执行完会执行 microtask ，把 microtask quene 里面的 microtask 全部拿出来一次性执行完，所以会输出 ‘async1 end’ 和 ‘ promise2’
- 3.开始新一轮事件循环，去除一个 macrotask 执行，所以会输出 “setTimeout”。

## 22. 下面代码中 a 在什么情况下会打印 1

```js
var a = ?;
if(a == 1 && a== 2 && a== 3){
 	console.log(1);
}
```

**答案&解析**
比较操作涉及多不同类型的值时候，会涉及到很多隐式转换，其中规则繁多即便是经验老道的程序员也没办法完全记住，特别是用到 `==` 和 `!=` 运算时候。所以一些团队规定禁用 `==` 运算符换用`===` 严格相等。

- 答案一

  ```js
  var aﾠ = 1;
  var a = 2;
  var ﾠa = 3;
  if (aﾠ == 1 && a == 2 && ﾠa == 3) {
    console.log("1");
  }
  ```

  > 考察你的找茬能力，注意 if 里面的空格，它是一个 Unicode 空格字符，不被 ECMA 脚本解释为空格字符(这意味着它是标识符的有效字符)。所以它可以解释为

  ```js
  var a_ = 1;
  var a = 2;
  var _a = 3;
  if (a_ == 1 && a == 2 && _a == 3) {
    console.log("1");
  }
  ```

- 答案二

  ```js
  var a = {
    i: 1,
    toString: function() {
      return a.i++;
    }
  };
  if (a == 1 && a == 2 && a == 3) {
    console.log("1");
  }
  ```

  > 如果原始类型的值和对象比较，对象会转为原始类型的值，再进行比较。
  > 对象转换成原始类型的值，算法是先调用 valueOf 方法；如果返回的还是对象，再接着调用 toString 方法。

- 答案三

  ```js
  var a = [1, 2, 3];
  a.join = a.shift;
  console.log(a == 1 && a == 2 && a == 3);
  ```

  > 比较巧妙的方式，array 也属于对象，
  > 对于数组对象，toString 方法返回一个字符串，该字符串由数组中的每个元素的 toString() 返回值经调用 join() 方法连接（由逗号隔开）组成。
  > 数组 toString 会调用本身的 join 方法，这里把自己的 join 方法该写为 shift,每次返回第一个元素，而且原数组删除第一个值，正好可以使判断成立

- 答案四

  ```js
  var i = 0;
  with ({
    get a() {
      return ++i;
    }
  }) {
    if (a == 1 && a == 2 && a == 3) console.log("1");
  }
  ```

  > with 也是被严重建议不使用的对象，这里也是利用它的特性在代码块里面利用对象的 get 方法动态返回 i.

- 答案五

  ```js
  var val = 0;
  Object.defineProperty(window, "a", {
    get: function() {
      return ++val;
    }
  });
  if (a == 1 && a == 2 && a == 3) {
    console.log("1");
  }
  ```

  > 全局变量也相当于 window 对象上的一个属性，这里用 defineProperty 定义了 a 的 get 也使得其动态返回值。和 with 有一些类似。

- 答案六

  ```js
  let a = { [Symbol.toPrimitive]: (i => () => ++i)(0) };
  if (a == 1 && a == 2 && a == 3) {
    console.log("1");
  }
  ```

  > ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。我们之前在定义类的内部私有属性时候习惯用 \_\_xxx ,这种命名方式避免别人定义相同的属性名覆盖原来的属性，有了 Symbol 之后我们完全可以用 Symbol 值来代替这种方法，而且完全不用担心被覆盖。
  > 除了定义自己使用的 Symbol 值以外，ES6 还提供了 11 个内置的 Symbol 值，指向语言内部使用的方法。Symbol.toPrimitive 就是其中一个，它指向一个方法，表示该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。这里就是改变这个属性，把它的值改为一个 闭包 返回的函数。

## 23. Day23

```js
const obj = {
  "2": 3,
  "3": 4,
  length: 2,
  splice: Array.prototype.splice,
  push: Array.prototype.push
};
obj.push(1);
obj.push(2);
console.log(obj);
```

**答案**

> Object(4) [empty × 2, 1, 2, splice: ƒ, push: ƒ]

**涉及知识点：**

- 1.类数组（ArrayLike）：一组数据，由数组来存，但是如果要对这组数据进行扩展，会影响到数组原型，ArrayLike 的出现则提供了一个中间数据桥梁，ArrayLike 有数组的特性， 但是对 ArrayLike 的扩展并不会影响到原生的数组。
- 2.push 方法：push 方法有意具有通用性。该方法和 call() 或 apply() 一起使用时，可应用在类似数组的对象上。push 方法根据 length 属性来决定从哪里开始插入给定的值。如果 length 不能被转成一个数值，则插入的元素索引为 0，包括 length 不存在时。当 length 不存在时，将会创建它。
- 唯一的原生类数组（array-like）对象是 Strings，尽管如此，它们并不适用该方法，因为字符串是不可改变的。
- 3.对象转数组的方式：Array.from()、splice()、concat()等

**解析**
这个 obj 中定义了两个 key 值，分别为 splice 和 push 分别对应数组原型中的 splice 和 push 方法，因此这个 obj 可以调用数组中的 push 和 splice 方法，调用对象的 push 方法：push(1)，因为此时 obj 中定义 length 为 2，所以从数组中的第二项开始插入，也就是数组的第三项（下表为 2 的那一项），因为数组是从第 0 项开始的，这时已经定义了下标为 2 和 3 这两项，所以它会替换第三项也就是下标为 2 的值，第一次执行 push 完，此时 key 为 2 的属性值为 1，同理：第二次执行 push 方法，key 为 3 的属性值为 2。此时的输出结果就是：Object(4) [empty × 2, 1, 2, splice: ƒ, push: ƒ]，因为只是定义了 2 和 3 两项，没有定义 0 和 1 这两项，所以前面会是 empty。

## 24.

## 25.

## 26.

## 27.

## 28.

## 29.

## 30.
