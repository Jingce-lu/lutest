# 2020 最新：100 道有答案的前端面试题（上）

[[toc]]

## 1. 1.写一个 mySetInterVal(fn, a, b),每次间隔 a,a+b,a+2b 的时间，然后写一个 myClear，停止上面的 mySetInterVal

公司：头条

分类：JavaScript

```js
function mySetInterVal(fn, a, b) {
  this.a = a;
  this.b = b;
  this.time = 0;
  this.handle = -1;
  this.start = () => {
    this.handle = setTimeout(() => {
      fn();
      this.time++;
      this.start();
      console.log(this.a + this.time * this.b);
    }, this.a + this.time * this.b);
  };

  this.stop = () => {
    clearTimeout(this.handle);
    this.time = 0;
  };
}

var a = new mySetInterVal(
  () => {
    console.log('123');
  },
  1000,
  2000
);
a.start();
a.stop();
```

```js
export interface MySetInterValReturn {
  id: NodeJS.Timeout;
}

export const mySetInterVal = (
  fn: (...args: any[]) => void,
  a: number,
  b: number
): MySetInterValReturn => {
  let timeObj: MySetInterValReturn = { id: null };

  const helper = (timeout: number): void => {
    timeObj.id = setTimeout(() => {
      fn();
      helper(timeout + b);
    }, timeout);
  };

  helper(a);

  return timeObj;
};

export const myClear = (timeObj: NodeJS.Timeout): void => {
  clearTimeout(timeObj);
};

// 测试用例
const timeObj = mySetInterVal(
  (): void => {
    console.log(`time: ${new Date().getSeconds()}`);
  },
  1000,
  1000
);

setTimeout(() => myClear(timeObj.id), 5000);
```

```js
function mySetInterVal(fn, a, b) {
  let timeCount = 0;
  let timer;
  const loop = () => {
    timer = setTimeout(() => {
      fn();
      timeCount++;
      loop();
    }, a + timeCount * b);
  };
  loop();
  return () => {
    clearTimeout(timer);
  };
}
//测试
const myClear = mySetInterVal(
  () => {
    console.log('test');
  },
  1000,
  500
);
// 清除定时器
myClear();
```

## 2.合并二维有序数组成一维有序数组，归并排序的思路

公司：头条

分类：算法

```js
// 方法1：使用concat
const flatten1 = arr => {
  while (arr.some(item => Array.isArray(item))) {
    arr = [].concat(...arr);
  }
  return arr;
};
// 方法2：使用reduce
const flatten2 = arr =>
  arr.reduce(
    (acc, cur) =>
      Array.isArray(cur) ? [...acc, ...flatten2(cur)] : [...acc, cur],
    []
  );
// test
var arr = [1, 2, [3, 4, [5, 6], 7, 8]];
console.log(flatten1(arr));
console.log(flatten2(arr));
```

```js
/**
 * 解题思路：
 * 双指针 从头到尾比较 两个数组的第一个值，根据值的大小依次插入到新的数组中
 * 空间复杂度：O(m + n)
 * 时间复杂度：O(m + n)
 * @param {Array} arr1
 * @param {Array} arr2
 */

function merge(arr1, arr2) {
  var result = [];
  while (arr1.length > 0 && arr2.length > 0) {
    if (arr1[0] < arr2[0]) {
      /*shift()方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。*/
      result.push(arr1.shift());
    } else {
      result.push(arr2.shift());
    }
  }
  return result.concat(arr1).concat(arr2);
}

function mergeSort(arr) {
  let lengthArr = arr.length;
  if (lengthArr === 0) {
    return [];
  }
  while (arr.length > 1) {
    let arrayItem1 = arr.shift();
    let arrayItem2 = arr.shift();
    let mergeArr = merge(arrayItem1, arrayItem2);
    arr.push(mergeArr);
  }
  return arr[0];
}
let arr1 = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9],
  [1, 2, 3],
  [4, 5, 6],
];
let arr2 = [
  [1, 4, 6],
  [7, 8, 10],
  [2, 6, 9],
  [3, 7, 13],
  [1, 5, 12],
];
mergeSort(arr1);
mergeSort(arr2);
```

## 3.多种方式实现斐波那契数列

公司：腾讯、CVTE、微软

分类：算法

```js
/**
 * @description 求斐波那契数列第n项
 * @param {number} n 项目数
 * @return {number} 返回第n项值
 */
function fibonacci(n, map = {}) {
  if (n == 1 || n == 2) return 1;
  if (map[n]) return map[n];
  let data = fibonacci(n - 1, map) + fibonacci(n - 2, map);
  map[n] = data;
  return data;
}
/**
 * @description 求斐波那契数列第n项
 * @param {number} n 项目数
 * @return {number} 返回第n项值
 */
function fibonacci(n) {
  let pre = 1;
  let cur = 1;
  let data;
  if (n == 1 || n == 2) return 1;
  for (let i = 3; i <= n; i++) {
    data = pre + cur;
    pre = cur;
    cur = data;
  }
  return data;
}

/**
 * @description 求斐波那契数列第n项
 * @param {number} n 项目数
 * @return {number} 返回第n项值
 */
function fibonacci(n, v1 = 1, v2 = 1) {
  if (n == 1) return v1;
  if (n == 2) return v2;
  return fibonacci(n - 1, v2, v1 + v2);
}

//基础版斐波那契数列
function fabonacci(n) {
  let num1 = 1,
    num2 = 1,
    sum;
  let arr = [1, 1];
  for (let i = 3; i <= n; i++) {
    sum = num1 + num2;
    num1 = num2;
    num2 = sum;
    arr.push(sum);
  }
  return arr;
}

//基于ES6 Generator实现
function* fabonacciG(num) {
  var a = 1,
    b = 1,
    n = 0;
  while (n < num) {
    yield a;
    [a, b] = [b, a + b];
    n++;
  }
}
```

## 4.字符串出现的不重复最长长度

公司：腾讯

分类：算法

```js
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function (s) {
  const arr = [...s];
  let res = 1;
  let result = arr.reduce((total, cur, i, arr) => {
    if (i == 0) {
      return cur;
    } else {
      if (total.indexOf(cur) < 0) {
        return total + cur;
      } else if (res < total.length) {
        res = total.length;
        return total.slice(total.indexOf(cur) + 1, total.length) + cur;
      } else {
        return total.slice(total.indexOf(cur) + 1, total.length) + cur;
      }
    }
  }, '');
  if (res < result.length) {
    res = result.length;
  }

  return res;
};

console.log(lengthOfLongestSubstring('loddktdji'));
console.log(lengthOfLongestSubstring('dvdf'));
console.log(lengthOfLongestSubstring('adfafwefffdasdcx'));
```

```js
/**
 * 题目：字符串出现的不重复最长长度
 * 整体思路：
 * 用一个滑动窗口装没有重复的字符，枚举字符记录最大值即可
 * 对于遇到重复字符如何收缩窗口大小？
 * 我们可以用 map 维护字符的索引，遇到相同的字符，把左边界移动过去即可
 * 挪动的过程中记录最大长度
 */
var lengthOfLongestSubstring = function (s) {
  let map = new Map();
  let i = -1;
  let res = 0;
  let n = s.length;
  for (let j = 0; j < n; j++) {
    if (map.has(s[j])) {
      i = Math.max(i, map.get(s[j]));
    }
    res = Math.max(res, j - i);
    map.set(s[j], j);
  }
  return res;
};
```

```js
function lengthOfLongestSubstring(s) {
  let max = 0;
  let arr = [];
  for (let i = 0; i < s.length; i++) {
    let index = arr.indexOf(s[i]);
    if (index !== -1) {
      arr.slice(0, index + 1);
    }
    arr.push(s[i]);
    max = Math.max(max, arr.length);
  }
  return max;
}
```

```js
const lengthOfLongestSubString = (s: string) => {
  let left = 0,
    right = 0,
    res = 0,
    map = new Map();
  while (right < s.length) {
    if (map.has(s[right])) {
      left = Math.max(left, right);
    }
    res = Math.max(res, right - left + 1);
    map.set(s[right], right);
    right++;
  }
  return res;
};

console.assert(lengthOfLongestSubString('') === 0);
console.assert(lengthOfLongestSubString('aa') === 1);
console.assert(lengthOfLongestSubString('aabc') === 3);
```

## 5.介绍 chrome 浏览器的几个版本

公司：滴滴

分类：网络&安全

1）Chrome 浏览器提供 4 种发布版本，即稳定版(Stable)、测试版(Beta)、开发者版(Dev)和金丝雀版(Canary)。
虽然 Chrome 这几个版本名称各不相同，但都沿用了相同的版本号，只是更新早晚的区别。就好比 iOS 等系统，Beta 版可以率先更新到 iOS 12 并进行测试，不断改进稳定后，正式版才升级到 12 版本。  
Chrome 也是如此，更新最快的 Canary 会领先正式版 1-2 个版本。

- 1.Canary（金丝雀） 版

  - 只限用于测试，Canary 是 Chrome 的未来版本，是功能、代码最先进的 Chrome 版本，一方面软件本身没有足够时间测试，另一方面网页也不一定支持这些全新的功能，因此极不稳定。好在，谷歌将其设定为可独立安装、与其他版本的 Chrome 程序共存，因此适合进阶用户安装备用，尝鲜最新功能。这种不稳定性使得 Canary 版目前并不适合日常使用。
  - Chrome Canary 是更新速度最快的 Chrome 版本，几乎每天更新。它相当于支持自动更新、并添加了谷歌自家服务与商业闭源插件（Flash 等）的 Chromium，更加强大好用。

- 2.开发者版(Dev)

  - Chrome Dev 最初是以 Chromium 为基础、更新最快的 Chrome，后来则被 Canary 取代。Dev 版每周更新一次，虽然仍不太稳定，但已经可以勉强满足日常使用，适合 Web 开发者用来测试新功能和网页。
  - 让 IT 人员使用开发者版，开发者可以通过开发者版测试自己公司的应用，确保这些应用能与 Chrome 最新的 API 更改及功能更改兼容。注意：开发者版并非百分之百稳定，但开发者可以提前 9 至 12 周体验即将添加到 Chrome 稳定版的功能。

- 3.测试版(Beta)

  - Chrome Beta 以 Dev 为基础，每月更新一次。它是正式发布前的最后测试版本，所有功能都已在前面几个版本中得到测试并改进，因此已经十分稳定，普通用户也可以用来日常使用
  - 让 5% 的用户使用测试版，测试版用户可以提前 4-6 周体验即将在 Chrome 稳定版中推出的功能。测试版用户可以发现特定版本可能存在的问题，让您可以先解决问题，然后再向所有用户推出该版本。

- 4.稳定版(Stable)
  - 最后的 Chrome Stable 就是我们熟知的正式版，它以 Beta 为基础，几个月更新一次。由于所有的功能都已经过数个月反复测试，是稳定性最高的 Chrome 版本。
  - 让大多数用户使用稳定版，稳定版是已进行充分测试的版本，稳定版每 2-3 周会进行一次小幅更新，并且每 6 周会进行一次重大更新。

所以要定期下载开发者版，体验 Chrome 最新的 API 和新功能 ，发现自己的应用跟新 API 和新功能的是否有兼容问题，找到开发亮点。

2）对于 Chrome 的历史版本测试  
可以使用 Docker Selenium 做分布式自动化测试，部署多个重点关注的版本，进行自动化测试，对比差异。

## 6.React 项目中有哪些细节可以优化？实际开发中都做过哪些性能优化

公司：滴滴、掌门一对一、网易、有赞、沪江、喜马拉雅、酷家乐、快手

分类：React

1）对于正常的项目优化，一般都涉及到几个方面，**开发过程中**、**上线之后的首屏**、**运行过程的状态**

- 来聊聊上线之后的首屏及运行状态：

  - 首屏优化一般涉及到几个指标 FP、FCP、FMP；要有一个良好的体验是尽可能的把 FCP 提前，需要做一些工程化的处理，去优化资源的加载
  - 方式及分包策略，资源的减少是最有效的加快首屏打开的方式；
  - 对于 CSR 的应用，FCP 的过程一般是首先加载 js 与 css 资源，js 在本地执行完成，然后加载数据回来，做内容初始化渲染，这中间就有几次的网络反复请求的过程；所以 CSR 可以考虑使用骨架屏及预渲染（部分结构预渲染）、suspence 与 lazy 做懒加载动态组件的方式
  - 当然还有另外一种方式就是 SSR 的方式，SSR 对于首屏的优化有一定的优势，但是这种瓶颈一般在 Node 服务端的处理，建议使用 stream 流的方式来处理，对于体验与 node 端的内存管理等，都有优势；
  - 不管对于 CSR 或者 SSR，都建议配合使用 Service worker，来控制资源的调配及骨架屏秒开的体验
  - react 项目上线之后，首先需要保障的是可用性，所以可以通过 React.Profiler 分析组件的渲染次数及耗时的一些任务，但是 Profile 记录的是 commit 阶段的数据，所以对于 react 的调和阶段就需要结合 performance API 一起分析；
  - 由于 React 是父级 props 改变之后，所有与 props 不相关子组件在没有添加条件控制的情况之下，也会触发 render 渲染，这是没有必要的，可以结合 React 的 PureComponent 以及 React.memo 等做浅比较处理，这中间有涉及到不可变数据的处理，当然也可以结合使用 ShouldComponentUpdate 做深比较处理；
  - 所有的运行状态优化，都是减少不必要的 render，React.useMemo 与 React.useCallback 也是可以做很多优化的地方；
  - 在很多应用中，都会涉及到使用 redux 以及使用 context，这两个都可能造成许多不必要的 render，所以在使用的时候，也需要谨慎的处理一些数据；

  - 最后就是保证整个应用的可用性，为组件创建错误边界，可以使用 componentDidCatch 来处理；

- 实际项目中开发过程中还有很多其他的优化点：

  - 1.保证数据的不可变性
  - 2.使用唯一的键值迭代
  - 3.使用 web worker 做密集型的任务处理
  - 4.不在 render 中处理数据
  - 5.不必要的标签，使用 React.Fragments

## 7.react 最新版本解决了什么问题 加了哪些东西

公司：滴滴

分类：React

1）React 16.x 的三大新特性 Time Slicing, Suspense，hooks

- 1. Time Slicing（解决 CPU 速度问题）使得在执行任务的期间可以随时暂停，跑去干别的事情，这个特性使得 react 能在性能极其差的机器跑时，仍然保持有良好的性能
- 2. Suspense （解决网络 IO 问题）和 lazy 配合，实现异步加载组件。 能暂停当前组件的渲染, 当完成某件事以后再继续渲染，解决从 react 出生到现在都存在的「异步副作用」的问题，而且解决得非
- 的优雅，使用的是「异步但是同步的写法」，我个人认为，这是最好的解决异步问题的方式
- 3. 此外，还提供了一个内置函数 componentDidCatch，当有错误发生时, 我们可以友好地展示 fallback 组件；可以捕捉到它的子元素（包括嵌套子元素）抛出的异常；可以复用错误组件。

2）React16.8

- 加入 hooks，让 React 函数式组件更加灵活
- hooks 之前，React 存在很多问题
  - 1. 在组件间复用状态逻辑很难
  - 2. 复杂组件变得难以理解，高阶组件和函数组件的嵌套过深。
  - 3. class 组件的 this 指向问题
  - 4. 难以记忆的生命周期
- hooks 很好的解决了上述问题，hooks 提供了很多方法
  - 1. useState 返回有状态值，以及更新这个状态值的函数
  - 2. useEffect 接受包含命令式，可能有副作用代码的函数。
  - 3. useContext 接受上下文对象（从 React.createContext 返回的值）并返回当前上下文值，
  - 4. useReducer useState 的替代方案。接受类型为(state，action) => newState 的 reducer，并返回与 dispatch 方法配对的当前状态。
  - 5. useCallback 返回一个回忆的 memoized 版本，该版本仅在其中一个输入发生更改时才会更改。纯函数的输入输出确定性
  - 6. useMemo 纯的一个记忆函数
  - 7. useRef 返回一个可变的 ref 对象，其.current 属性被初始化为传递的参数
  - 8. useImperativeMethods 自定义使用 ref 时公开给父组件的实例值
  - 9. useMutationEffect 更新兄弟组件之前，它在 React 执行其 DOM 改变的同一阶段同步触发
  - 10. useLayoutEffect DOM 改变后同步触发。使用它来从 DOM 读取布局并同步重新渲染

3）React16.9

- 1. 重命名 Unsafe 的生命周期方法。新的 UNSAFE\_ 前缀将有助于在代码 review 和 debug 期间，使这些有问题的字样更突出
- 2. 废弃 javascript: 形式的 URL。以 javascript: 开头的 URL 非常容易遭受攻击，造成安全漏洞。
- 3. 废弃 “Factory” 组件。 工厂组件会导致 React 变大且变慢。
- 4. act() 也支持异步函数，并且你可以在调用它时使用 await。
- 5. 使用 `<React.Profiler>` 进行性能评估。 在较大的应用中追踪性能回归可能会很方便

4）React16.13.0

- 1. 支持在渲染期间调用 setState，但仅适用于同一组件
- 2. 可检测冲突的样式规则并记录警告
- 3. 废弃 unstable_createPortal，使用 createPortal
- 4. 将组件堆栈添加到其开发警告中，使开发人员能够隔离 bug 并调试其程序，这可以清楚地说明问题所在，并更快地定位和修复错误。

## 8.说一下 Http 缓存策略，有什么区别，分别解决了什么问题

公司：滴滴、头条、网易、易车、脉脉、掌门一对一、虎扑、挖财、爱范儿

分类：网络&安全

**1）浏览器缓存策略**

浏览器每次发起请求时，先在本地缓存中查找结果以及缓存标识，根据缓存标识来判断是否使用本地缓存。如果缓存有效，则使
用本地缓存；否则，则向服务器发起请求并携带缓存标识。根据是否需向服务器发起 HTTP 请求，将缓存过程划分为两个部分：
强制缓存和协商缓存，强缓优先于协商缓存。

- 强缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。
- 协商缓存，让客户端与服务器之间能实现缓存文件是否更新的验证、提升缓存的复用率，将缓存信息中的 Etag 和 Last-Modified
  通过请求发送给服务器，由服务器校验，返回 304 状态码时，浏览器直接使用缓存。

HTTP 缓存都是从第二次请求开始的：

- 第一次请求资源时，服务器返回资源，并在 response header 中回传资源的缓存策略；
- 第二次请求时，浏览器判断这些请求参数，击中强缓存就直接 200，否则就把请求参数加到 request header 头中传给服务器，看是否击中协商缓存，击中则返回 304，否则服务器会返回新的资源。这是缓存运作的一个整体流程图：

<div align="center"><img :src="$withBase('/images/prepare/collection/2020071501.png')" alt="prepare/collection/2020071501.png"></div>

**2）强缓存**

- 强缓存命中则直接读取浏览器本地的资源，在 network 中显示的是 from memory 或者 from disk
- 控制强制缓存的字段有：Cache-Control（http1.1）和 Expires（http1.0）
- Cache-control 是一个相对时间，用以表达自上次请求正确的资源之后的多少秒的时间段内缓存有效。
- Expires 是一个绝对时间。用以表达在这个时间点之前发起请求可以直接从浏览器中读取数据，而无需发起请求
- Cache-Control 的优先级比 Expires 的优先级高。前者的出现是为了解决 Expires 在浏览器时间被手动更改导致缓存判断错误的问题。
  如果同时存在则使用 Cache-control。

**3）强缓存-expires**

- 该字段是服务器响应消息头字段，告诉浏览器在过期时间之前可以直接从浏览器缓存中存取数据。

- Expires 是 HTTP 1.0 的字段，表示缓存到期时间，是一个绝对的时间 (当前时间+缓存时间)。在响应消息头中，设置这个字段之后，就可以告诉浏览器，在未过期之前不需要再次请求。

- 由于是绝对时间，用户可能会将客户端本地的时间进行修改，而导致浏览器判断缓存失效，重新请求该资源。此外，即使不考虑修改，时差或者误差等因素也可能造成客户端与服务端的时间不一致，致使缓存失效。

- 优势特点
  - 1、HTTP 1.0 产物，可以在 HTTP 1.0 和 1.1 中使用，简单易用。
  - 2、以时刻标识失效时间。
- 劣势问题
  - 1、时间是由服务器发送的(UTC)，如果服务器时间和客户端时间存在不一致，可能会出现问题。
  - 2、存在版本问题，到期之前的修改客户端是不可知的。

**4）强缓存-cache-control**

- 已知 Expires 的缺点之后，在 HTTP/1.1 中，增加了一个字段 Cache-control，该字段表示资源缓存的最大有效时间，在该时间内，客户端不需要向服务器发送请求。

- 这两者的区别就是前者是绝对时间，而后者是相对时间。下面列举一些 `Cache-control` 字段常用的值：(完整的列表可以查看 MDN)

  - `max-age`：即最大有效时间。
  - `must-revalidate`：如果超过了 `max-age` 的时间，浏览器必须向服务器发送请求，验证资源是否还有效。
  - `no-cache`：不使用强缓存，需要与服务器验证缓存是否新鲜。
  - `no-store`: 真正意义上的“不要缓存”。所有内容都不走缓存，包括强制和对比。
  - `public`：所有的内容都可以被缓存 (包括客户端和代理服务器， 如 CDN)
  - `private`：所有的内容只有客户端才可以缓存，代理服务器不能缓存。默认值。

- **Cache-control 的优先级高于 Expires**，为了兼容 HTTP/1.0 和 HTTP/1.1，实际项目中两个字段都可以设置。

- 该字段可以在请求头或者响应头设置，可组合使用多种指令：
  - **可缓存性**：
    - public：default，浏览器和缓存服务器都可以缓存页面信息
    - private：代理服务器不可缓存，只能被单个用户缓存
    - no-cache：浏览器器和服务器都不应该缓存页面信息，但仍可缓存，只是在缓存前需要向服务器确认资源是否被更改。可配合 private，
      过期时间设置为过去时间。
    - only-if-cache：客户端只接受已缓存的响应
  - **到期**
    - max-age=`<seconds>`：缓存存储的最大周期，超过这个周期被认为过期。
    - s-maxage=`<seconds>`：设置共享缓存，比如 can。会覆盖 max-age 和 expires。
    - max-stale[=`<seconds>`]：客户端愿意接收一个已经过期的资源
    - min-fresh=`<seconds>`：客户端希望在指定的时间内获取最新的响应
    - stale-while-revalidate=`<seconds>`：客户端愿意接收陈旧的响应，并且在后台一部检查新的响应。时间代表客户端愿意接收陈旧响应
      的时间长度。
    - stale-if-error=`<seconds>`：如新的检测失败，客户端则愿意接收陈旧的响应，时间代表等待时间。
  - **重新验证和重新加载**
    - must-revalidate：如页面过期，则去服务器进行获取。
    - proxy-revalidate：用于共享缓存。
    - immutable：响应正文不随时间改变。
  - **其他**
    - no-store：绝对禁止缓存
    - no-transform：不得对资源进行转换和转变。例如，不得对图像格式进行转换。
- 优势特点
  - 1、HTTP 1.1 产物，以时间间隔标识失效时间，解决了 Expires 服务器和客户端相对时间的问题。
  - 2、比 Expires 多了很多选项设置。
- 劣势问题
  - 1、存在版本问题，到期之前的修改客户端是不可知的。

**5）协商缓存**

- 协商缓存的状态码由服务器决策返回 200 或者 304
- 当浏览器的强缓存失效的时候或者请求头中设置了不走强缓存，并且在请求头中设置了 If-Modified-Since 或者 If-None-Match 的时候，会将这两个属性值到服务端去验证是否命中协商缓存，如果命中了协商缓存，会返回 304 状态，加载浏览器缓存，并且响应头会设置 Last-Modified 或者 ETag 属性。
- 对比缓存在请求数上和没有缓存是一致的，但如果是 304 的话，返回的仅仅是一个状态码而已，并没有实际的文件内容，因此 在响应体体积上的节省是它的优化点。
- 协商缓存有 2 组字段(不是两个)，控制协商缓存的字段有：Last-Modified/If-Modified-since（http1.0）和 Etag/If-None-match（http1.1）
- Last-Modified/If-Modified-since 表示的是服务器的资源最后一次修改的时间；Etag/If-None-match 表示的是服务器资源的唯一标
  识，只要资源变化，Etag 就会重新生成。
- Etag/If-None-match 的优先级比 Last-Modified/If-Modified-since 高。

**6）协商缓存-协商缓存-Last-Modified/If-Modified-since**

- 1.服务器通过 `Last-Modified` 字段告知客户端，资源最后一次被修改的时间，例如 `Last-Modified: Mon, 10 Nov 2018 09:10:11 GMT`
- 2.浏览器将这个值和内容一起记录在缓存数据库中。
- 3.下一次请求相同资源时时，浏览器从自己的缓存中找出“不确定是否过期的”缓存。因此在请求头中将上次的 `Last-Modified` 的值写入到请求头的 `If-Modified-Since` 字段
- 4.服务器会将 `If-Modified-Since` 的值与 `Last-Modified` 字段进行对比。如果相等，则表示未修改，响应 304；反之，则表示修改了，响应 200 状态码，并返回数据。
- 优势特点
  - 1、不存在版本问题，每次请求都会去服务器进行校验。服务器对比最后修改时间如果相同则返回 304，不同返回 200 以及资源内容。
- 劣势问题
  - 2、只要资源修改，无论内容是否发生实质性的变化，都会将该资源返回客户端。例如周期性重写，这种情况下该资源包含的数据实际上一样的。
  - 3、以时刻作为标识，无法识别一秒内进行多次修改的情况。 如果资源更新的速度是秒以下单位，那么该缓存是不能被使用的，因为它的时间单位最低是秒。
  - 4、某些服务器不能精确的得到文件的最后修改时间。
  - 5、如果文件是通过服务器动态生成的，那么该方法的更新时间永远是生成的时间，尽管文件可能没有变化，所以起不到缓存的作用。

**7）协商缓存-Etag/If-None-match**

- 为了解决上述问题，出现了一组新的字段 `Etag` 和 `If-None-Match`
- `Etag` 存储的是文件的特殊标识(一般都是 hash 生成的)，服务器存储着文件的 `Etag` 字段。之后的流程和 `Last-Modified` 一致，只是 `Last-Modified` 字段和它所表示的更新时间改变成了 `Etag` 字段和它所表示的文件 hash，把 `If-Modified-Since` 变成了 `If-None-Match`。服务器同样进行比较，命中返回 304, 不命中返回新资源和 200。
- 浏览器在发起请求时，服务器返回在 Response header 中返回请求资源的唯一标识。在下一次请求时，会将上一次返回的 Etag 值赋值给 If-No-Matched 并添加在 Request Header 中。服务器将浏览器传来的 if-no-matched 跟自己的本地的资源的 ETag 做对比，如果匹配，则返回 304 通知浏览器读取本地缓存，否则返回 200 和更新后的资源。
- **Etag 的优先级高于 Last-Modified**。
- 优势特点
  - 1、可以更加精确的判断资源是否被修改，可以识别一秒内多次修改的情况。
  - 2、不存在版本问题，每次请求都回去服务器进行校验。
- 劣势问题
  - 1、计算 ETag 值需要性能损耗。
  - 2、分布式服务器存储的情况下，计算 ETag 的算法如果不一样，会导致浏览器从一台服务器上获得页面内容后到另外一台服务器上进行验证时现 ETag 不匹配的情况。

## 9.介绍防抖节流原理、区别以及应用，并用 JavaScript 进行实现

公司：滴滴、虎扑、挖财、58、头条

分类：JavaScript、编程题

1）防抖

- 原理：在事件被触发 n 秒后再执行回调，如果在这 n 秒内又被触发，则重新计时。
- 适用场景：
  - 按钮提交场景：防止多次提交按钮，只执行最后提交的一次
  - 搜索框联想场景：防止联想发送请求，只发送最后一次输入
- 简易版实现

```js
function debounce(func, wait) {
  let timeout;
  return function () {
    const context = this;
    const args = arguments;
    clearTimeout(timeout);
    timeout = setTimeout(function () {
      func.apply(context, args);
    }, wait);
  };
}
```

- 立即执行版实现
  - 有时希望立刻执行函数，然后等到停止触发 n 秒后，才可以重新触发执行。

```js
// 有时希望立刻执行函数，然后等到停止触发 n 秒后，才可以重新触发执行。
function debounce(func, wait, immediate) {
  let timeout;
  return function () {
    const context = this;
    const args = arguments;
    if (timeout) clearTimeout(timeout);
    if (immediate) {
      const callNow = !timeout;
      timeout = setTimeout(function () {
        timeout = null;
      }, wait);
      if (callNow) func.apply(context, args);
    } else {
      timeout = setTimeout(function () {
        func.apply(context, args);
      }, wait);
    }
  };
}
```

- 返回值版实现
  - func 函数可能会有返回值，所以需要返回函数结果，但是当 immediate 为 false 的时候，因为使用了 setTimeout ，我们将 func.apply(context, args) 的返回值赋给变量，最后再 return 的时候，值将会一直是 undefined，所以只在 immediate 为 true 的时候返回函数的执行结果。

```js
function debounce(func, wait, immediate) {
  let timeout, result;
  return function () {
    const context = this;
    const args = arguments;
    if (timeout) clearTimeout(timeout);
    if (immediate) {
      const callNow = !timeout;
      timeout = setTimeout(function () {
        timeout = null;
      }, wait);
      if (callNow) result = func.apply(context, args);
    } else {
      timeout = setTimeout(function () {
        func.apply(context, args);
      }, wait);
    }
    return result;
  };
}
```

2）节流

- 原理：规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。
- 适用场景
  - 拖拽场景：固定时间内只执行一次，防止超高频次触发位置变动
  - 缩放场景：监控浏览器 resize
- 使用时间戳实现
  - 使用时间戳，当触发事件的时候，我们取出当前的时间戳，然后减去之前的时间戳(最一开始值设为 0 )，如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，如果小于，就不执行。

```js
function throttle(func, wait) {
  let context, args;
  let previous = 0;

  return function () {
    let now = +new Date();
    context = this;
    args = arguments;
    if (now - previous > wait) {
      func.apply(context, args);
      previous = now;
    }
  };
}
```

- 使用定时器实现
  - 当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行，直到定时器执行，然后执行函数，清空定时器，这样就可以设置下个定时器。

```js
function throttle(func, wait) {
  let timeout;
  return function () {
    const context = this;
    const args = arguments;
    if (!timeout) {
      timeout = setTimeout(function () {
        timeout = null;
        func.apply(context, args);
      }, wait);
    }
  };
}
```

## 10.前端安全、中间人攻击

公司：滴滴

分类：网络&安全

#### 1）XSS：跨站脚本攻击

就是攻击者想尽一切办法将可以执行的代码注入到网页中。

##### 存储型（server 端）：

- 场景：见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。
- 攻击步骤：
  - i）攻击者将恶意代码提交到目标网站的数据库中
  - ii）用户打开目标网站时，服务端将恶意代码从数据库中取出来，拼接在 HTML 中返回给浏览器
  - iii）用户浏览器在收到响应后解析执行，混在其中的恶意代码也同时被执行
  - iv）恶意代码窃取用户数据，并发送到指定攻击者的网站，或者冒充用户行为，调用目标网站的接口，执行恶意操作

##### 反射型（Server 端）

与存储型的区别在于，存储型的恶意代码存储在数据库中，反射型的恶意代码在 URL 上

- 场景：通过 URL 传递参数的功能，如网站搜索、跳转等。
- 攻击步骤：
  - i）攻击者构造出特殊的 URL，其中包含恶意代码。
  - ii）用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。
  - iii）用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
  - iv）恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

##### Dom 型(浏览器端）

DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。

- 场景：通过 URL 传递参数的功能，如网站搜索、跳转等。
- 攻击步骤：
  - i）攻击者构造出特殊的 URL，其中包含恶意代码。
  - ii）用户打开带有恶意代码的 URL。
  - iii）用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。
  - iv）恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

##### 预防方案：（防止攻击者提交恶意代码，防止浏览器执行恶意代码）

- i）对数据进行严格的输出编码：如 HTML 元素的编码，JS 编码，CSS 编码，URL 编码等等
  - 避免拼接 HTML；Vue/React 技术栈，避免使用 v-html / dangerouslySetInnerHTML
- ii）CSP HTTP Header，即 Content-Security-Policy、X-XSS-Protection
  - 增加攻击难度，配置 CSP(本质是建立白名单，由浏览器进行拦截)
  - `Content-Security-Policy: default-src 'self'`-所有内容均来自站点的同一个源（不包括其子域名）
  - `Content-Security-Policy: default-src 'self' *.trusted.com`-允许内容来自信任的域名及其子域名 (域名不必须与 CSP 设置所在的域名相同)
  - `Content-Security-Policy: default-src https://yideng.com`-该服务器仅允许通过 HTTPS 方式并仅从 yideng.com 域名来访问文档
- iii）输入验证：比如一些常见的数字、URL、电话号码、邮箱地址等等做校验判断
- iv）开启浏览器 XSS 防御：Http Only cookie，禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。
- v）验证码

#### 2）CSRF：跨站请求伪造

攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。

##### 攻击流程举例

- i）受害者登录 a.com，并保留了登录凭证（Cookie）
- ii）攻击者引诱受害者访问了 b.com
- iii）b.com 向 a.com 发送了一个请求：a.com/act=xx 浏览器会默认携带 a.com 的 Cookie
- iv）a.com 接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求
- v）a.com 以受害者的名义执行了 act=xx
- vi）攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让 a.com 执行了自己定义的操作

##### 攻击类型

- i）GET 型：如在页面的某个 img 中发起一个 get 请求
- ii）POST 型：通过自动提交表单到恶意网站
- iii）链接型：需要诱导用户点击链接

##### 预防方案：

CSRF 通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对 CSRF 的防护能力来提升安全性。）

- i）同源检测：通过 Header 中的 Origin Header 、Referer Header 确定，但不同浏览器可能会有不一样的实现，不能完全保证
- ii）CSRF Token 校验：将 CSRF Token 输出到页面中（通常保存在 Session 中），页面提交的请求携带这个 Token，服务器验证 Token 是否
  正确
- iii）双重 cookie 验证：
  - 流程：
    - 步骤 1：在用户访问网站页面时，向请求域名注入一个 Cookie，内容为随机字符串（例如 csrfcookie=v8g9e4ksfhw）
    - 步骤 2：在前端向后端发起请求时，取出 Cookie，并添加到 URL 的参数中（接上例 POST https://www.a.com/comment?csrfcookie=v8g9e4ksfhw）
    - 步骤 3：后端接口验证 Cookie 中的字段与 URL 参数中的字段是否一致，不一致则拒绝。
  - 优点：
    - 无需使用 Session，适用面更广，易于实施。
    - Token 储存于客户端中，不会给服务器带来压力。
    - 相对于 Token，实施成本更低，可以在前后端统一拦截校验，而不需要一个个接口和页面添加。
  - 缺点：
    -Cookie 中增加了额外的字段。 -如果有其他漏洞（例如 XSS），攻击者可以注入 Cookie，那么该防御方式失效。 -难以做到子域名的隔离。 -为了确保 Cookie 传输安全，采用这种防御方式的最好确保用整站 HTTPS 的方式，如果还没切 HTTPS 的使用这种方式也会有风险。
- iv）Samesite Cookie 属性：Google 起草了一份草案来改进 HTTP 协议，那就是为 Set-Cookie 响应头新增 Samesite 属性，它用来标明这个 Cookie 是个“同站 Cookie”，同站 Cookie 只能作为第一方 Cookie，不能作为第三方 Cookie，Samesite 有两个属性值，Strict 为任何情况下都不可以作为第三方 Cookie ，Lax 为可以作为第三方 Cookie , 但必须是 Get 请求

#### 3）iframe 安全

##### 说明：

- i）嵌入第三方 iframe 会有很多不可控的问题，同时当第三方 iframe 出现问题或是被劫持之后，也会诱发安全性问题
- ii）点击劫持
  - 攻击者将目标网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，诱导用户点击。
- iii）禁止自己的 iframe 中的链接外部网站的 JS

##### 预防方案：

- i）为 iframe 设置 sandbox 属性，通过它可以对 iframe 的行为进行各种限制，充分实现“最小权限“原则
- ii）服务端设置 X-Frame-Options Header 头，拒绝页面被嵌套，X-Frame-Options 是 HTTP 响应头中用来告诉浏览器一个页面是否可以嵌入 `<iframe>` 中
  - eg.`X-Frame-Options: SAMEORIGIN`
  - SAMEORIGIN: iframe 页面的地址只能为同源域名下的页面
  - ALLOW-FROM: 可以嵌套在指定来源的 iframe 里
  - DENY: 当前页面不能被嵌套在 iframe 里
- iii）设置 CSP 即 Content-Security-Policy 请求头
- iv）减少对 iframe 的使用

#### 4）错误的内容推断

##### 说明：

文件上传类型校验失败后，导致恶意的 JS 文件上传后，浏览器 Content-Type Header 的默认解析为可执行的 JS 文件

##### 预防方案：

设置 X-Content-Type-Options 头

#### 5）第三方依赖包

减少对第三方依赖包的使用，如之前 npm 的包如：event-stream 被爆出恶意攻击数字货币；

#### 6）HTTPS

##### 描述：

黑客可以利用 SSL Stripping 这种攻击手段，强制让 HTTPS 降级回 HTTP，从而继续进行中间人攻击。

##### 预防方案：

使用 HSTS（HTTP Strict Transport Security），它通过下面这个 HTTP Header 以及一个预加载的清单，来告知浏览器和网站进行通信的时候强制性的使用 HTTPS，而不是通过明文的 HTTP 进行通信。这里的“强制性”表现为浏览器无论在何种情况下都直接向务器端发起 HTTPS 请求，而不再像以往那样从 HTTP 跳转到 HTTPS。另外，当遇到证书或者链接不安全的时候，则首先警告用户，并且不再
用户选择是否继续进行不安全的通信。

#### 7）本地存储数据

避免重要的用户信息存在浏览器缓存中

#### 8）静态资源完整性校验

##### 描述

使用 内容分发网络 (CDNs) 在多个站点之间共享脚本和样式表等文件可以提高站点性能并节省带宽。然而，使用 CDN 也存在风险，如果攻击者获得对 CDN 的控制权，则可以将任意恶意内容注入到 CDN 上的文件中 （或完全替换掉文件），因此可能潜在地攻击所有从该 CDN 获取文件的站点。

##### 预防方案

将使用 base64 编码过后的文件哈希值写入你所引用的 `<script>` 或 `<link>` 标签的 integrity 属性值中即可启用子资源完整性能。

#### 9）网络劫持

##### 描述：

- DNS 劫持（涉嫌违法）：修改运行商的 DNS 记录，重定向到其他网站。DNS 劫持是违法的行为，目前 DNS 劫持已被监管，现在很少见 DNS 劫持
- HTTP 劫持：前提有 HTTP 请求。因 HTTP 是明文传输，运营商便可借机修改 HTTP 响应内容（如加广告）。

##### 预防方案

全站 HTTPS

#### 10）中间人攻击：

中间人攻击（Man-in-the-middle attack, MITM），指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者窃听、篡改甚至完全控制。没有进行严格的证书校验是中间人攻击着手点。目前大多数加密协议都提供了一些特殊认证方法以阻止中间人攻击。如 SSL （安全套接字层）协议可以验证参与通讯的用户的证书是否有权威、受信任的数字证书认证机构颁发，并且能执行双向身份认证。攻击场景如用户在一个未加密的 WiFi 下访问网站。在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容。

##### 场景

- i）在一个未加密的 Wi-Fi 无线接入点的接受范围内的中间人攻击者，可以将自己作为一个中间人插入这个网络
- ii）Fiddler / Charles （花瓶）代理工具
- iii）12306 之前的自己证书

##### 过程

- i）客户端发送请求到服务端，请求被中间人截获
- ii）服务器向客户端发送公钥
- iii）中间人截获公钥，保留在自己手上。然后自己生成一个【伪造的】公钥，发给客户端
- iv）客户端收到伪造的公钥后，生成加密 hash 值发给服务器
- v）中间人获得加密 hash 值，用自己的私钥解密获得真秘钥,同时生成假的加密 hash 值，发给服务器
- vi）服务器用私钥解密获得假密钥,然后加密数据传输给客户端

##### 使用抓包工具 fiddle 来进行举例说明

- 1. 首先通过一些途径在客户端安装证书
- 2. 然后客户端发送连接请求，fiddle 在中间截取请求，并返回自己伪造的证书
- 3. 客户端已经安装了攻击者的根证书，所以验证通过
- 4. 客户端就会正常和 fiddle 进行通信，把 fiddle 当作正确的服务器
- 5. 同时 fiddle 会跟原有的服务器进行通信，获取数据以及加密的密钥，去解密密钥

##### 常见攻击方式

- 1. 嗅探：嗅探是一种用来捕获流进和流出的网络数据包的技术，就好像是监听电话一样。比如：抓包工具
- 2. 数据包注入：在这种，攻击者会将恶意数据包注入到常规数据中的，因为这些恶意数据包是在正常的数据包里面的，用户和系统都很难发现这个内容。
- 3. 会话劫持：当我们进行一个网站的登录的时候到退出登录这个时候，会产生一个会话，这个会话是攻击者用来攻击的首要目标，因为这个会话，包含了用户大量的数据和私密信息。
- 4. SSL 剥离：HTTPS 是通过 SSL/TLS 进行加密过的，在 SSL 剥离攻击中，会使 SSL/TLS 连接断开，让受保护的 HTTPS，变成不受
     保护的 HTTP（这对于网站非常致命）
- 5. DNS 欺骗，攻击者往往通过入侵到 DNS 服务器，或者篡改用户本地 hosts 文件，然后去劫持用户发送的请求，然后转发到攻击者想要转发到的服务器
- 6. ARP 欺骗，ARP(address resolution protocol)地址解析协议，攻击者利用 APR 的漏洞，用当前局域网之间的一台服务器，来冒充客户端想要请求的服务端，向客户端发送自己的 MAC 地址，客户端无从得到真正的主机的 MAC 地址，所以，他会把这个地址当作真正
     的主机来进行通信，将 MAC 存入 ARP 缓存表。
- 7. 代理服务器

##### 预防方案：

- i）用可信的第三方 CA 厂商
- ii）不下载未知来源的证书，不要去下载一些不安全的文件
- iii）确认你访问的 URL 是 HTTPS 的，确保网站使用了 SSL，确保禁用一些不安全的 SSL，只开启：TLS1.1，TLS1.2
- iv）不要使用公用网络发送一些敏感的信息
- v）不要去点击一些不安全的连接或者恶意链接或邮件信息

#### 11）sql 注入

##### 描述

就是通过把 SQL 命令插入到 Web 表单递交或输入域名或页面请求的查询字符串，最终达到欺骗数据库服务器执行恶意的 SQL 命令,从而达到和服务器
进行直接的交互

##### 预防方案：

- i）后台进行输入验证，对敏感字符过滤。
- ii）使用参数化查询，能避免拼接 SQL，就不要拼接 SQL 语句。

#### 12）前端数据安全：

##### 描述

反爬虫。如猫眼电影、天眼查等等，以数据内容为核心资产的企业

##### 预防方案：

- i）font-face 拼接方式：猫眼电影、天眼查
- ii）background 拼接：美团
- iii）伪元素隐藏：汽车之家
- iv）元素定位覆盖式：去哪儿
- v）iframe 异步加载：网易云音乐

#### 13）其他建议

- i）定期请第三方机构做安全性测试，漏洞扫描
- ii）使用第三方开源库做上线前的安全测试，可以考虑融合到 CI 中
- iii）code review 保证代码质量
- iv）默认项目中设置对应的 Header 请求头，如 X-XSS-Protection、 X-Content-Type-Options 、X-Frame-Options Header、Content-Security-Policy 等等
- v）对第三方包和库做检测：NSP(Node Security Platform)，Snyk

## 11.对闭包的看法，为什么要用闭包？说一下闭包原理以及应用场景

公司：滴滴、携程、喜马拉雅、微医、蘑菇街、酷家乐、腾讯应用宝、安居客

分类：JavaScript

#### 1）什么是闭包

函数执行后返回结果是一个内部函数，并被外部变量所引用，如果内部函数持有被执行函数作用域的变量，即形成了闭包。

可以在内部函数访问到外部函数作用域。使用闭包，一可以读取函数中的变量，二可以将函数中的变量存储在内存中，保护变量不被污染。而正因闭包会把函数中的变量值存储在内存中，会对内存有消耗，所以不能滥用闭包，否则会影响网页性能，造成内存泄漏。当不需要使用闭包时，要及时释放内存，可将内层函数对象的变量赋值为 null。

#### 2）闭包原理

函数执行分成两个阶段(预编译阶段和执行阶段)。

- 在预编译阶段，如果发现内部函数使用了外部函数的变量，则会在内存中创建一个“闭包”对象并保存对应变量值，如果已存在“闭包”，则只需要增加对应属性值即可。
- 执行完后，函数执行上下文会被销毁，函数对“闭包”对象的引用也会被销毁，但其内部函数还持用该“闭包”的引用，所以内部函数可以继续使用“外部函数”中的变量

利用了函数作用域链的特性，一个函数内部定义的函数会将包含外部函数的活动对象添加到它的作用域链中，函数执行完毕，其执行作用域链销毁，但因内部函数的作用域链仍然在引用这个活动对象，所以其活动对象不会被销毁，直到内部函数被烧毁后才被销毁。

#### 3）优点

1. 可以从内部函数访问外部函数的作用域中的变量，且访问到的变量长期驻扎在内存中，可供之后使用
2. 避免变量污染全局
3. 把变量存到独立的作用域，作为私有成员存在

#### 4）缺点

1. 对内存消耗有负面影响。因内部函数保存了对外部变量的引用，导致无法被垃圾回收，增大内存使用量，所以使用不当会导致内存泄漏
2. 对处理速度具有负面影响。闭包的层级决定了引用的外部变量在查找时经过的作用域链长度
3. 可能获取到意外的值(captured value)

#### 4）应用场景

**应用场景一：** 典型应用是模块封装，在各模块规范出现之前，都是用这样的方式防止变量污染全局。

```js
var Yideng = (function () {
  // 这样声明为模块私有变量，外界无法直接访问
  var foo = 0;

  function Yideng() {}
  Yideng.prototype.bar = function bar() {
    return foo;
  };
  return Yideng;
})();
```

**应用场景二：** 在循环中创建闭包，防止取到意外的值。

如下代码，无论哪个元素触发事件，都会弹出 3。因为函数执行后引用的 i 是同一个，而 i 在循环结束后就是 3

```js
for (var i = 0; i < 3; i++) {
  document.getElementById('id' + i).onfocus = function () {
    alert(i);
  };
}
//可用闭包解决
function makeCallback(num) {
  return function () {
    alert(num);
  };
}
for (var i = 0; i < 3; i++) {
  document.getElementById('id' + i).onfocus = makeCallback(i);
}
```

## 12.css 伪类与伪元素区别

公司：滴滴

分类：Css

1）伪类(pseudo-classes)

- 其核⼼就是⽤来选择 DOM 树之外的信息,不能够被普通选择器选择的⽂档之外的元素，⽤来添加⼀些选择器的特殊效果。
- ⽐如:hover :active :visited :link :visited :first-child :focus :lang 等
- 由于状态的变化是⾮静态的，所以元素达到⼀个特定状态时，它可能得到⼀个伪类的样式；当状态改变时，它⼜会失去这个样式。
- 由此可以看出，它的功能和 class 有些类似，但它是基于⽂档之外的抽象，所以叫 伪类。

2）伪元素(Pseudo-elements)

- DOM 树没有定义的虚拟元素
- 核⼼就是需要创建通常不存在于⽂档中的元素，
- ⽐如::before ::after 它选择的是元素指定内容，表示选择元素内容的之前内容或之后内容。
- 伪元素控制的内容和元素是没有差别的，但是它本身只是基于元素的抽象，并不存在于⽂档中，所以称为伪元素。⽤于将特殊的效果添加到某些选择器

2）伪类与伪元素的区别

- 表示⽅法

  - CSS2 中伪类、伪元素都是以单冒号:表示,
  - CSS2.1 后规定伪类⽤单冒号表示,伪元素⽤双冒号::表示，
  - 浏览器同样接受 CSS2 时代已经存在的伪元素(:before, :after, :first￾line, :first-letter 等)的单冒号写法。
  - CSS2 之后所有新增的伪元素(如::selection)，应该采⽤双冒号的写法。
  - CSS3 中，伪类与伪元素在语法上也有所区别，伪元素修改为以::开头。浏览器对以:开头的伪元素也继续⽀持，但建议规范书写为::开头

- 定义不同
  - 伪类即假的类，可以添加类来达到效果
  - 伪元素即假元素，需要通过添加元素才能达到效果
- 总结:
  - 伪类和伪元素都是⽤来表示⽂档树以外的"元素"。
  - 伪类和伪元素分别⽤单冒号:和双冒号::来表示。
  - 伪类和伪元素的区别，关键点在于如果没有伪元素(或伪类)，
  - 是否需要添加元素才能达到效果，如果是则是伪元素，反之则是伪类。

4）相同之处：

- 伪类和伪元素都不出现在源⽂件和 DOM 树中。也就是说在 html 源⽂件中是看不到伪类和伪元素的。
  不同之处：
- 伪类其实就是基于普通 DOM 元素⽽产⽣的不同状态，他是 DOM 元素的某⼀特征。
- 伪元素能够创建在 DOM 树中不存在的抽象对象，⽽且这些抽象对象是能够访问到的。

## 13.有一堆整数，请把他们分成三份，确保每一份和尽量相等（11，42，23，4，5，6 4 5 6 11 23 42 56 78 90）

公司：滴滴

分类：算法

```js
// 计算数组元素和
function sum(o) {
  var sum = 0;

  if (Array.isArray(o)) {
    o.map(function (item, index, array) {
      sum += item;
    });
  } else {
    sum += o;
  }

  return sum;
}

// 多维数组排序
function sortMArray(arr) {
  for (var i = 0, len = arr.length; i < len - 1; i++) {
    for (var j = i + 1; j < len; j++) {
      if (sum(arr[i]) < sum(arr[j])) {
        var temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
      }
    }
  }

  return arr;
}
// 任意数分三组，每组和尽量相等（也就是最大值与最小值差值最小）
function equal(arr) {
  var array = [];

  arr = sortMArray(arr);

  for (var i = 0; i < arr.length; i++) {
    // 转换成多维数组
    array.push([arr[i]]);
  }

  while (array.length > 3) {
    array[2].push(array[3][0]);
    array.splice(3, 1);
    array = sortMArray(array);
  }

  return array;
}

/**
 [
   [56, 42, 23, 6, 5, 4],     // 136
   [78, 42, 11, 4],           // 135
   [90, 23, 11, 6, 5]         // 135
 ] 
 */
```

```js
function f1(arr, count) {
  //数组从大到小排序
  arr.sort((a, b) => b - a);
  //计算平均值
  let avg = arr.reduce((a, b) => a + b) / count;
  //从大到小求和，取最接近平均值的一组，放入二维数组
  let resArr = [];
  let current = 0;
  for (let i = 0; i < count - 1; i++) {
    if (current + arr[arr.length - 1] / 2 < avg && i) {
      arr.pop();
      resArr[i - 1].push(arr[arr.length - 1]);
    }
    current = 0;
    resArr[i] = [];
    arr.forEach((item, index) => {
      current += item;
      arr.splice(index, 1);
      resArr[i].push(item);
      if (current > avg) {
        current -= item;
        arr.splice(index, 0, item);
        resArr[i].pop();
      }
    });
  }
  resArr[count - 1] = arr;
  return resArr;
}
//测试，第一个参数为数组，第二个为份数
f1([11, 42, 23, 4, 5, 6, 4, 5, 6, 11, 23, 42, 56, 78, 90], 3);

/**
  [
    [90, 42, 4],                    // 136
    [78, 42, 11, 4],                // 135
    [56, 23, 23, 11, 6, 6, 5, 5]    // 135
  ]
 */
```

## 14.实现 lodash 的\_.get

公司：滴滴

分类：JavaScript

在 js 中经常会出现嵌套调用这种情况，如 a.b.c.d.e，但是这么写很容易抛出异常。你需要这么写 a && a.b && a.b.c && a.b.c.d && a.b.c.d.e，但是显得有些啰嗦与冗长了。特别是在 graphql 中，这种嵌套调用更是难以避免。
这时就需要一个 get 函数，使用 get(a, 'b.c.d.e') 简单清晰，并且容错性提高了很多。

1）代码实现

```js
function get(source, path, defaultValue = undefined) {
  // a[3].b -> a.3.b -> [a,3,b]
  // path 中也可能是数组的路径，全部转化成 . 运算符并组成数组
  const paths = path.replace(/\[(\d+)\]/g, '.$1').split('.');
  let result = source;
  for (const p of paths) {
    // 注意 null 与 undefined 取属性会报错，所以使用 Object 包装一下。
    result = Object(result)[p];
    if (result == undefined) {
      return defaultValue;
    }
  }
  return result;
}
// 测试用例
console.log(get({ a: null }, 'a.b.c', 3)); // output: 3
console.log(get({ a: undefined }, 'a', 3)); // output: 3
console.log(get({ a: null }, 'a', 3)); // output: 3
console.log(get({ a: [{ b: 1 }] }, 'a[0].b', 3)); // output: 1
```

2）代码实现  
不考虑数组的情况

```js
const _get = (object, keys, val) => {
  return keys.split(/\./).reduce((o, j) => (o || {})[j], object) || val;
};
console.log(get({ a: null }, 'a.b.c', 3)); // output: 3
console.log(get({ a: undefined }, 'a', 3)); // output: 3
console.log(get({ a: null }, 'a', 3)); // output: 3
console.log(get({ a: { b: 1 } }, 'a.b', 3)); // output: 1
```

## 15.实现 add(1)(2)(3)

公司：滴滴

分类：JavaScript

答案&解析

考点：函数柯里化

函数柯里化概念： 柯里化（Currying）是把接受多个参数的函数转变为接受一个单一参数的函数，并且返回接受余下的参数且返回结果的新函数的技术。

1）粗暴版

```js
function add(a) {
  return function (b) {
    return function (c) {
      return a + b + c;
    };
  };
}
console.log(add(1)(2)(3)); // 6
```

2）柯里化解决方案

- 参数长度固定

```js
const curry = fn =>
  (judge = (...args) =>
    args.length === fn.length
      ? fn(...args)
      : (...arg) => judge(...args, ...arg));
const add = (a, b, c) => a + b + c;
const curryAdd = curry(add);
console.log(curryAdd(1)(2)(3)); // 6
console.log(curryAdd(1, 2)(3)); // 6
console.log(curryAdd(1)(2, 3)); // 6
```

- 参数长度不固定

```js
function add(...args) {
  //求和
  return args.reduce((a, b) => a + b);
}

function currying(fn) {
  let args = [];
  return function temp(...newArgs) {
    if (newArgs.length) {
      args = [...args, ...newArgs];
      return temp;
    } else {
      let val = fn.apply(this, args);
      args = []; //保证再次调用时清空
      return val;
    }
  };
}

let addCurry = currying(add);
console.log(addCurry(1)(2)(3)(4, 5)()); //15
console.log(addCurry(1)(2)(3, 4, 5)()); //15
console.log(addCurry(1)(2, 3, 4, 5)()); //15
```

```java
// 使用柯里化 + 递归
function curry ( fn ) {
  var c = (...arg) => (fn.length === arg.length) ?
          fn (...arg) : (...arg1) => c(...arg, ...arg1)
  return c
}
```

## 16.实现链式调用

公司：滴滴

分类：JavaScript

答案&解析

链式调用的核心就在于调用完的方法将自身实例返回

1）示例一

```js
function Class1() {
  console.log('初始化');
}
Class1.prototype.method = function (param) {
  console.log(param);
  return this;
};
let cl = new Class1();
//由于new 在实例化的时候this会指向创建的对象， 所以this.method这个方法会在原型链中找到。
cl.method('第一次调用').method('第二次链式调用').method('第三次链式调用');
```

2）示例二

```js
var obj = {
  a: function () {
    console.log('a');
    return this;
  },
  b: function () {
    console.log('b');
    return this;
  },
};
obj.a().b();
```

3）示例三

```js
// 类
class Math {
  constructor(value) {
    this.hasInit = true;
    this.value = value;
    if (!value) {
      this.value = 0;
      this.hasInit = false;
    }
  }
  add() {
    let args = [...arguments];
    let initValue = this.hasInit ? this.value : args.shift();
    const value = args.reduce((prev, curv) => prev + curv, initValue);
    return new Math(value);
  }
  minus() {
    let args = [...arguments];
    let initValue = this.hasInit ? this.value : args.shift();
    const value = args.reduce((prev, curv) => prev - curv, initValue);
    return new Math(value);
  }
  mul() {
    let args = [...arguments];
    let initValue = this.hasInit ? this.value : args.shift();
    const value = args.reduce((prev, curv) => prev * curv, initValue);
    return new Math(value);
  }
  divide() {
    let args = [...arguments];
    let initValue = this.hasInit ? this.value : args.shift();
    const value = args.reduce(
      (prev, curv) => prev / (+curv ? curv : 1),
      initValue
    );
    return new Math(value);
  }
}

let test = new Math();
const res = test.add(222, 333, 444).minus(333, 222).mul(3, 3).divide(2, 3);
console.log(res.value);

// 原型链
Number.prototype.add = function () {
  let _that = this;
  _that = [...arguments].reduce((prev, curv) => prev + curv, _that);
  return _that;
};
Number.prototype.minus = function () {
  let _that = this;
  _that = [...arguments].reduce((prev, curv) => prev - curv, _that);
  return _that;
};
Number.prototype.mul = function () {
  let _that = this;
  _that = [...arguments].reduce((prev, curv) => prev * curv, _that);
  return _that;
};
Number.prototype.divide = function () {
  let _that = this;
  _that = [...arguments].reduce(
    (prev, curv) => prev / (+curv ? curv : 1),
    _that
  );
  return _that;
};
let num = 0;
let newNum = num.add(222, 333, 444).minus(333, 222).mul(3, 3).divide(2, 3);
console.log(newNum);
```

## 17.React 事件绑定原理

公司：滴滴、沪江

分类：React

答案&解析

React 并不是将 click 事件绑在该 div 的真实 DOM 上，而是在 document 处监听所有支持的事件，当事件发生并冒泡至 document 处时，React 将事件内容封装并交由真正的处理函数运行。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。  
另外冒泡到 document 上的事件也不是原生浏览器事件，而是 React 自己实现的合成事件（SyntheticEvent）。因此我们如果不想要事件冒泡的话，调用 `event.stopPropagation` 是无效的，而应该调用 `event.preventDefault`。

<div align="center"><img :src="$withBase('/images/prepare/collection/2020071701.png')" alt="prepare/collection/2020071701.png"></div>

## 18.类数组和数组的区别，dom 的类数组如何转换成数组

公司：海康威视

分类：JavaScript

答案&解析

1）定义

- 数组是一个特殊对象,与常规对象的区别：
  - 1. 当由新元素添加到列表中时，自动更新 length 属性
  - 2. 设置 length 属性，可以截断数组
  - 3. 从 Array.protoype 中继承了方法
  - 4. 属性为'Array'
- 类数组是一个拥有 length 属性，并且他属性为非负整数的普通对象，类数组不能直接调用数组方法。

2）区别
本质：类数组是简单对象，它的原型关系与数组不同。

```js
// 原型关系和原始值转换
let arrayLike = {
  length: 10,
};
console.log(arrayLike instanceof Array); // false
console.log(arrayLike.__proto__.constructor === Array); // false
console.log(arrayLike.toString()); // [object Object]
console.log(arrayLike.valueOf()); // {length: 10}

let array = [];
console.log(array instanceof Array); // true
console.log(array.__proto__.constructor === Array); // true
console.log(array.toString()); // ''
console.log(array.valueOf()); // []
```

3）类数组转换为数组

- 转换方法
  - 1. 使用 `Array.from()`
  - 2. 使用 `Array.prototype.slice.call()`
  - 3. 使用 `Array.prototype.forEach()` 进行属性遍历并组成新的数组
- 转换须知
  - 转换后的数组长度由 `length` 属性决定。索引不连续时转换结果是连续的，会自动补位。
  - 代码示例

```js
let al1 = {
  length: 4,
  0: 0,
  1: 1,
  3: 3,
  4: 4,
  5: 5,
};
console.log(Array.from(al1)); // [0, 1, undefined, 3]
```

- ② 仅考虑 0 或正整数 的索引

```js
// 代码示例
let al2 = {
  length: 4,
  '-1': -1,
  '0': 0,
  a: 'a',
  1: 1,
};
console.log(Array.from(al2)); // [0, 1, undefined, undefined]
```

- ③ 使用 slice 转换产生稀疏数组

```js
// 代码示例
let al2 = {
  length: 4,
  '-1': -1,
  '0': 0,
  a: 'a',
  1: 1,
};
console.log(Array.prototype.slice.call(al2)); //[0, 1, empty × 2]
```

4）使用数组方法操作类数组注意地方

```js
let arrayLike2 = {
  2: 3,
  3: 4,
  length: 2,
  push: Array.prototype.push,
};

// push 操作的是索引值为 length 的位置
arrayLike2.push(1);
console.log(arrayLike2); // {2: 1, 3: 4, length: 3, push: ƒ}
arrayLike2.push(2);
console.log(arrayLike2); // {2: 1, 3: 2, length: 4, push: ƒ}
```

## 19.webpack 做过哪些优化，开发效率方面、打包策略方面等等

公司：滴滴、快手、掌门一对一、高思教育

分类：工程化

答案&解析

**1）优化 Webpack 的构建速度**

- 使用高版本的 Webpack （使用 webpack4）
- 多线程/多实例构建：HappyPack(不维护了)、thread-loader
- 缩小打包作用域：
  - exclude/include (确定 loader 规则范围)
  - resolve.modules 指明第三方模块的绝对路径 (减少不必要的查找)
  - resolve.extensions 尽可能减少后缀尝试的可能性
  - noParse 对完全不需要解析的库进行忽略 (不去解析但仍会打包到 bundle 中，注意被忽略掉的文件里不应该包含 import、require、define 等模块化语句)
  - IgnorePlugin (完全排除模块)
  - 合理使用 alias
- 充分利用缓存提升二次构建速度：
  - babel-loader 开启缓存
  - terser-webpack-plugin 开启缓存
  - 使用 cache-loader 或者 hard-source-webpack-plugin
    注意：thread-loader 和 cache-loader 兩個要一起使用的話，請先放 cache-loader 接著是 thread-loader 最後才是 heavy-loader
- DLL：
  - 使用 DllPlugin 进行分包，使用 DllReferencePlugin(索引链接) 对 manifest.json 引用，让一些基本不会改动的代码先打包成静态资源，避免反复编译浪费时间。

2）使用 webpack4-优化原因

- (a)V8 带来的优化（for of 替代 forEach、Map 和 Set 替代 Object、includes 替代 indexOf）
- (b)默认使用更快的 md4 hash 算法
- (c)webpacks AST 可以直接从 loader 传递给 AST，减少解析时间
- (d)使用字符串方法替代正则表达式

①noParse

- 不去解析某个库内部的依赖关系
- 比如 jquery 这个库是独立的， 则不去解析这个库内部依赖的其他的东西
- 在独立库的时候可以使用

```js
module.exports = {
  module: {
    noParse: /jquery/,
    rules: [],
  },
};
```

②IgnorePlugin

- 忽略掉某些内容 不去解析依赖库内部引用的某些内容
- 从 moment 中引用 ./locol 则忽略掉
- 如果要用 local 的话 则必须在项目中必须手动引入 import 'moment/locale/zh-cn'
  module.exports = {
  plugins: [
  new Webpack.IgnorePlugin(/\.\/local/, /moment/),
  ]
  }

③dillPlugin

- 不会多次打包， 优化打包时间
- 先把依赖的不变的库打包
- 生成 manifest.json 文件
- 然后在 webpack.config 中引入
- webpack.DllPlugin Webpack.DllReferencePlugin

④happypack -> thread-loader

- 大项目的时候开启多线程打包
- 影响前端发布速度的有两个方面，一个是构建，一个就是压缩，把这两个东西优化起来，可以减少很多发布的时间。

⑤thread-loader
thread-loader 会将您的 loader 放置在一个 worker 池里面运行，以达到多线程构建。
把这个 loader 放置在其他 loader 之前（如下图 example 的位置）， 放置在这个 loader 之后的 loader 就会在一个单独的 worker 池(worker pool)中运行。

```js
// webpack.config.js
module.exports = {
  module: {
    rules: [
      {
        test: /\.js$/,
        include: path.resolve('src'),
        use: [
          'thread-loader',
          // 你的高开销的loader放置在此 (e.g babel-loader)
        ],
      },
    ],
  },
};
```

每个 worker 都是一个单独的有 600ms 限制的 node.js 进程。同时跨进程的数据交换也会被限制。请在高开销的 loader 中使用，否则效果不佳

⑥ 压缩加速——开启多线程压缩

- 不推荐使用 webpack-paralle-uglify-plugin，项目基本处于没人维护的阶段，issue 没人处理，pr 没人合并。
  Webpack 4.0 以前：uglifyjs-webpack-plugin，parallel 参数

```js
module.exports = {
  optimization: {
    minimizer: [
      new UglifyJsPlugin({
        parallel: true,
      }),
    ],
  },
};
```

- 推荐使用 terser-webpack-plugin

```js
module.exports = {
  optimization: {
    minimizer: [
      new TerserPlugin(
        (parallel: true) // 多线程
      ),
    ],
  },
};
```

**2）优化 Webpack 的打包体积**

- 压缩代码
  - webpack-paralle-uglify-plugin
  - uglifyjs-webpack-plugin 开启 parallel 参数 (不支持 ES6)
  - terser-webpack-plugin 开启 parallel 参数
  - 多进程并行压缩
  - 通过 mini-css-extract-plugin 提取 Chunk 中的 CSS 代码到单独文件，通过 optimize-css-assets-webpack-plugin 插件 开启 cssnano 压缩 CSS。
- 提取页面公共资源：
  - 使用 html-webpack-externals-plugin，将基础包通过 CDN 引入，不打入 bundle 中
  - 使用 SplitChunksPlugin 进行(公共脚本、基础包、页面公共文件)分离(Webpack4 内置) ，替代了 CommonsChunkPlugin 插件
  - 基础包分离：将一些基础库放到 cdn，比如 vue，webpack 配置 external 是的 vue 不打入 bundle
- Tree shaking
  - purgecss-webpack-plugin 和 mini-css-extract-plugin 配合使用(建议)
  - 打包过程中检测工程中没有引用过的模块并进行标记，在资源压缩时将它们从最终的 bundle 中去掉(只能对 ES6 Modlue 生效) 开发中尽可能使用 ES6 Module 的模块，提高 tree shaking 效率
  - 禁用 babel-loader 的模块依赖解析，否则 Webpack 接收到的就都是转换过的 CommonJS 形式的模块，无法进行 tree-shaking
  - 使用 PurifyCSS(不在维护) 或者 uncss 去除无用 CSS 代码
- Scope hoisting
  - 构建后的代码会存在大量闭包，造成体积增大，运行代码时创建的函数作用域变多，内存开销变大。Scope hoisting 将所有模块的代码按照引用顺序放在一个函数作用域里，然后适当的重命名一些变量以防止变量名冲突
  - 必须是 ES6 的语法，因为有很多第三方库仍采用 CommonJS 语法，为了充分发挥 Scope hoisting 的作用，需要配置 mainFields 对第三方模块优先采用 jsnext:main 中指向的 ES6 模块化语法
- 图片压缩
  - 使用基于 Node 库的 imagemin (很多定制选项、可以处理多种图片格式)
  - 配置 image-webpack-loader
- 动态 Polyfill
  - 建议采用 polyfill-service 只给用户返回需要的 polyfill，社区维护。(部分国内奇葩浏览器 UA 可能无法识别，但可以降级返回所需全部 polyfill)
  - @babel-preset-env 中通过 useBuiltIns: 'usage 参数来动态加载 polyfill。

**3）speed-measure-webpack-plugin**  
简称 SMP，分析出 Webpack 打包过程中 Loader 和 Plugin 的耗时，有助于找到构建过程中的性能瓶颈。

<hr />

**开发阶段**

1）开启多核压缩

插件：** terser-webpack-plugin **

```js
const TerserPlugin = require('terser-webpack-plugin');
module.exports = {
  optimization: {
    minimizer: [
      new TerserPlugin({
        parallel: true,
        terserOptions: {
          ecma: 6,
        },
      }),
    ],
  },
};
```

2）监控面板

插件：**speed-measure-webpack-plugin**
在打包的时候显示出每一个 loader,plugin 所用的时间，来精准优化

```js
// webpack.config.js文件
const SpeedMeasurePlugin = require('speed-measure-webpack-plugin');
const smp = new SpeedMeasurePlugin();
//............
// 用smp.warp()包裹一下合并的config
module.exports = smp.wrap(merge(_mergeConfig, webpackConfig));
```

3）开启一个通知面板

插件：**webpack-build-notifier**

```js
// webpack.config.js文件
const WebpackBuildNotifierPlugin = require('webpack-build-notifier');
const webpackConfig = {
  plugins: [
    new WebpackBuildNotifierPlugin({
      title: '我的webpack',
      // logo: path.resolve('./img/favicon.png'),
      suppressSuccess: true,
    }),
  ],
};
```

4）开启打包进度

插件：**progress-bar-webpack-plugin**

```js
// webpack.config.js文件
const ProgressBarPlugin = require('progress-bar-webpack-plugin');
const webpackConfig = {
  plugins: [new ProgressBarPlugin()],
};
```

5）开发面板更清晰

插件：**webpack-dashboard**

```js
// webpack.config.js文件
const DashboardPlugin = require('webpack-dashboard/plugin');
const webpackConfig = {
  plugins: [new DashboardPlugin()],
};
```

```js
// package.json文件
{
  "scripts": {
    "dev": "webpack-dashboard webpack --mode development",
  },
}
```

6）开启窗口的标题

**node-bash-title**
这个包 mac 的 item 用有效果，windows 暂时没看到效果

```js
// webpack.config.js文件
const setTitle = require('node-bash-title');
setTitle('server');
```

7）friendly-errors-webpack-plugin

插件：**friendly-errors-webpack-plugin**

```js
new FriendlyErrorsWebpackPlugin({
    compilationSuccessInfo: {
        messages: ['You application is running here http://localhost:3000'],
        notes: ['Some additionnal notes to be displayed unpon successful compilation']
    },
    onErrors: function (severity, errors) {
        // You can listen to errors transformed and prioritized by the plugin
        // severity can be 'error' or 'warning'
    },
    // should the console be cleared between each compilation?
    // default is true
    clearConsole: true,

    // add formatters and transformers (see below)
    additionalFormatters: [],
    additionalTransformers: []
}),
```

## 20.说一下事件循环机制(node、浏览器)

公司：滴滴、伴鱼、高德、自如、虎扑、58

分类：Node、JavaScript

答案&解析

#### 1）为什么会有 Event Loop

​ JavaScript 的任务分为两种`同步`和`异步`，它们的处理方式也各自不同，**同步任务**是直接放在主线程上排队依次执行，**异步任务**会放在任务队列中，若有多个异步任务则需要在任务队列中排队等待，任务队列类似于缓冲区，任务下一步会被移到**调用栈**然后主线程执行调用栈的任务。

> **调用栈**：调用栈是一个栈结构，函数调用会形成一个栈帧，帧中包含了当前执行函数的参数和局部变量等上下文信息，函数执行完后，它的执行上下文会从栈中弹出。

​ JavaScript 是`单线程`的，单线程是指 js 引擎中解析和执行 js 代码的线程只有一个（主线程），每次只能做一件事情，然而`ajax`请求中，主线程在等待响应的过程中回去做其他事情，浏览器先在事件表注册 ajax 的回调函数，响应回来后回调函数被添加到任务队列中等待执行，不会造成线程阻塞，所以说 js 处理 ajax 请求的方式是异步的。

​ 综上所述，检查调用栈是否为空以及讲某个任务添加到调用栈中的个过程就是 event loop，这就是 JavaScript 实现异步的核心。

#### 2）浏览器中的 Event Loop

##### Micro-Task 与 Macro-Task

浏览器端事件循环中的异步队列有两种：macro（宏任务）队列和 micro（微任务）队列。

常见的 macro-task：`setTimeout`、`setInterval`、`script（整体代码）`、`I/O 操作`、`UI 渲染`等。

常见的 micro-task: `new Promise().then(回调)`、`MutationObserve`等。

##### requestAnimationFrame

requestAnimationFrame 也属于异步执行的方法，但该方法既不属于宏任务，也不属于微任务。按照 MDN 中的定义：

> `window.requestAnimationFrame()` 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行

requestAnimationFrame 是 GUI 渲染之前执行，但在`Micro-Task`之后，不过 requestAnimationFrame 不一定会在当前帧必须执行，由浏览器根据当前的策略自行决定在哪一帧执行。

##### event loop 过程

![](https://raw.githubusercontent.com/XQY279/blog/master/image/event-loop.jpg)

1. 检查 macrotask 队列是否为空，非空则到 2，为空则到 3
2. 执行 macrotask 中的一个任务
3. 继续检查 microtask 队列是否为空，若有则到 4，否则到 5
4. 取出 microtask 中的任务执行，执行完成返回到步骤 3
5. 执行视图更新

> 当某个宏任务执行完后,会查看是否有微任务队列。如果有，先执行微任务队列中的所有任务，如果没有，会读取宏任务队列中排在最前的任务，执行宏任务的过程中，遇到微任务，依次加入微任务队列。栈空后，再次读取微任务队列里的任务，依次类推。

#### 3）node 中的 Event Loop

Node 中的 Event Loop 和浏览器中的是完全不相同的东西。Node.js 采用 V8 作为 js 的解析引擎，而 I/O 处理方面使用了自己设计的 libuv，libuv 是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的 API，事件循环机制也是它里面的实现

![](https://raw.githubusercontent.com/XQY279/blog/master/image/bg2014100803.png)

根据上图 node 的运行机制如下

1. V8 引擎解析 JavaScript 脚本。
2. 解析后的代码，调用 Node API。
3. libuv 库负责 Node API 的执行。它将不同的任务分配给不同的线程，形成一个 Event Loop（事件循环），以异步的方式将任务的执行结果返回给 V8 引擎。
4. V8 引擎再将结果返回给用户。

##### 六大阶段

其中 libuv 引擎中的事件循环分为 6 个阶段，它们会按照顺序反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。

![](https://raw.githubusercontent.com/XQY279/blog/master/image/libuv.png)

1. `timers` 阶段：这个阶段执行 timer（setTimeout、setInterval）的回调，并且是由 poll 阶段控制的。
2. `I/O callbacks` 阶段：处理一些上一轮循环中的少数未执行的 I/O 回调
3. `idle, prepare` 阶段：仅 node 内部使用
4. `poll` 阶段：获取新的 I/O 事件, 适当的条件下 node 将阻塞在这里
5. `check` 阶段：执行 setImmediate() 的回调
6. `close callbacks` 阶段：执行 socket 的 close 事件回调

##### poll 阶段

poll 是一个至关重要的阶段，这一阶段中，系统会做两件事情

1.回到 timer 阶段执行回调

2.执行 I/O 回调

并且在进入该阶段时如果没有设定了 timer 的话，会发生以下两件事情

- 如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制
- 如果 poll 队列为空时，会有两件事发生
  - 如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调
  - 如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去

当然设定了 timer 的话且 poll 队列为空，则会判断是否有 timer 超时，如果有的话会回到 timer 阶段执行回调。

##### Micro-Task 与 Macro-Task

Node 端事件循环中的异步队列也是这两种：macro（宏任务）队列和 micro（微任务）队列。

- 常见的 macro-task 比如：`setTimeout`、`setInterval`、 `setImmediate`、`script（整体代码`）、`I/O 操作等`。
- 常见的 micro-task 比如: `process.nextTick`、`new Promise().then(回调)`等。

##### setTimeout 和 setImmediate

二者非常相似，区别主要在于调用时机不同。

- setImmediate 设计在 poll 阶段完成时执行，即 check 阶段；
- setTimeout 设计在 poll 阶段为空闲时，且设定时间到达后执行，但它在 timer 阶段执行

```javascript
setTimeout(function timeout() {
  console.log('timeout');
}, 0);
setImmediate(function immediate() {
  console.log('immediate');
});
```

1. 对于以上代码来说，setTimeout 可能执行在前，也可能执行在后。
2. 首先 setTimeout(fn, 0) === setTimeout(fn, 1)，这是由源码决定的 进入事件循环也是需要成本的，如果在准备时候花费了大于 1ms 的时间，那么在 timer 阶段就会直接执行 setTimeout 回调
3. 如果准备时间花费小于 1ms，那么就是 setImmediate 回调先执行了

##### process.nextTick

这个函数其实是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行

#### 4）Node 与浏览器的 Event Loop 差异

![](https://raw.githubusercontent.com/XQY279/blog/master/image/diff.png)

- Node 端，microtask 在事件循环的各个阶段之间执行
- 浏览器端，microtask 在事件循环的 macrotask 执行完之后执行

## 21.如何封装 node 中间件

公司：滴滴、酷狗

分类：Node

答案&解析

在 NodeJS 中，中间件主要是指封装所有 Http 请求细节处理的方法。一次 Http 请求通常包含很多工作，如记录日志、ip 过滤、查询字符串、请求体解析、Cookie 处理、权限验证、参数验证、异常处理等，但对于 Web 应用而言，并不希望接触到这么多细节性的处理，因此引入中间件来简化和隔离这些基础设施与业务逻辑之间的细节，让开发者能够关注在业务的开发上，以达到提升开发效率的目的。

中间件的行为比较类似 Java 中过滤器的工作原理，就是在进入具体的业务处理之前，先让过滤器处理。

```js
const http = require('http');
function compose(middlewareList) {
  return function (ctx) {
    function dispatch(i) {
      const fn = middlewareList[i];
      try {
        return Promise.resolve(fn(ctx, dispatch.bind(null, i + 1)));
      } catch (err) {
        Promise.reject(err);
      }
    }
    return dispatch(0);
  };
}
class App {
  constructor() {
    this.middlewares = [];
  }
  use(fn) {
    this.middlewares.push(fn);
    return this;
  }
  handleRequest(ctx, middleware) {
    return middleware(ctx);
  }
  createContext(req, res) {
    const ctx = {
      req,
      res,
    };
    return ctx;
  }
  callback() {
    const fn = compose(this.middlewares);
    return (req, res) => {
      const ctx = this.createContext(req, res);
      return this.handleRequest(ctx, fn);
    };
  }
  listen(...args) {
    const server = http.createServer(this.callback());
    return server.listen(...args);
  }
}
module.exports = App;
```

## 22.node 中间层怎样做的请求合并转发

公司：易车

分类：Node

答案&解析

1） 什么是中间层

- 就是前端---请求---> nodejs ----请求---->后端 ----响应--->nodejs--数据处理---响应---->前端。这么一个流程，这个流程的好处就是当业务逻辑过多，或者业务需求在不断变更的时候，前端不需要过多当去改变业务逻辑，与后端低耦合。前端即显示，渲染。后端获取和存储数据。中间层处理数据结构，返回给前端可用可渲染的数据结构。

- nodejs 是起中间层的作用，即根据客户端不同请求来做相应的处理或渲染页面，处理时可以是把获取的数据做简单的处理交由底层 java 那边做真正的数据持久化或数据更新，也可以是从底层获取数据做简单的处理返回给客户端。
- 通常我们把 Web 领域分为客户端和服务端，也就是前端和后端，这里的后端就包含了网关，静态资源，接口，缓存，数据库等。而中间层呢，就是在后端这里再抽离一层出来，在业务上处理和客户端衔接更紧密的部分，比如页面渲染（SSR），数据聚合，接口转发等等。
- 以 SSR 来说，在服务端将页面渲染好，可以加快用户的首屏加载速度，避免请求时白屏，还有利于网站做 SEO，他的好处是比较好理解的。

2）中间层可以做的事情

- 代理：在开发环境下，我们可以利用代理来，解决最常见的跨域问题；在线上环境下，我们可以利用代理，转发请求到多个服务端。
- 缓存：缓存其实是更靠近前端的需求，用户的动作触发数据的更新，node 中间层可以直接处理一部分缓存需求。
- 限流：node 中间层，可以针对接口或者路由做响应的限流。
- 日志：相比其他服务端语言，node 中间层的日志记录，能更方便快捷的定位问题（是在浏览器端还是服务端）。
- 监控：擅长高并发的请求处理，做监控也是合适的选项。
- 鉴权：有一个中间层去鉴权，也是一种单一职责的实现。
- 路由：前端更需要掌握页面路由的权限和逻辑。
- 服务端渲染：node 中间层的解决方案更灵活，比如 SSR、模板直出、利用一些 JS 库做预渲染等等。

3）node 转发 API（node 中间层）的优势

- 可以在中间层把 java|php 的数据，处理成对前端更友好的格式
- 可以解决前端的跨域问题，因为服务器端的请求是不涉及跨域的，跨域是浏览器的同源策略导致的
- 可以将多个请求在通过中间层合并，减少前端的请求

4）如何做请求合并转发

- 使用 express 中间件 multifetch 可以将请求批量合并
- 使用 express+http-proxy-middleware 实现接口代理转发

5）不使用用第三方模块手动实现一个 nodejs 代理服务器，实现请求合并转发

1.实现思路

- ① 搭建 http 服务器，使用 Node 的 http 模块的 createServer 方法
- ② 接收客户端发送的请求，就是请求报文，请求报文中包括请求行、请求头、请求体
- ③ 将请求报文发送到目标服务器，使用 http 模块的 request 方法

  2.实现步骤

- 第一步：http 服务器搭建

```js
const http = require('http');
const server = http.createServer();
server.on('request', (req, res) => {
  res.end('hello world');
});
server.listen(3000, () => {
  console.log('running');
});
```

- 第二步：接收客户端发送到代理服务器的请求报文

```js
const http = require('http');
const server = http.createServer();
server.on('request', (req, res) => {
  // 通过req的data事件和end事件接收客户端发送的数据
  // 并用Buffer.concat处理一下
  //
  let postbody = [];
  req.on('data', chunk => {
    postbody.push(chunk);
  });
  req.on('end', () => {
    let postbodyBuffer = Buffer.concat(postbody);
    res.end(postbodyBuffer);
  });
});
server.listen(3000, () => {
  console.log('running');
});
```

这一步主要数据在客户端到服务器端进行传输时在 nodejs 中需要用到 buffer 来处理一下。处理过程就是将所有接收的数据片段 chunk 塞到一个数组中，然后将其合并到一起还原出源数据。合并方法需要用到 Buffer.concat，这里不能使用加号，加号会隐式的将 buffer 转化为字符串，这种转化不安全。

- 第三步：使用 http 模块的 request 方法，将请求报文发送到目标服务器
  - 第二步已经得到了客户端上传的数据，但是缺少请求头，所以在这一步根据客户端发送的请求需要构造请求头，然后发送

```js
const http = require('http');
const server = http.createServer();

server.on('request', (req, res) => {
  var { connection, host, ...originHeaders } = req.headers;
  var options = {
    method: req.method,
    // 随表找了一个网站做测试，被代理网站修改这里
    hostname: 'www.nanjingmb.com',
    port: '80',
    path: req.url,
    headers: { originHeaders },
  };
  //接收客户端发送的数据
  var p = new Promise((resolve, reject) => {
    let postbody = [];
    req.on('data', chunk => {
      postbody.push(chunk);
    });
    req.on('end', () => {
      let postbodyBuffer = Buffer.concat(postbody);
      resolve(postbodyBuffer);
    });
  });
  //将数据转发，并接收目标服务器返回的数据，然后转发给客户端
  p.then(postbodyBuffer => {
    let responsebody = [];
    var request = http.request(options, response => {
      response.on('data', chunk => {
        responsebody.push(chunk);
      });
      response.on('end', () => {
        responsebodyBuffer = Buffer.concat(responsebody);
        res.end(responsebodyBuffer);
      });
    });
    // 使用request的write方法传递请求体
    request.write(postbodyBuffer);
    // 使用end方法将请求发出去
    request.end();
  });
});
server.listen(3000, () => {
  console.log('runnng');
});
```

## 23.介绍下 promise 的特性、优缺点，内部是如何实现的，动手实现 Promise

公司：滴滴、头条、喜马拉雅、兑吧、寺库、百分点、58、安居客

分类：JavaScript、编程题

答案&解析

// 依照 PromiseA+规范 的 Promise

```javascript
const PENDING = 'pending';
const FULFILLED = 'fulfilled';
const REJECTED = 'rejected';

const resolvePromise = (promise, x, resolve, reject) => {
  if (x === promise) {
    // If promise and x refer to the same object, reject promise with a TypeError as the reason.
    reject(new TypeError('循环引用'));
  }
  // if x is an object or function,
  if ((x !== null && typeof x === 'object') || typeof x === 'function') {
    // If both resolvePromise and rejectPromise are called, or multiple calls to the same argument are made, the first call takes precedence, and any further calls are ignored.
    let called;
    try {
      // If retrieving the property x.then results in a thrown exception e, reject promise with e as the reason.
      let then = x.then; // Let then be x.then
      // If then is a function, call it with x as this
      if (typeof then === 'function') {
        // If/when resolvePromise is called with a value y, run [[Resolve]](promise, y)
        // If/when rejectPromise is called with a reason r, reject promise with r.
        then.call(
          x,
          y => {
            if (called) return;
            called = true;
            resolvePromise(promise, y, resolve, reject);
          },
          r => {
            if (called) return;
            called = true;
            reject(r);
          }
        );
      } else {
        // If then is not a function, fulfill promise with x.
        resolve(x);
      }
    } catch (e) {
      if (called) return;
      called = true;
      reject(e);
    }
  } else {
    // If x is not an object or function, fulfill promise with x
    resolve(x);
  }
};

class Promise {
  constructor(executor) {
    this.status = PENDING;
    this.value = undefined;
    this.reason = undefined;
    // 存放成功/失败的队列
    this.onFulfilledCallbacks = [];
    this.onRejectedCallbacks = [];

    const resolve = value => {
      // 如果value是一个Promise 递归解析
      if (value instanceof Promise) {
        return value.then(resolve, reject);
      }
      if (this.status === PENDING) {
        this.status = FULFILLED;
        this.value = value;
        this.onFulfilledCallbacks.forEach(fn => fn());
      }
    };
    const reject = reason => {
      if (this.status === PENDING) {
        this.status = REJECTED;
        this.reason = reason;
        this.onRejectedCallbacks.forEach(fn => fn());
      }
    };
    try {
      executor(resolve, reject); // 立即执行
    } catch (error) {
      reject(error);
    }
  }
  then(onFulfilled, onRejected) {
    // 判断 onFulfilled, onRejected 是否是函数
    onFulfilled =
      typeof onFulfilled === 'function' ? onFulfilled : value => value;
    onRejected =
      typeof onRejected === 'function'
        ? onRejected
        : reason => {
            throw reason;
          };
    let newPromise = new Promise((resolve, reject) => {
      if (this.status === FULFILLED) {
        setTimeout(() => {
          try {
            let x = onFulfilled(this.value);
            resolvePromise(newPromise, x, resolve, reject);
          } catch (error) {
            reject(error);
          }
        });
      }
      if (this.status === REJECTED) {
        setTimeout(() => {
          try {
            let x = onRejected(this.reason);
            resolvePromise(newPromise, x, resolve, reject);
          } catch (error) {
            reject(error);
          }
        });
      }
      if (this.status === PENDING) {
        this.onFulfilledCallbacks.push(() => {
          setTimeout(() => {
            try {
              let x = onFulfilled(this.value);
              resolvePromise(newPromise, x, resolve, reject);
            } catch (error) {
              reject(error);
            }
          });
        });
        this.onRejectedCallbacks.push(() => {
          setTimeout(() => {
            try {
              let x = onRejected(this.reason);
              resolvePromise(newPromise, x, resolve, reject);
            } catch (error) {
              reject(error);
            }
          });
        });
      }
    });
    return newPromise;
  }
  /**
   * Promise.catch
   * @description  用于promise方法链示，捕获前面 onFulfilled/onRejected 抛出的异常
   * @param {*} errorCallback
   */
  catch(errorCallback) {
    return this.then(null, errorCallback);
  }
  /**
   * Promise.finally
   * @description finally 传入的函数 无论成功和失败都执行
   * @param {*} callback 回调函数
   * @returns 返回成功/失败
   */
  finally(callback) {
    return this.then(
      value => {
        // 返回上一次的值
        return new Promise(callback()).then(() => value);
      },
      error => {
        return new Promise(callback()).then(() => {
          throw error;
        });
      }
    );
  }
  /**
   * Promise.all
   * @description 当这个数组里的所有promise对象全部变为resolve状态的时候，才会resolve 当有一个promise对象变为reject状态时 直接 reject
   * @param {*} values promise对象组成的数组作为参数
   * @returns 返回一个promise实例
   */
  static all(values) {
    return new Promise((resolve, reject) => {
      let resultArr = [];
      let count = 0;
      const resultArrByKey = (index, value) => {
        resultArr[index] = value;
        if (++count === values.length) {
          resolve(resultArr);
        }
      };
      values.forEach((promise, index) => {
        promise.then(value => {
          resultArrByKey(index, value);
        }, reject);
      });
    });
  }
  /**
   * Promise.race
   * @description 只要有一个promise对象进入FULFILLED 或者  REJECTED 状态的话，就会继续执行后面的处理
   * @param {*} values  接受promise对象组成的数组作为参数
   * @returns 返回一个Promise实例
   */
  static race(values) {
    return new Promise((resolve, reject) => {
      values.forEach(promise => {
        promise.then(resolve, reject);
      });
    });
  }
  // 默认产生一个成功的promise
  static resolve(value) {
    return new Promise((resolve, reject) => {
      resolve(value);
    });
  }
  // 默认产生一个失败的promise
  static reject(reason) {
    return new Promise((resolve, reject) => {
      reject(reason);
    });
  }
}

Promise.deferred = () => {
  let defer = {};
  defer.promise = new Promise((resolve, reject) => {
    defer.resolve = resolve;
    defer.reject = reject;
  });
  return defer;
};

module.exports = Promise;
```

## 24.实现 Promise.all

Promise.all = function (arr) {
// 实现代码
};
公司：滴滴、头条、有赞、微医

分类：JavaScript、编程题

答案&解析

**1) 核心思路**

- ① 接收一个 Promise 实例的数组或具有 Iterator 接口的对象作为参数
- ② 这个方法返回一个新的 promise 对象，
- ③ 遍历传入的参数，用 Promise.resolve()将参数"包一层"，使其变成一个 promise 对象
- ④ 参数所有回调成功才是成功，返回值数组与参数顺序一致
- ⑤ 参数数组其中一个失败，则触发失败状态，第一个触发失败的 Promise 错误信息作为 Promise.all 的错误信息。

**2）实现代码**
一般来说，Promise.all 用来处理多个并发请求，也是为了页面数据构造的方便，将一个页面所用到的在不同接口的数据一起请求过来，不过，如果其中一个接口失败了，多个请求也就失败了，页面可能啥也出不来，这就看当前页面的耦合程度了～

```js
function promiseAll(promises) {
  return new Promise(function (resolve, reject) {
    if (!Array.isArray(promises)) {
      throw new TypeError(`argument must be a array`);
    }
    var resolvedCounter = 0;
    var promiseNum = promises.length;
    var resolvedResult = [];
    for (let i = 0; i < promiseNum; i++) {
      Promise.resolve(promises[i]).then(
        value => {
          resolvedCounter++;
          resolvedResult[i] = value;
          if (resolvedCounter == promiseNum) {
            return resolve(resolvedResult);
          }
        },
        error => {
          return reject(error);
        }
      );
    }
  });
}

// test
let p1 = new Promise(function (resolve, reject) {
  setTimeout(function () {
    resolve(1);
  }, 1000);
});
let p2 = new Promise(function (resolve, reject) {
  setTimeout(function () {
    resolve(2);
  }, 2000);
});
let p3 = new Promise(function (resolve, reject) {
  setTimeout(function () {
    resolve(3);
  }, 3000);
});
promiseAll([p3, p1, p2]).then(res => {
  console.log(res); // [3, 1, 2]
});
```

## 25.React 组件通信方式

公司：滴滴、掌门一对一、喜马拉雅、蘑菇街

分类：React

答案&解析

react 组件间通信常见的几种情况:

- 1. 父组件向子组件通信
- 2. 子组件向父组件通信
- 3. 跨级组件通信
- 4. 非嵌套关系的组件通信

1）父组件向子组件通信：父组件通过 props 向子组件传递需要的信息。

```js
// 子组件: Child
const Child = props => {
  return <p>{props.name}</p>;
};

// 父组件 Parent
const Parent = () => {
  return <Child name="京程一灯"></Child>;
};
```

2）子组件向父组件通信：: props+回调的方式。

```js
// 子组件: Child
const Child = props => {
  const cb = msg => {
    return () => {
      props.callback(msg);
    };
  };
  return <button onClick={cb('京程一灯欢迎你!')}>京程一灯欢迎你</button>;
};

// 父组件 Parent
class Parent extends Component {
  callback(msg) {
    console.log(msg);
  }
  render() {
    return <Child callback={this.callback.bind(this)}></Child>;
  }
}
```

3）跨级组件通信：即父组件向子组件的子组件通信，向更深层子组件通信。

- 使用 props，利用中间组件层层传递,但是如果父组件结构较深，那么中间每一层组件都要去传递 props，增加了复杂度，并且这些 props 并不是中间组件自己需要的。
- 使用 context，context 相当于一个大容器，我们可以把要通信的内容放在这个容器中，这样不管嵌套多深，都可以随意取用，对于跨越多层的全局数据可以使用 context 实现。

```js
// context方式实现跨级组件通信
// Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据

const BatteryContext = createContext();

//  子组件的子组件
class GrandChild extends Component {
  render() {
    return (
      <BatteryContext.Consumer>
        {color => <h1 style={{ color: color }}>我是红色的:{color}</h1>}
      </BatteryContext.Consumer>
    );
  }
}

//  子组件
const Child = () => {
  return <GrandChild />;
};
// 父组件
class Parent extends Component {
  state = {
    color: 'red',
  };
  render() {
    const { color } = this.state;
    return (
      <BatteryContext.Provider value={color}>
        <Child></Child>
      </BatteryContext.Provider>
    );
  }
}
```

4）非嵌套关系的组件通信：即没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件。

- 1. 可以使用自定义事件通信（发布订阅模式）
- 2. 可以通过 redux 等进行全局状态管理
- 3. 如果是兄弟组件通信，可以找到这两个兄弟节点共同的父节点, 结合父子间通信方式进行通信。

## 26.redux-saga 和 mobx 的比较

公司：掌门一对一

分类：React

答案&解析

1）状态管理

- redux-sage 是 redux 的一个异步处理的中间件。
- mobx 是数据管理库，和 redux 一样。

2）设计思想

- redux-sage 属于 flux 体系， 函数式编程思想。
- mobx 不属于 flux 体系，面向对象编程和响应式编程。

3）主要特点

- redux-sage 因为是中间件，更关注异步处理的，通过 Generator 函数来将异步变为同步，使代码可读性高，结构清晰。action 也不是 action creator 而是 pure action，
- 在 Generator 函数中通过 call 或者 put 方法直接声明式调用，并自带一些方法，如 takeEvery，takeLast，race 等，控制多个异步操作，让多个异步更简单。
- mobx 是更简单更方便更灵活的处理数据。 Store 是包含了 state 和 action。state 包装成一个可被观察的对象， action 可以直接修改 state，之后通过 Computed values 将依赖 state 的计算属性更新 ，之后触发 Reactions 响应依赖 state 的变更，输出相应的副作用 ，但不生成新的 state。

4）数据可变性

- redux-sage 强调 state 不可变，不能直接操作 state，通过 action 和 reducer 在原来的 state 的基础上返回一个新的 state 达到改变 state 的目的。
- mobx 直接在方法中更改 state，同时所有使用的 state 都发生变化，不生成新的 state。

5）写法难易度

- redux-sage 比 redux 在 action 和 reducer 上要简单一些。需要用 dispatch 触发 state 的改变，需要 mapStateToProps 订阅 state。
- mobx 在非严格模式下不用 action 和 reducer，在严格模式下需要在 action 中修改 state，并且自动触发相关依赖的更新。

6）使用场景

- redux-sage 很好的解决了 redux 关于异步处理时的复杂度和代码冗余的问题，数据流向比较好追踪。但是 redux 的学习成本比 较高，代码比较冗余，不是特别需要状态管理，最好用别
  的方式代替。
- mobx 学习成本低，能快速上手，代码比较简洁。但是可能因为代码编写的原因和数据更新时相对黑盒，导致数据流向不利于追踪。

## 27.说一下 react-fiber

公司：头条、滴滴、菜鸟网络、挖财、喜马拉雅

分类：React

答案&解析

1）背景

- react 在进行组件渲染时，从 setState 开始到渲染完成整个过程是同步的（“一气呵成”）。如果需要渲染的组件比较庞大，js 执行会占据主线程时间较长，会导致页面响应度变差，使得 react 在动画、手势等应用中效果比较差。
- 页面卡顿：Stack reconciler 的工作流程很像函数的调用过程。父组件里调子组件，可以类比为函数的递归；对于特别庞大的 vDOM 树来说，reconciliation 过程会很长(x00ms)，超过 16ms,在这期间，主线程是被 js 占用的，因此任何交互、布局、渲染都会停止，给用户的感觉就是页面被卡住了。

2）实现原理

> 旧版 React 通过递归的方式进行渲染，使用的是 JS 引擎自身的函数调用栈，它会一直执行到栈空为止。而 Fiber 实现了自己的组件调用栈，它以链表的形式遍历组件树，可以灵活的暂停、继续和丢弃执行的任务。实现方式是使用了浏览器的 requestIdleCallback 这一 API。
> Fiber 其实指的是一种数据结构，它可以用一个纯 JS 对象来表示：

```js
const fiber = {
  stateNode, // 节点实例
  child, // 子节点
  sibling, // 兄弟节点
  return, // 父节点
};
```

- react 内部运转分三层：
  - Virtual DOM 层，描述页面长什么样。
  - Reconciler 层，负责调用组件生命周期方法，进行 Diff 运算等。
  - Renderer 层，根据不同的平台，渲染出相应的页面，比较常见的是 ReactDOM 和 ReactNative。
- 为了实现不卡顿，就需要有一个调度器 (Scheduler) 来进行任务分配。优先级高的任务（如键盘输入）可以打断优先级低的任务（如 Diff）的执行，从而更快的生效。任务的优先级有六种：
  - synchronous，与之前的 Stack Reconciler 操作一样，同步执行
  - task，在 next tick 之前执行
  - animation，下一帧之前执行
  - high，在不久的将来立即执行
  - low，稍微延迟执行也没关系
  - offscreen，下一次 render 时或 scroll 时才执行
- Fiber Reconciler（react ）执行阶段：
  - 阶段一，生成 Fiber 树，得出需要更新的节点信息。这一步是一个渐进的过程，可以被打断。
  - 阶段二，将需要更新的节点一次过批量更新，这个过程不能被打断。
- Fiber 树：Fiber Reconciler 在阶段一进行 Diff 计算的时候，会基于 Virtual DOM 树生成一棵 Fiber 树，它的本质是链表。
- 从 Stack Reconciler 到 Fiber Reconciler，源码层面其实就是干了一件递归改循环的事情

## 28.手写发布订阅

公司：滴滴、头条

分类：JavaScript

答案&解析

```js
// 发布订阅中心, on-订阅, off取消订阅, emit发布, 内部需要一个单独事件中心caches进行存储;

interface CacheProps {
  [key: string]: Array<((data?: unknown) => void)>;
}

class Observer {

  private caches: CacheProps = {}; // 事件中心

  on (eventName: string, fn: (data?: unknown) => void){ // eventName事件名-独一无二, fn订阅后执行的自定义行为
    this.caches[eventName] = this.caches[eventName] || [];
    this.caches[eventName].push(fn);
  }

  emit (eventName: string, data?: unknown) { // 发布 => 将订阅的事件进行统一执行
    if (this.caches[eventName]) {
      this.caches[eventName].forEach((fn: (data?: unknown) => void) => fn(data));
    }
  }

  off (eventName: string, fn?: (data?: unknown) => void) { // 取消订阅 => 若fn不传, 直接取消该事件所有订阅信息
    if (this.caches[eventName]) {
      const newCaches = fn ? this.caches[eventName].filter(e => e !== fn) : [];
      this.caches[eventName] = newCaches;
    }
  }

}
```

```js
class EventListener {
  listeners = {};
  on(name, fn) {
    (this.listeners[name] || (this.listeners[name] = [])).push(fn);
  }
  once(name, fn) {
    let tem = (...args) => {
      this.removeListener(name, fn);
      fn(...args);
    };
    fn.fn = tem;
    this.on(name, tem);
  }
  removeListener(name, fn) {
    if (this.listeners[name]) {
      this.listeners[name] = this.listeners[name].filter(
        listener => listener != fn && listener != fn.fn
      );
    }
  }
  removeAllListeners(name) {
    if (name && this.listeners[name]) delete this.listeners[name];
    this.listeners = {};
  }
  emit(name, ...args) {
    if (this.listeners[name]) {
      this.listeners[name].forEach(fn => fn.call(this, ...args));
    }
  }
}
```

## 29.手写数组转树

公司：滴滴

分类：JavaScript

答案&解析

例如
`[{id:1, parentId: 0}, {id:2, parentId:1},{id:3, parentId:1}]`
把这个数组从顶级分类递归查找子分类，最终构建一个树状数组。结果输出如下
`[{id:1, parentId: 0,children:[{id:2, parentId:1},{id:3, parentId:1}]}]`
parentId 为 0 的是根节点

代码实现

```js
// 输入
const tempArr = [
  {
    id: 1,
    parentId: 0,
  },
  {
    id: 2,
    parentId: 1,
  },
  {
    id: 3,
    parentId: 1,
  },
  {
    id: 4,
    parentId: 2,
  },
];

function arrayToTree(sourceArr) {
  sourceArr.forEach(item => {
    let parentId = item.parentId;
    if (parentId !== 0) {
      sourceArr.forEach(subitem => {
        if (subitem.id == parentId) {
          if (!subitem.children) {
            subitem.children = [];
          }
          subitem.children.push(item);
        }
      });
    }
  });
  return sourceArr.filter(item => item.parentId === 0);
}
console.log(arrayToTree(tempArr));
```

## 30.手写用 ES6proxy 如何实现 arr[-1] 的访问

公司：滴滴

分类：JavaScript

答案&解析

```js
const negativeArray = els =>
  new Proxy(els, {
    get: (target, propKey, receiver) =>
      Reflect.get(
        target,
        +propKey < 0 ? String(target.length + +propKey) : propKey,
        receiver
      ),
  });
const unicorn = negativeArray(['京', '程', '一', '灯']);
unicorn[-1];
```
