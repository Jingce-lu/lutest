# 面试

[[toc]]

## 1. 如何配置 React-Router?

1. 标签的方式: BrowserRouter/HashRouter Router Switch exact Route path component this.props.children redirect 通过 path 跟 Component 对应的方式
2. 对象配置的方式: {path component indexRoute childRoutes onLeave onEnter }
3. 按需加载的方式配置路由 提升性能 Route 可以定义 getIndexRoute getComponents getChildRoutes 几个异步函数 只有需要的时候才调用

## 2. 路由的动态加载模块?

根据路由组件打包成多个 bundle，只有在点击到对应的 Route 时，这个 bundle 才会被加载

> webpack babel-plugin-systax-dynamic-import react-loadable

```jsx
<Route exact path="/settings"
  component={Loadable({
    loader: () => import(/* webpackChunkName: "Settings" */ ‘./Settings.js‘),
    loading:Loading
  })}
/>
```

## 3. 服务端渲染 SSR ?

主要是利于 SEO 减少首页白屏

理解: 通过后台(新的 `renderToNodeStream` 替代 原始的 `renderToString`)最后返回已经把数据处理好的 html 页面(link => css, div#root, script)

css-modules-require-hook/preset (csshook) 处理 css 引入  
express body-parser cookie-parser 处理 js  
react-router-dom 处理后端路由  
react react-dom 解析 jsx 语法  
redux react-redux react-thunk 处理 全局数据 (createStore applyMiddleware compose)

## 4. 介绍路由的 history?

它属于 Bom 浏览器对象, 常用来原生实现路由跳转但是不刷新页面的功能 记录浏览历史记录 用来实现前进后退的功能,  
中间可以做一些数据处理,与信息提示  
H5 新增了两个 API: `history.pushState` 和 `history.replaceState`  
接收 3 个参数 (状态对象 object, 标题 title, 地址 url)

## 5.介绍 Redux 数据流的流程?

view => action/dispatch => store(reducer) => view

## 6. Redux 如何实现多个组件之间的通信，多个组件使用相同状态如何进行管理 ?

react-redux(Provider 传入到最外层组件 store 在需要用到的地方 用 connect 获取 (mapStateToProps, mapDispatchToProps) 在页面中引用)  
类似发布订阅模式, 一个地方修改了这个值, 其他所有使用了这个相同状态的地方也会更改

多个组件之间如何拆分各自的 state，每块小的组件有自己的状态，它们之间还有一些公共的状态需要维护，如何思考这块?  
一个全局的 reducer , 页面级别的 reducer , 然后 redux 里有个 combineReducers 把所有的 reducer 合在一起,小组件的使用与全局的使用是分开的互不影响

## 7. 使用过 webpack 里面哪些 plugin 和 loader?

plugin:

- DllReferencePlugin => 生成 manifest.json 文件 利于缓存页面数据
- html-webpack-plugin => 把带 hash 的 dll js/css 插入到 html 中
- copy-webpack-plugin => 把 src 目录外的文件(static) 引入到 dist 目录里
- happypack => 因为 js 是单线程的 多进程来分别执行这些线程 完成的时候在 event loop 中返回给 webpack 处理 提高打包效率
- webpack-bundle-analyzer => 用来分析打包的大小 针对性的去处理文件
- DefinePlugin => 注入一些全局的 config 区分开发和生产
- mini-css-extract-plugin => 压缩 css 代码

loader:

- url-loader => 小图片转化成 base64 进行加载
- styly-loader css-loader postcss-loader less-loader => 处理 css
- eslint-loader => 代码检查
- vue-loader react-loader => 处理框架的语法

## 8. webpack 里面的插件是怎么实现的?

插件开发，最重要的两个对象：`compiler`、`compilation`

compiler.plugin(‘\*\*\*’)就相当于给 compiler 设置了事件监听  
所以 compiler.plugin(‘compile’)就代表：当编译器监听到 compile 事件时，我们应该做些什么  
compilation（’编译器’对’编译 ing’这个事件的监听）相当于对编译过程的监听
compiler.plugin(“emit”, function(compilation, callback) {} 最后执行 emit 输出的回调函数 callback

## 9. vue 的双向绑定的原理是什么 ?

vue.js 是采用**数据劫持**结合**发布者-订阅者模式**的方式，通过 **Object.defineProperty()**来劫持各个属性的 `setter`，`getter`，在数据变动时发布消息给订阅者，触发相应的监听回调。

具体步骤：

1. 第一步：需要 `observe` 的数据对象进行递归遍历，包括子属性对象的属性，都加上 `setter` 和 `getter`  
   这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化
2. 第二步：`compile` 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图
3. 第三步：`Watcher` 订阅者是 `Observer` 和 `Compile` 之间通信的桥梁，主要做的事情是:
   1. 在自身实例化时往属性订阅器(`dep`)里面添加自己
   2. 自身必须有一个 `update()`方法
   3. 待属性变动 `dep.notice()`通知时，能调用自身的 `update()` 方法，并触发 `Compile` 中绑定的回调，则功成身退。
4. 第四步：`MVVM` 作为数据绑定的入口，整合 `Observer`、`Compile` 和 `Watcher` 三者，通过 `Observer` 来监听自己的 `model` 数据变化，通过 `Compile` 来解析编译模板指令，最终利用 `Watcher` 搭起 `Observer` 和 `Compile` 之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据 model 变更的双向绑定效果

## 10. 项目中如何应用数据结构?

不是复杂的项目, 数据结构应该尽量简单  
静态数组适合元素不超过 100 的场合  
动态数组适合元素不超过 1000 的场合  
链表适合元素不超过 3000 的场合

## 11. OSI 七层网络模型

（1 物理层 -> 2 数据链路层 -> 3 网络层(ip)-> 4 传输层(tcp) -> 5 应用层(http)）

OSI 七层模型 作用 对应协议 对应设备

- 应用层 它是计算机用户，以及各种应用程序和网络之间的接口 HTTP, FTP, SMTP, POP3 计算机设备
- 表示层 信息的语法语义以及它们的关系，如加密解密、转换翻译、压缩解压缩 IPX, LPP, XDP
- 会话层 建立、维护、管理应用程序之间的会话 SSL, TLS, DAP, LDAP
- 传输层 服务点编址，分段与重组、连接控制、流量控制、差错控制 TCP, UDP 防火墙
- 网络层 为网络设备提供逻辑地址，进行路由选择、分组转发 IP ARP RARP ICMP IGMP 路由器
- 数据链路层 物理寻址，同时将原始比特流转变为逻辑传输路线 PPTP, ARP, RARP 交换机
- 物理层 机械、电子、定时接口通道信道上的原始比特流传输 IEEE 802.2, Ethernet v.2, Internetwork 网卡

## 12. redux 的设计思想 ?

一个全局的状态管理中心, 不用一步一步的 props 传递数据, 使数据的使用更加方便

react-redux 提供的两个 api Provider 标签中 传入全局的 store store 里面有 reducer 里面有对应的 action 的处理方法 用户使用是,通过 connect(mapStateToProps, mapDispatchToProps)(component) 传入到组件中
每一个 action-types 都有对应的修改 store 里的 state 的方法

## 13. 选择排序:

1. 从数组的开头起，将第一个元素和其他所有元素都进行一次比较，选择出最小的元素放在数组的第一个位置
2. 然后再从第二个元素开始，将第二个元素和除第一个之外的所有元素进行一次比较，选择出最小的元素放在数组的第二个位置
3. 对后面的第三，第四……的元素分别重复上面的步骤，直到所有的数据完成排序

## 14. transform 动画和直接使用 left、top 改变位置有什么优缺点?

设置一次的初始末尾位置, 用浏览器的 GPU 去处理动画, 页面更加流畅, 减少页面的重绘和回流 性能更高

## 15. 介绍暂时性死区 ?

let const 变量申明前引用报错 只能申明一次变量 不会变量提升 按申明的位置开始起作用

## 16. 两个对象如何比较是否相等?

```js
function diff(obj1, obj2) {
  let o1 = obj1 instanceof Object;
  let o2 = obj2 instanceof Object;
  /*  判断不是对象  */
  if (!o1 || !o2) {
    return obj1 === obj2;
  }

  //Object.keys() 返回一个由对象的自身可枚举属性(key值)组成的数组,例如：数组返回下表：let arr = ["a", "b", "c"];console.log(Object.keys(arr))->0,1,2;
  if (Object.keys(obj1).length !== Object.keys(obj2).length) {
    return false;
  }

  for (var attr in obj1) {
    var t1 = obj1[attr] instanceof Object;
    var t2 = obj2[attr] instanceof Object;
    if (t1 && t2) {
      return diff(obj1[attr], obj2[attr]);
    } else if (obj1[attr] !== obj2[attr]) {
      return false;
    }
  }
  return true;
}
```

## 17. 对 async、await 的理解，内部原理?

async、await 是一种异步编程的解决方式  
await/async 和 yield 都被编译器在编译时转化为了状态机

## 18. 使用 Async 会注意哪些东西?

await 接收返回来的 Promise , 用在 try{}catch{} 中抓取错误信息

## 19. Async 里面有多个 await 请求，可以怎么优化（请求是否有依赖）?

await promise.all([p1, p2]) 同时发起异步请求

## 20. Promise 和 Async 处理失败的时候有什么区别?

Promise、generator 错误都可以在构造体里面被捕获，而 async/await 返回的是 promise,可以通过 catch 直接捕获错误  
generator 抛出的错误，以及 await 后接的 Promise.reject 都必须被捕获，否则会中断执行

## 21. React 的事件机制（ 绑定到 document ）?

React 组件上声明的事件没有绑定在 React 组件对应的原生 DOM 节点上，而是绑定在 document 节点上，触发的事件是对原生事件的包装

主要包含`事件注册`、`触发`以及`回调函数的存储`

- `ReactEventListener`：负责事件注册和事件分发, React 将 DOM 事件全都注册到 document 节点上，事件分发主要调用 `dispatchEvent` 进行，从事件触发组件开始，向父元素遍历
- `ReactEventEmitter`：负责每个组件上事件的执行
- `EventPluginHub`：负责回调函数的存储

## 22. 前端开发中用到哪些设计模式?

- 单例模式: 购物车, 全局缓存
- 观察者模式: 登录页面登录后，会需要刷新各个模块的信息（头像、nav）这类
- 工厂模式: 学生 课程 分数
- 命令模式: 刷新菜单界面
- 策略模式: 商品打折

1. 单例模式
   定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。

   实现方法：先判断实例存在与否，如果存在则直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。

   适用场景：一个单一对象。比如：弹窗，无论点击多少次，弹窗只应该被创建一次。

2. 发布/订阅模式  
   定义：又叫观察者模式,它定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时,所有依赖于它的对象都将得到通知。

   场景：订阅感兴趣的专栏和公众号。

3. 策略模式  
   定义：将一个个算法（解决方案）封装在一个个策略类中。

   优点：

   1. 策略模式可以避免代码中的多重判断条件。
   2. 策略模式很好的体现了开放-封闭原则，将一个个算法（解决方案）封装在一个个策略类中。便于切换，理解，扩展。
   3. 策略中的各种算法可以重复利用在系统的各个地方，避免复制粘贴。
   4. 策略模式在程序中或多或少的增加了策略类。但比堆砌在业务逻辑中要清晰明了。
   5. 违反最少知识原则，必须要了解各种策略类，才能更好的在业务中应用。

   应用场景：根据不同的员工绩效计算不同的奖金；表单验证中的多种校验规则。

4. 代理模式

   定义：为一个对象提供一个代用品或占位符，以便控制对它的访问。

   应用场景：图片懒加载（先通过一张 loading 图占位，然后通过异步的方式加载图片，等图片加载好了再把完成的图片加载到 img 标签里面。）

5. 中介者模式

   定义：通过一个中介者对象，其他所有相关对象都通过该中介者对象来通信，而不是互相引用，当其中的一个对象发生改变时，只要通知中介者对象就可以。可以解除对象与对象之间的紧耦合关系。

   应用场景： 例如购物车需求，存在商品选择表单、颜色选择表单、购买数量表单等等，都会触发 change 事件，那么可以通过中介者来转发处理这些事件，实现各个事件间的解耦，仅仅维护中介者对象即可。

6. 装饰者模式

   定义：在不改变对象自身的基础上，在程序运行期间给对象动态的添加方法。

   应用场景： 有方法维持不变，在原有方法上再挂载其他方法来满足现有需求；函数的解耦，将函数拆分成多个可复用的函数，再将拆分出来的函数挂载到某个函数上，实现相同的效果但增强了复用性。

## 23. React/Redux 中哪些功能用到了哪些设计模式?

- `代理模式`: 事件的注册, 触发
- @connect: `装饰器模式`
- 一个 store: `单例模式`
- appmidlleware(thunk, logger): `中介者模式`
- state => view : `发布订阅者模式`

## 24. 介绍下数字签名的原理?

- A：将明文进行摘要运算后得到摘要（消息完整性），再将摘要用 A 的私钥加密（身份认证），得到数字签名，将密文和数字签名一块发给 B。
- B：收到 A 的消息后，先将密文用自己的私钥解密，得到明文。将数字签名用 A 的公钥进行解密后，得到正确的摘要（解密成功说明 A 的身份被认证了

## 25. formData 和原生的 ajax 有什么区别?

设置 header 里的 Content-Type 的类型  
Content-type：application/x-www-form-urlencoded

## 26. koa2 中间件

常用的中间件?

1. koa:面向 node.js 的表达式 HTTP 中间件框架，使 Web 应用程序和 API 更加令人愉快地编写
2. koa-router:Router middleware for koa(koa 的路由中间件)
3. -views:Template rendering middleware for koa.(koa 的模板渲染中间件)
4. -bodyparser:用来解析 body 的中间件，比方说你通过 post 来传递表单，json 数据，或者上传文件，在 koa 中是不容易获取的，通过 koa-bodyparser 解析之后，在 koa 中 this.body 就能直接获取到数据。ps：xml 数据没办法通过 koa-bodyparser 解析，有另一个中间件 koa-xml-body
5. promise-mysql:Promise-mysql 是 mysqljs / mysql 的一个包装函数，它包含 Bluebird 承诺的函数调用。通常这会用 Bluebird 的.promisifyAll()方法完成，但是 mysqljs / mysql 的脚本与 Bluebird 所期望的不同

## 27. npm2 和 npm3+有什么区别?

npm3 和 npm2 对于依赖的处理不一样了  
npm2 所有项目依赖是嵌套关系，而 npm3 为了改进嵌套过多、套路过深的情况，会将所有依赖放在第二层依赖中（所有依赖只嵌套一次，彼此平行，也就是平铺的结构

## 28. MVC 和 MVVM 的区别

Model 用于封装和应用程序的业务逻辑相关的数据以及对数据的处理方法；
View 作为视图层，主要负责数据的展示；
Controller 定义用户界面对用户输入的响应方式，它连接模型和视图，用于控制应用程序的流程，处理用户的行为和数据上的改变。

MVC 将响应机制封装在 controller 对象中，当用户和你的应用产生交互时，控制器中的事件触发器就开始工作了。

MVVM 把 View 和 Model 的同步逻辑自动化了。以前 Controller 负责的 View 和 Model 同步不再手动地进行操作，而是交给框架所提供的数据绑定功能进行负责，只需要告诉它 View 显示的数据对应的是 Model 哪一部分即可。也就是双向数据绑定，就是 View 的变化能实时让 Model 发生变化，而 Model 的变化也能实时更新到 View。

## 29. 懒加载怎么实现

场景：一个页面中很多图片，但是首屏只出现几张，这时如果一次性把图片都加载出来会影响性能。这时可以使用懒加载，页面滚动到可视区在加载。优化首屏加载。

实现：img 标签 src 属性为空，给一个 data-xx 属性，里面存放图片真实地址，当页面滚动直至此图片出现在可视区域时，用 js 取到该图片的 data-xx 的值赋给 src。

优点：页面加载速度快，减轻服务器压力、节约流量，用户体验好。

## 30. XSS 和 CSRF 防范措施

1. XSS：跨站脚本攻击
   攻击方式：在 URL 或者页面输入框中插入 JavaScript 代码。

   防范：

   1. 设置 httpOnly，禁止用 document.cookie 操作；
   2. 输入检查：在用户输入的时候进行格式检查；
   3. 对输出转义。

2. CSRF：跨站点伪造请求
   攻击方式：攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并执行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。主要是拿到了用户的登录态。

   防范：

   1. 检查 Referer 字段：这个字段用以标明请求来源于哪个地址。在处理敏感数据请求时，通常来说，Referer 字段应和请求的地址位于同一域名下
   2. 添加校验 Token：这种数据通常是表单中的一个数据项。服务器生成 token 并附加在表单中，其内容是一个伪乱数。当客户端通过表单提交请求时，这个伪乱数也一并提交上去以供校验。正常的访问时，客户端浏览器能够正确得到并传回这个伪乱数，而通过 CSRF 传来的欺骗性攻击中，攻击者无从事先得知这个伪乱数的值，服务器端就会因为校验 Token 的值为空或者错误，拒绝这个可疑请求
   3. 通过输入验证码来校验合法请求

## 31. 进程和线程的区别

- 根本区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位。
- 在开销方面：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。
- 所处环境：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过 CPU 调度，在每个时间片中只有一个线程执行）。
- 内存分配方面：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了 CPU 外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。
- 包含关系：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。

## 32. 为什么 reducer 要是个纯函数，纯函数是什么？

纯函数：对于相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用，也不依赖外部环境的状态。

原因：Redux 只通过比较新旧两个对象的存储位置来比较新旧两个对象是否相同（浅比较）。如果你在 reducer 内部直接修改旧的 state 对象的属性值，那么新的 state 和旧的 state 将都指向同一个对象。因此 Redux 认为没有任何改变，返回的 state 将为旧的 state。两个 state 相同的话，页面就不会重新渲染了。

因为比较两个 Javascript 对象所有的属性是否相同的的唯一方法是对它们进行深比较。但是深比较在真实的应用当中代价昂贵，因为通常 js 的对象都很大，同时需要比较的次数很多。因此一个有效的解决方法是作出一个规定：无论何时发生变化时，开发者都要创建一个新的对象，然后将新对象传递出去。同时，当没有任何变化发生时，开发者发送回旧的对象。也就是说，新的对象代表新的 state。

## 33. let、const、var 的区别；如果 const 定义的是个对象，能够修改对象的属性吗？

const 实际上保证的并不是变量的值不得改动，而是变量指向的那个指针不得改动，可以给对象添加属性。如果真的想将对象冻结，应该使用 Object.freeze 方法。

## 34. Object.freeze 和 Object.seal 的区别

Object.preventExtension：禁止对象添加新属性并保留已有属性;

Object.seal：在一个现有对象上调用 Object.preventExtensions(..) 并把所有现有属性标记为 configurable:false;

Object.freeze：在一个现有对象上调用 Object.seal(..) 并把所有“数据访问”属性标记为 writable:false。

## 35. flex 布局?用处?

弹性伸缩布局 , 用处,常用于 pc 移动基础布局 ,圣杯布局,骰子布局,固定底栏布局,流式布局

基本属性

- flex-direction  (row column)  控制主轴方向
- flex-wrap  换行与否
- flex-flow flex-direction 和 flex-wrap 的合写
- justify-content 定义主轴对齐方式   flex-start  end  space-between(留空) space-around  center
- align-item 定义交叉轴对齐方式   flex-start flex-end baseline stretch center
- align-content 定义多根轴的对齐方式   flex-start  flex-end  space-between(留空) space-around  center stretch

## 36. 移动端和 pc 端怎么切换的?

```js
if (!urlhash.match("fromapp")) {
  //移动端

  if (navigator.userAgent.match(/(iPhone|iPod|Android|ios|iPad)/i)) {
    window.location.href = "/cn/index.htm"; //pc端
  } else {
    window.location.href = "/cn/index.htm";
  }
}
```

利用 navigator.userAgent.match 去匹配

## 37. 小程序和 vue 最大的区别

小程序没有 v-model 双向数据绑定,小程序主要通过 this.setData({key:value})

## 38. overflow:hidden 用处

1. 超出部分隐藏,
2. 清除浮动,
3. 形成 BFC(块级格式上下文)

## 39. ajax 原生写法,有哪四步?

1. 实例化 XMLhttprequset 对象
2. 设置请求行
3. 设置请求头
4. 设置请求主体并发送请求

```js
var  xhr = new  XMLHttpRequest()

xhr.open('get',index.php)

//post请求

xhr.setRequestHeader('content-type','application/x-www-form-urlencoded')

xhr.send('name=zs&age=18)

xhr.onreadystatechange = function(){

  if(xhr.readystate == 4 & xhr.status == 200)

    console.log(xhr.responseText)

}
```

## 40. common.js 规范

1. 一个文件就是一个模块
2. 普通定义的变量和函数,对象都是该变量
3. 通过 require 加载
4. 通过 export 和 module export 导出

## 41. 集中化 vueX 是什么?

是一个公共的数据管理工具,这样实现共享数据,任何组件都可以去调用这些数据,里面有 state(数据管理地方),mutations,getters,

辅助函数(mapstate,mapmutations,mapgetters),实现数据在组件的映射

## 42. 页面白屏原因

- 网络延迟,js 加载延迟,阻塞页面
- 客服端 bug,缓存错乱,不缓存 js,乱缓存 html
- 尽量同步输出,减少文件嵌套,给接口设置 tiemout

## 43. 垂直居中实现?

1. flex 布局,
   ```css
   justify-content : center
   align-item:center
   display:flex
   ```
2. 定位 :
   ```css
   position: absolute;
   top: 50%;
   left: 50%;
   width: 100%;
   transform: translate(-50%, -50%);
   ```
3. 表格布局:
   ```css
   display:table-cell
   vertical:middle
   text-aligin:center
   ```

## 44. vue 路由传参对象形式?

1. 导航路由直接传对象,params 和 query 对象

   ```jsx
   <router-link
     :to="{
       path: 'yourPath',
       params: {
         name: 'name',
         dataObj: data
       },

       query: {
         name: 'name',

         dataObj: data
       }
     }"
   >

   </router-link>
   ```

2. 利用编程式导航
   ```jsx
   this.$router.push({
     path: 'yourPath',
     name: '要跳转的路径的 name,
     params: {
       name: 'name',
       dataObj: this.msg
     }
   )
   ```

## 45. cookie 和 token 都存放在 header 里面，为什么只劫持前者?

- cookie 每次请求都会带上 内容主要包括：名字，值，过期时间，路径和域,cookie 是有状态的 被劫持不安全, 可以设置 httpOnly 防止 cors
- token 可以设置失效时间, 是无状态的 被劫持后危险性要低一些, 在跨端能力上更好

## 46. React 中 Dom 结构发生变化后内部经历了哪些变化?

diff 算法对比虚拟 dom 与现在视图 dom, 计算哪些节点需要重新渲染 算出最小操作集 然后到组件 render

## 47. key 主要是解决哪一类的问题，为什么不建议用索引 index（重绘）?

循环渲染子元素 加个 key 值使 diff 算法更快, 使用 index 的话, 当数组增删的时候, dom 元素对应 index 改变 会出现渲染的问题

## 48. Redux 中间件是怎么拿到 store 和 action，然后怎么处理?

处理异步函数 打印 logger 信息等

```js
const logger = store => next => action => {
  console.log("dispatching", action);
  let result = next(action);
  console.log("next state", store.getState());
  return result;
};

// 当我们调用applyMiddleware方法时
applyMiddleware(store, [logger]);
// 会依次middlewares数组中的方法，并且每次执行都重新封装store.dispatch
middlewares.forEach(middleware => (dispatch = middleware(store)(dispatch)));
// 这里体现了函数柯里化，每次执行一个中间件，middleware(store)(dispatch),
// 第二个括号内的（dispatch），传递给了具体函数的next
```

## 49. koa-bodyparser 怎么来解析 request?

```js
var Koa = require("koa");
var bodyParser = require("koa-bodyparser");
var app = new Koa();
app.use(async ctx => {
  ctx.body = ctx.request.body;
});
```

## 50. jsonp 方案需要服务端怎么配合?

配置返回的数据类型必须是 jsonp 类型的，而不是 json 类型的,解决跨域必须在 ajax 方法中 dataType 设置为 jsonp

客户端 js 代码中 ajax 方法还要设置 jsonpCallback 这个属性

## 51.
