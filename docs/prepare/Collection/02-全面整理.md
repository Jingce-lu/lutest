# 全面整理

[[toc]]

## 1. js 实现 checkbox 全选以及反选

```html
<body>
  <button id="other">反选</button>
  <input type="checkbox" id="all" />全选/全不选
  <input type="checkbox" class="check" />1
  <input type="checkbox" class="check" />2
  <input type="checkbox" class="check" />3
  <script>
    var checkbox = document.getElementsByClassName("check");
    var checkAll = document.getElementById("all");
    var checkOther = document.getElementById("other");
    checkAll.onclick = function() {
      var flag = true;
      for (var i = 0; i < checkbox.length; i++) {
        if (!checkbox[i].checked) flag = false;
      }
      if (flag) {
        // 全部选中时候全不选
        for (var i = 0; i < checkbox.length; i++) {
          checkbox[i].checked = false;
        }
      } else {
        for (var i = 0; i < checkbox.length; i++) {
          checkbox[i].checked = true;
        }
      }
    };
    checkOther.onclick = function() {
      for (var i = 0; i < checkbox.length; i++) {
        checkbox[i].checked = !checkbox[i].checked;
      }
    };
  </script>
</body>
```

## 2. 对原型链的理解？prototype 上都有哪些属性

- 在 js 里，继承机制是原型继承。继承的起点是 对象的原型（Object prototype）。
- 一切皆为对象，只要是对象，就会有 proto 属性，该属性存储了指向其构造的指针。
- Object.prototype 也是对象，其 proto 指向 null。
- 对象分为两种：函数对象和普通对象，只有函数对象拥有『原型』对象（prototype）。
- prototype 的本质是普通对象。
- Function prototype 比较特殊，是没有 prototype 的函数对象。
- new 操作得到的对象是普通对象。
- 当调取一个对象的属性时，会先在本身查找，若无，就根据 proto 找到构造原型，若无，继续往上找。最后会到达顶层 Object prototype，它的 proto 指向 null，均无结果则返回 undefined，结束。
- 由 proto 串起的路径就是『原型链』。
- 通过 prototype 可以给所有子类共享属性

## 3. setTimeout 时间延迟为何不准

单线程, 先执行同步主线程, 再执行异步任务队列

## 4. 事件循环述，宏任务和微任务有什么区别？

- 先主线程后异步任务队列
- 先微任务再宏任务

## 5. 节流和防抖

- **函数节流是指一定时间内 js 方法只跑一次**。比如人的眨眼睛，就是一定时间内眨一次。这是函数节流最形象的解释。

  ```js
  // 函数节流   滚动条滚动
  var canRun = true;
  document.getElementById("throttle").onscroll = function() {
    if (!canRun) {
      // 判断是否已空闲，如果在执行中，则直接return
      return;
    }

    canRun = false;
    setTimeout(function() {
      console.log("函数节流");
      canRun = true;
    }, 300);
  };

  // 节流
  function throttle(fn, delay) {
    // 利用闭包保存时间
    let prev = Date.now();
    return function() {
      let context = this;
      let arg = arguments;
      let now = Date.now();
      if (now - prev >= delay) {
        fn.apply(context, arg);
        prev = Date.now();
      }
    };
  }

  function fn() {
    console.log("节流");
  }
  addEventListener("scroll", throttle(fn, 1000));
  ```

2. **函数防抖是指频繁触发的情况下，只有足够的空闲时间，才执行代码一次**。比如生活中的坐公交，就是一定时间内，如果有人陆续刷卡上车，司机就不会开车。只有别人没刷卡了，司机才开车。

   ```js
   // 函数防抖
   var timer = false;
   document.getElementById("debounce").onscroll = function() {
     clearTimeout(timer); // 清除未执行的代码，重置回初始化状态

     timer = setTimeout(function() {
       console.log("函数防抖");
     }, 300);
   };

   // 防抖
   function debounce(fn, delay) {
     // 利用闭包保存定时器
     let timer = null;
     return function() {
       let context = this;
       let arg = arguments;
       // 在规定时间内再次触发会先清除定时器后再重设定时器
       clearTimeout(timer);
       timer = setTimeout(function() {
         fn.apply(context, arg);
       }, delay);
     };
   }

   function fn() {
     console.log("防抖");
   }
   addEventListener("scroll", debounce(fn, 1000));
   ```

## 6. 实现一个 sleep 函数

```js
// 这种实现方式是利用一个伪死循环阻塞主线程。因为JS是单线程的。所以通过这种方式可以实现真正意义上的sleep()。
function sleep(delay) {
  var start = new Date().getTime();
  while (new Date().getTime() - start < delay) {
    continue;
  }
}

function test() {
  console.log("111");
  sleep(2000);
  console.log("222");
}

test();
```

## 7. localStorage 与 sessionStorage 与 cookie 的区别总结

- 共同点: 都保存在浏览器端, 且同源
- localStorage 与 sessionStorage 统称 webStorage,保存在浏览器,不参与服务器通信,大小为 5M
- 生命周期不同: localStorage 永久保存, sessionStorage 当前会话, 都可手动清除
- 作用域不同: 不同浏览器不共享 local 和 session, 不同会话不共享 session
- Cookie: 设置的过期时间前一直有效, 大小 4K.有个数限制, 各浏览器不同, 一般为 20 个.携带在 HTTP 头中, 过多会有性能问题.可自己封装, 也可用原生

## 8. 什么情况会阻塞渲染？

- js 脚本同步执行
- css 和图片虽然是异步加载, 但 js 文件执行需依赖 css, 所以 css 也会阻塞渲染

## 9. 如何判断 js 运行在浏览器中还是 node 中？

判断有无全局对象 global 和 window

## 10. cookie 可设置哪些属性？httponly?

- name 　　字段为一个 cookie 的名称。
- value 　　字段为一个 cookie 的值。
- domain 　　字段为可以访问此 cookie 的域名。
- path 　　字段为可以访问此 cookie 的页面路径。比如 domain 是 abc.com,path 是/test，那么只有/test 路径下的页面可以读取此 cookie。
- expires/Max-Age 　　字段为此 cookie 超时时间。若设置其值为一个时间，那么当到达此时间后，此 cookie 失效。不设置的话默认值是 Session，意思是 cookie 会和 session 一起失效。当浏览器关闭(不是浏览器标签页，而是整个浏览器) 后，此 cookie 失效。
- Size 　　字段 此 cookie 大小。
- http 　　字段 cookie 的 httponly 属性。若此属性为 true，则只有在 http 请求头中会带有此 cookie 的信息，而不能通过 document.cookie 来访问此 cookie。
- secure 　　 字段 设置是否只能通过 https 来传递此条 cookie

## 11. 登录后，前端做了哪些工作，如何得知已登录

- 前端存放服务端下发的 cookie, 简单说就是写一个字段在 cookie 中表明已登录, 并设置失效日期
- 或使用后端返回的 token, 每次 ajax 请求将 token 携带在请求头中, 这也是防范 csrf 的手段之一

## 12. 登录验证拦截(通过 router)

1. 先设置 requireAuth:
   ```js
   routes = [
     {
       name: "detail",
       path: "/detail",
       meta: {
         requireAuth: true
       }
     },
     {
       name: "login",
       path: "/login"
     }
   ];
   ```
2. 再配置 router.beforeEach:
   ```js
   router.beforeEach((from, to, next) => {
     if (to.meta.requireAuth) {
       // 判断跳转的路由是否需要登录
       if (store.state.token) {
         // vuex.state判断token是否存在
         next(); // 已登录
       } else {
         next({
           path: "/login",
           query: { redirect: to.fullPath } // 将跳转的路由path作为参数，登录成功后跳转到该路由
         });
       }
     } else {
       next();
     }
   });
   ```

## 13. 双向数据绑定 v-model。

```js
// 依赖收集
// 简化版
var obj = {};
var name;
//第一个参数：定义属性的对象。
//第二个参数：要定义或修改的属性的名称。
//第三个参数：将被定义或修改的属性描述符。
Object.defineProperty(obj, "data", {
  //获取值
  get: function() {
    return name;
  },
  //设置值
  set: function(val) {
    name = val;
    console.log(val);
  }
});
//赋值调用set
obj.data = "aaa";
//取值调用get
console.log(obj.data);

// 详细版
myVue.prototype._obverse = function(obj) {
  // obj = {number: 0}
  var value;
  for (key in obj) {
    //遍历obj对象
    if (obj.hasOwnProperty(key)) {
      value = obj[key];
      if (typeof value === "object") {
        //如果值是对象，则递归处理
        this._obverse(value);
      }
      Object.defineProperty(this.$data, key, {
        //关键
        enumerable: true,
        configurable: true,
        get: function() {
          console.log(`获取${value}`);
          return value;
        },
        set: function(newVal) {
          console.log(`更新${newVal}`);
          if (value !== newVal) {
            value = newVal;
          }
        }
      });
    }
  }
};
```

## 14. vue 解除双向绑定

```js
let obj = JSON.parse(JSON.stringify(this.temp1));
```

## 15. vue 异步组件

为了简化，Vue 允许你以一个工厂函数的方式定义你的组件，这个工厂函数会异步解析你的组件定义。Vue 只有在这个组件需要被渲染的时候才会触发该工厂函数，且会把结果缓存起来供未来重渲染

```js
Vue.component(
  "async-webpack-example",
  // 这个 `import` 函数会返回一个 `Promise` 对象。
  () => import("./my-async-component")
);
```

## 15. react 和 vue 的区别

- **数据是否可变**:
  - react 整体是函数式的思想，把组件设计成纯组件，状态和逻辑通过参数传入，所以在 react 中，是单向数据流，推崇结合 immutable 来实现数据不可变;
  - vue 的思想是响应式的，也就是基于是数据可变的，通过对每一个属性建立 Watcher 来监听，当属性变化的时候，响应式的更新对应的虚拟 dom。
  - 总之，react 的性能优化需要手动去做，而 vue 的性能优化是自动的，但是 vue 的响应式机制也有问题，就是当 state 特别多的时候，Watcher 也会很多，会导致卡顿，所以大型应用（状态特别多的）一般用 react，更加可控。
- **通过 js 来操作一切，还是用各自的处理方式**:
  - react 的思路是 all in js，通过 js 来生成 html，所以设计了 jsx，还有通过 js 来操作 css，社区的 styled-component、jss 等;
  - vue 是把 html，css，js 组合到一起，用各自的处理方式，vue 有单文件组件，可以把 html、css、js 写到一个文件中，html 提供了模板引擎来处理。
- **类式的组件写法，还是声明式的写法**:
  - react 是类式的写法，api 很少; 而 vue 是声明式的写法，通过传入各种 options，api 和参数都很多。
  - 所以 react 结合 typescript 更容易一起写，vue 稍微复杂。
- **扩展不同**:
  - react 可以通过高阶组件（Higher Order Components--HOC）来扩展，而 vue 需要通过 mixins 来扩展。
- **什么功能内置，什么交给社区去做**:
  - react 做的事情很少，很多都交给社区去做，vue 很多东西都是内置的，写起来确实方便一些，  
    比如 redux 的 combineReducer 就对应 vuex 的 modules，  
    比如 reselect 就对应 vuex 的 getter 和 vue 组件的 computed，  
    vuex 的 mutation 是直接改变的原始数据，而 redux 的 reducer 是返回一个全新的 state，所以 redux 结合 immutable 来优化性能，vue 不需要。

## 16. JSBridge 通信原理, 有哪几种实现的方式？

JsBridge 给 JavaScript 提供了调用 Native 功能，Native 也能够操控 JavaScript。这样前端部分就可以方便使用地理位置、摄像头以及登录支付等 Native 能力啦。JSBridge 构建 Native 和非 Native 间消息通信的通道，而且是 双向通信的通道。

- JS 向 Native 发送消息 : 调用相关功能、通知 Native 当前 JS 的相关状态等。
- Native 向 JS 发送消息 : 回溯调用结果、消息推送、通知 JS 当前 Native 的状态等。

## 17. C 端 H5 与 app 交互

### 判断 app

- tools.isWebView()方法判断是否在 app 中
- 区分 一 app、二 app，需要读取 cookie 中 BitautoAppInfo 的 SOURCE 值

  | app    | SOURCE 值 |
  | ------ | --------- |
  | 一 app | 108       |
  | 二 app | 5         |

### 分享

1. app 中是否显示分享按钮，

   ```html
   <meta name="BitautoCustom" content="ShowShare=0" />
   <meta name="BitautoCustom" content="ShowShare=1" />
   ```

   ShowShare=0 表示不显示，ShowShare=1 显示；

2. 自定义分享内容

   ```javascript
   function customizewebcofig() {
     var json = {
       hideshare: 0,
       shareContent: "分享内容",
       shareTitle: "分享标题",
       shareurl: "分享链接",
       // 分享图片可不传，app有默认图片
       shareImg: "分享图片"
     };
     // 返回需为字符串json
     return JSON.stringify(json);
   }
   ```

**注意：**

1. 函数只在 H5 中定义，原生 app 监测页面加载完成后调用该函数；
2. 当分享的内容可配置时，异步获取配置内容后会与 app 监测页面加载完成存在时间差，可能造成原生 app 调用函数后获取不到返回值。

**解决办法：** 页面渲染 html 由后台控制时，需要后台同学把该函数以及配置的参数值放到页面里面。

### js 与 native(Android/iOS)交互-JSBridge

**注意**： 需 native 端注册（registerHandler）相应方法，进入监听状态，js 才能调用该方法

1. 调用方式示例：

   ```javascript
   jsBridge("handlerName", data, "post", function(params) {
     // any code
   });
   ```

   | 参数                 | 解释                                                        | 数据类型 |
   | -------------------- | ----------------------------------------------------------- | -------- |
   | handlerName          | 与 native 端约定的调用方法名                                | string   |
   | data                 | 传给 native 的数据参数                                      | any      |
   | post                 | post 表示发起调用；get 表示监听调用；                       | string   |
   | function (params) {} | 调用或监听到交互后会调用该方法，params 为 native 传回的数据 | function |

2. JSBridge 代码：

   ```javascript
   window.jsBridge = function(name, params, type, success) {
     // name：约定监听名字 string;
     // params: 参数 any;
     // type: 'get' iso/android中的事件，type：'post'  h5中的事件;
     // success: 成功回调 function;
     var u = navigator.userAgent;
     var isiOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端
     //注册事件监听
     function connectWebViewJavascriptBridge(callback) {
       if (window.WebViewJavascriptBridge) {
         return callback(WebViewJavascriptBridge);
       } else if (isiOS) {
         if (window.WVJBCallbacks) {
           return window.WVJBCallbacks.push(callback);
         }
         window.WVJBCallbacks = [callback];
         var WVJBIframe = document.createElement("iframe");
         WVJBIframe.style.display = "none";
         WVJBIframe.src = "https://__bridge_loaded__";
         document.documentElement.appendChild(WVJBIframe);
         setTimeout(function() {
           document.documentElement.removeChild(WVJBIframe);
         }, 0);
       } else {
         document.addEventListener(
           "WebViewJavascriptBridgeReady",
           function() {
             callback(WebViewJavascriptBridge);
           },
           false
         );
       }
     }
     if (name) {
       if (type === "post") {
         connectWebViewJavascriptBridge(function(bridge) {
           bridge.callHandler(name, params, function(responseData) {
             success && success(responseData);
           });
         });
       } else if (type === "get") {
         connectWebViewJavascriptBridge(function(bridge) {
           bridge.registerHandler(name, function(data, responseCallback) {
             responseCallback(params);
             success && success(data);
           });
         });
       }
     }
   };
   ```

**拓展**： 可提供给 native 同事参考

1. Android 端

   - 注册监听：

     ```js
     webView.registerHandler("handlerName", new BridgeHandler() {
       @Override
       public void handler(String data, CallBackFunction function) {
         function.onCallBack("responseData");
       }
     });
     ```

     | 参数         | 解释              |
     | ------------ | ----------------- |
     | handlerName  | 约定的方法名称    |
     | data         | web 传入的数据    |
     | responseData | 回传给 web 的数据 |

   - 发起调用：

     ```js
     webView.callHandler("handlerName", data , new CallBackFunction() {
       @Override
       public void onCallBack(String responseData) {
       }
     });
     ```

     | 参数         | 解释                |
     | ------------ | ------------------- |
     | handlerName  | 约定的方法名称      |
     | data         | 传输给 web 的数据   |
     | responseData | 来自 web 的回传数据 |

2. iOS 端

   - 注册监听：

     ```js
     [self.bridge registerHandler:@"handlerName" handler:^(id data, WVJBResponseCallback responseCallback) {
     }];
     ```

     | 参数         | 解释              |
     | ------------ | ----------------- |
     | handlerName  | 约定的方法名称    |
     | data         | web 传入的数据    |
     | responseData | 回传给 web 的数据 |

   - 发起调用：

     ```js
     [self.bridge callHandler:@"handlerName" data:data responseCallback:^(id responseData) {
     }];
     ```

     | 参数         | 解释                |
     | ------------ | ------------------- |
     | handlerName  | 约定的方法名称      |
     | data         | 传输给 web 的数据   |
     | responseData | 来自 web 的回传数据 |

## 18. H5 页面在微信中的分享

### 依赖

```javascript
import wxBridge from "wx-bridge"; // 微信分享
import tools from "utils";

const weixin = {
  config: {
    authorizationUrl: `...`,
    userInfo: localStorage.getItem("WEIXIN_USER_INFO"),
    getSignatureApi: "..."
  },

  isWeixin: function() {
    const ua = window.navigator.userAgent.toLowerCase();
    if (ua.match(/MicroMessenger/i) === "micromessenger") {
      return true;
    } else {
      return false;
    }
  },

  getQueryString: function(name) {
    const reg = new RegExp(`(^|&)${name}=([^&]*)(&|$)`, "i");
    const r = window.location.search.substr(1).match(reg);
    if (r) {
      return decodeURIComponent(r[2]);
    }
  },

  // 微信授权
  getUserInfo: function() {
    if (this.config.userInfo) {
      return this.config.userInfo;
    } else {
      let user = this.getQueryString("v");
      if (user) {
        localStorage.setItem("WEIXIN_USER_INFO", user);
        return user;
      } else {
        window.location.href = this.config.authorizationUrl;
      }
    }
  },

  // 微信分享
  setShare: function(options) {
    $.ajax({
      url: this.config.getSignatureApi,
      type: "post",
      cache: false,
      async: false,
      data: {
        PARAM_weixinAccount: "3359947936",
        PARAM_PageUrl: window.location.href.split("#")[0]
      },
      dataType: "jsonp",
      jsonp: "PARAM_Jsonpcallback",
      success: res => {
        if (res.status === 1) {
          const signature = res.Data.Signature.split("|");
          window.__WX_AUTH__ = {
            debug: false,
            ...options,
            appId: "..",
            signature: signature[0],
            timestamp: signature[1],
            nonceStr: "...",
            jsApiList: [
              "onMenuShareTimeline",
              "onMenuShareAppMessage",
              "onMenuShareQQ",
              "onMenuShareWeibo"
            ]
          };
          // console.log(window.__WX_AUTH__);
          wxBridge();
        }
      },
      error: function(err) {
        console.log(err);
      }
    });

    // ai系app分享用方法
    window.customizewebconfig = function customizewebconfig() {
      return JSON.stringify({
        shareTitle: options.title,
        shareContent: options.desc,
        shareImg: options.imgUrl,
        shareurl: options.shareUrl
      });
    };

    if (tools.isWebView()) {
      tools.jsNativeBridge("showShare", {
        title: options.title,
        des: options.desc,
        img: options.imgUrl,
        url: options.shareUrl
      });
    }
  },

  // 获取app分享链接
  getAppShareUrl: function(options) {
    const appInfo = tools.isWebView();
    let baseUrl = "";
    switch (appInfo) {
      case "5":
        // 二app
        baseUrl = "bitautousedcar:";
        break;
      case "108":
      case "aiapp":
        // app
        baseUrl = "https://...:";
        break;
      default:
        break;
    }
    if (baseUrl) {
      return encodeURI(
        `${baseUrl}//?platform=web&action=openShareController&title=${options.title}&content=${options.desc}&shareURL=${options.shareUrl}&imageURL=${options.imgUrl}`
      );
    } else {
      return false;
    }
  }
};

export default weixin;
```

### 调用

```javascript
import weixin from "weixin.js";

const shareOption = {
  title: "首付1万月租666，买车比买包还轻松！",
  desc: "新车30款热销车型特惠，总价最高直降2.2万，首付1万就开走！",
  imgUrl: "http://...",
  shareUrl: window.location.href
};
weixin.setShare(shareOption);
```

### 调试

1. 测试环境暂不支持查看该项功能，需灰度环境查看
2. 在控制台中查看是否有 GetSignature 请求，成功发起请求说明调用成功
3. 分享还是不成功,查看 GetSignature 请求参数，根据下图排查，查看 1 框中是否有更新，2 框中的 url 公众号是否配置；

**注意**

- 该功能在分享到朋友圈只取到 shareOption.title ；
- 暂不支持 title 和 desc 都在朋友圈展示。

## 19. 快速排序

```js
function quickSort(arr) {
  if (arr.length < 2) return arr;
  var middle = Math.floor(arr.length / 2);
  var flag = arr.splice(middle, 1)[0];
  var left = [],
    right = [];
  for (var i = 0; i < arr.length; i++) {
    if (arr[i] < flag) {
      left.push(arr[i]);
    } else {
      right.push(arr[i]);
    }
  }
  return quickSort(left).concat([flag], quickSort(right));
}
```

## 20. 最长公共子串

```js
function findSubStr(str1, str2) {
  if (str1.length > str2.length) {
    [str1, str2] = [str2, str1];
  }
  var result = "";
  var len = str1.length;
  for (var j = len; j > 0; j--) {
    for (var i = 0; i < len - j; i++) {
      result = str1.substr(i, j);
      if (str2.includes(result)) return result;
    }
  }
}
console.log(findSubStr("aabbcc11", "ppooiiuubcc123")); // bcc1
```

## 21. 最长公共子序列(LCS 动态规划)

```js
// dp[i][j] 计算去最大长度，
// 记住口诀：相等左上角加一，不等取上或左最大值
function LCS(str1, str2) {
  var rows = str1.split("");
  rows.unshift("");
  var cols = str2.split("");
  cols.unshift("");
  var m = rows.length;
  var n = cols.length;
  var dp = [];
  for (var i = 0; i < m; i++) {
    dp[i] = [];
    for (var j = 0; j < n; j++) {
      if (i === 0 || j === 0) {
        dp[i][j] = 0;
        continue;
      }

      if (rows[i] === cols[j]) {
        dp[i][j] = dp[i - 1][j - 1] + 1; //对角＋1
      } else {
        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); //对左边，上边取最大
      }
    }
    console.log(dp[i].join("")); //调试
  }
  return dp[i - 1][j - 1];
}
//!!!如果它来自左上角加一，则是子序列，否则向左或上回退。
//findValue过程，其实就是和 就是把T[i][j]的计算反过来。
// 求最长子序列
function findValue(input1, input2, n1, n2, T) {
  var i = n1 - 1,
    j = n2 - 1;
  var result = []; //结果保存在数组中
  console.log(i);
  console.log(j);
  while (i > 0 && j > 0) {
    if (input1[i] == input2[j]) {
      result.unshift(input1[i]);
      i--;
      j--;
    } else {
      //向左或向上回退
      if (T[i - 1][j] > T[i][j - 1]) {
        //向上回退
        i--;
      } else {
        //向左回退
        j--;
      }
    }
  }

  console.log(result);
}
```

## 22. 实现一个函数功能：sum(1,2,3,4..n)转化为 sum(1)(2)(3)(4)…(n)

```java
// 使用柯里化 + 递归
function curry ( fn ) {
  var c = (...arg) => (fn.length === arg.length) ?
          fn(...arg) : (...arg1) => c(...arg, ...arg1)
  return c
}

const curry = (fn, arr = []) => (...args) =>
  (arg => (
    arg.length === fn.length ? fn(...arg) : curry(fn, arg)
  ))([...arr,...args]);
```

## 23. 贪心算法解决背包问题

```js
var items = ["A", "B", "C", "D"];
var values = [50, 220, 60, 60];
var weights = [5, 20, 10, 12];
var capacity = 32; //背包容积

greedy(values, weights, capacity); // 320

function greedy(values, weights, capacity) {
  var result = 0;
  var rest = capacity;
  var sortArray = [];
  var num = 0;
  values.forEach((v, i) => {
    sortArray.push({
      value: v,
      weight: weights[i],
      ratio: v / weights[i]
    });
  });
  sortArray.sort((a, b) => b.ratio - a.ratio);
  sortArray.forEach((v, i) => {
    num = parseInt(rest / v.weight);
    rest -= num * v.weight;
    result += num * v.value;
  });
  return result;
}
```

## 24. 输入一个递增排序的数组和一个数字 S，在数组中查找两个数，使得他们的和正好是 S，如果有多对数字的和等于 S，输出两个数的乘积最小的。

```js
function FindNumbersWithSum(array, sum) {
  var index = 0;
  for (var i = 0; i < array.length - 1 && array[i] < sum / 2; i++) {
    for (var j = i + 1; j < array.length; j++) {
      if (array[i] + array[j] === sum) return [array[i], array[j]];
    }
    //index = array.indexOf(sum - array[i], i + 1)
    // if (index !== -1) {
    //     return [array[i], array[index]]
    //}
  }
  return [];
}
```

## 25. 反转二叉树

```js
var invertTree = function(root) {
  if (root !== null) {
    [root.left, root.right] = [root.right, root.left];
    invertTree(root.left);
    invertTree(root.right);
  }
  return root;
};
```

## 26. 二叉树各种(层序)遍历

深度广度遍历

```js
// 根据前序和中序重建二叉树
/* function TreeNode(x) {
    this.val = x;
    this.left = null;
    this.right = null;
} */
function reConstructBinaryTree(pre, vin) {
  var result = null;
  if (pre.length === 1) {
    result = {
      val: pre[0],
      left: null,
      right: null
    };
  } else if (pre.length > 1) {
    var root = pre[0];
    var vinRootIndex = vin.indexOf(root);
    var vinLeft = vin.slice(0, vinRootIndex);
    var vinRight = vin.slice(vinRootIndex + 1, vin.length);
    pre.shift();
    var preLeft = pre.slice(0, vinLeft.length);
    var preRight = pre.slice(vinLeft.length, pre.length);
    result = {
      val: root,
      left: reConstructBinaryTree(preLeft, vinLeft),
      right: reConstructBinaryTree(preRight, vinRight)
    };
  }
  return result;
}

// 递归
// 前序遍历
function prevTraverse(node) {
  if (node === null) return;

  console.log(node.data);
  prevTraverse(node.left);
  prevTraverse(node.right);
}

// 中序遍历
function middleTraverse(node) {
  if (node === null) return;

  middleTraverse(node.left);
  console.log(node.data);
  middleTraverse(node.right);
}

// 后序遍历
function lastTraverse(node) {
  if (node === null) return;

  lastTraverse(node.left);
  lastTraverse(node.right);
  console.log(node.data);
}

// 非递归
// 前序遍历
function preTraverse(tree) {
  var arr = [],
    node = null;
  arr.unshift(tree);
  while (arr.length) {
    node = arr.shift();
    console.log(node.root);
    if (node.right) arr.unshift(node.right);
    if (node.left) arr.unshift(node.left);
  }
}

// 中序遍历
function middleTraverseUnRecursion(root) {
  let arr = [],
    node = root;

  while (arr.length !== 0 || node !== null) {
    if (node === null) {
      node = arr.shift();
      console.log(node.data);
      node = node.right;
    } else {
      arr.unshift(node);
      node = node.left;
    }
  }
}

// 广度优先-层序遍历
// 递归
var result = [];
var stack = [tree];
var count = 0;
var bfs = function() {
  var node = stack[count];
  if (node) {
    result.push(node.value);
    if (node.left) stack.push(node.left);
    if (node.right) stack.push(node.right);
    count++;
    bfs();
  }
};
bfs();
console.log(result);
// 非递归
function bfs(node) {
  var result = [];
  var queue = [];
  queue.push(node);
  while (queue.length) {
    node = queue.shift();
    result.push(node.value);
    node.left && queue.push(node.left);
    node.right && queue.push(node.right);
  }
  return result;
}
```

## 27. 各种排序

```js
// 插入排序
function insertSort(arr) {
  var temp;
  for (var i = 1; i < arr.length; i++) {
    temp = arr[i];
    for (var j = i; j > 0 && temp < arr[j - 1]; j--) {
      arr[j] = arr[j - 1];
    }
    arr[j] = temp;
  }
  return arr;
}
console.log(insertSort([3, 1, 8, 2, 5]));

// 归并排序
function mergeSort(array) {
  var result = array.slice(0);
  function sort(array) {
    var length = array.length;
    var mid = Math.floor(length * 0.5);
    var left = array.slice(0, mid);
    var right = array.slice(mid, length);
    if (length === 1) return array;
    return merge(sort(left), sort(right));
  }
  function merge(left, right) {
    var result = [];

    while (left.length || right.length) {
      if (left.length && right.length) {
        if (left[0] < right[0]) {
          result.push(left.shift());
        } else {
          result.push(right.shift());
        }
      } else if (left.length) {
        result.push(left.shift());
      } else {
        result.push(right.shift());
      }
    }
    return result;
  }
  return sort(result);
}
console.log(mergeSort([5, 2, 8, 3, 6]));

// 二分插入排序
function twoSort(array) {
  var len = array.length,
    i,
    j,
    tmp,
    low,
    high,
    mid,
    result;
  result = array.slice(0);
  for (i = 1; i < len; i++) {
    tmp = result[i];
    low = 0;
    high = i - 1;
    while (low <= high) {
      mid = parseInt((high + low) / 2, 10);
      if (tmp < result[mid]) {
        high = mid - 1;
      } else {
        low = mid + 1;
      }
    }
    for (j = i - 1; j >= high + 1; j--) {
      result[j + 1] = result[j];
    }
    result[j + 1] = tmp;
  }
  return result;
}
console.log(twoSort([4, 1, 7, 2, 5]));
```

## 28. 使用尾递归对斐波那契优化

递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。

```js
// 传统递归斐波那契, 会造成超时或溢出
function Fibonacci(n) {
  if (n <= 1) {
    return 1;
  }

  return Fibonacci(n - 1) + Fibonacci(n - 2);
}

Fibonacci(10); // 89
Fibonacci(100); // 超时
Fibonacci(500); // 超时

// 使用尾递归优化, 可规避风险
function Fibonacci2(n, ac1 = 1, ac2 = 1) {
  if (n <= 1) {
    return ac2;
  }

  return Fibonacci2(n - 1, ac2, ac1 + ac2);
}

Fibonacci2(100); // 573147844013817200000
Fibonacci2(1000); // 7.0330367711422765e+208
Fibonacci2(10000); // Infinity
```

## 29. 两个升序数组合并为一个升序数组

```js
function sort(A, B) {
  var i = 0,
    j = 0,
    p = 0,
    m = A.length,
    n = B.length,
    C = [];
  while (i < m || j < n) {
    if (i < m && j < n) {
      C[p++] = A[i] < B[j] ? A[i++] : B[j++];
    } else if (i < m) {
      C[p++] = A[i++];
    } else {
      C[p++] = B[j++];
    }
  }
  return C;
}
```

## 30.
