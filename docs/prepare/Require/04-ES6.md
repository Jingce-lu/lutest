# Add 2020 Es6

[[toc]]

## 1.谈谈你对 es6 的 module 体系的理解

1. 每一个模块只加载一次， 每一个 JS 只执行一次， 如果下次再去加载同目录下同文件，直接从内存中读取。 一个模块就是一个单例，或者说就是一个对象；
2. 每一个模块内声明的变量都是局部变量， 不会污染全局作用域；
3. 模块内部的变量或者函数可以通过 export 导出；
4. 一个模块可以导入别的模块

## 2.module、export、import 分别有什么作用？

- **module** 每个文件就是一个模块。文件内定义的变量、函数等等都是在自己的作用域内，都是自身所私有的，对其它文件不可见。
  - 在 module 中有一个属性 exports，即：module.exports。它是该模块对外的输出值，是一个对象。其它模块在加载该模块时，实际上加载到的数据都是由它提供的。
  - module.exports 输出的可以是一个对象，也可以是一个函数。在引用该模块的文件内，如果接受到的是对象，可以直接访问其中的属性，如果接受到的是一个函数，也可以直接执行。
- **export** 用于规定模块的对外接口，可以输出变量、函数或类。export 规定的对外接口必须与模块内部的变量建立一一对应关系
- **import** `import`和`export`配对使用，用于加载接收 export 输入的内容

## 3.说说你对 Babel 的了解？

**babel**其实是一个解释器，它主要讲进行中的代码分为三个阶段执行：`解析`，`转换`，`生成`。其中 babel 插件或者其他插件都是在转换阶段起作用。

## 4.es6 函数的 rest 参数你有了解吗？

ES6 引入 `rest` 参数（`形式为...变量名`），用于获取函数的多余参数，这样就不需要使用`arguments`对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。

```js
unction add(...values) {
  let sum = 0;

  for (var val of values) {
    sum += val;
  }

  return sum;
}

add(2, 5, 3) // 10
```

`rest`参数和 `arguments`对象的区别

- `rest`参数只包含那些没有对应形参的实参，而`arguments`对象包含了传给函数的所有实参。
- arguments 对象不是一个真正的数组，`而rest参数是真正的Array实例`，也就是说你能够在它上面直接使用所有的数组方法，比如 sort，map，forEach 或 pop。
- arguments 对象还有一些附加的属性 （如 callee 属性）。

## 5.说说你对 class 的理解

类（class）的写法

```js
class MyClass {
  constructor() {}
  method1() {}
  method2() {}
  method3() {}
}
```

- 首先，**由 class 创建的函数由特殊的内部属性标记**`[[FunctionKind]]:"classConstructor"`.所以它与手动创建并不完全相同。与常规函数不同，**如果没有 new，则无法调用类构造函数**
- **类方法是不可枚举的**。对于原型中的所有方法，类定义将 enumerable 标志设置为 false。
- **类总是使用严格模式的**。这意味着类构造中的所有代码都自动处于严格模式

## 6.说说你对 set 数据结构的理解

- 成员唯一、无序且不重复；
- [value, value]，键值与键名是一致的（或者说只有键值，没有键名）；
- 可以遍历，方法有：add、delete、has。

## 7.let 和 const 的区别是什么

相同点：

1. ES6 中的命令，声明的变量或常量不再是全局变量的属性或方法。
   let a=0 window.a//'undefined'
2. 都是命令
3. 块级作用域，块之外访问会报错
4. 不能变量提升，在声明之前访问会报错
5. 不允许在同一快中重复声明（let,const 一样）
6. 暂时性死区，所声明的变量或者常量会绑定到该区块，不再受外部影响

不同点：

1. let 声明的是变量，const 声明的是常量，只读，修改值会报错
2. const 保存的是内存地址,可以给对象或数组添加属性或元素，但是不能重新复写。

## 8.箭头函数与普通函数有什么区别？它有哪些新的特性？

1. 函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象，用 call apply bind 也不能改变 this 指向
2. 不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误。
3. 不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。
4. 不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。
5. 箭头函数没有原型对象 prototype

箭头函数的特性

1. 箭头函数是匿名函数，自身没有 this 和 arguments，它的 this 从上下文捕捉而来；
2. 箭头函数不能作为构造函数，和 new 一起用就会抛出错误；
3. 箭头函数没有原型属性（prototype）；
4. 箭头函数不能当做 Generator 函数,不能使用 yield 关键字

## 9.es6 对函数做了哪些优化？

1. 默认参数(default parameters)
2. 任意参数(rest parameters ...)
3. spread 操作符(...)
4. new.target 元属性
5. 箭头函数( => )
6. 其他一些改动(miscellaneous)
7. 函数中新增的 name 属性。es6 也定义了块级函数的行为，即使在严格模式下块级函数也不再是一个语法错误
8. es6 中，普通的函数会触发函数的`[[call]]`方法调用，通过 new 关键字调用函数会触发函数的`[[constructor]]`方法调用。新增的元素属性`new.target`可以帮助你检测函数是通过何种方式调用的
9. 尾调用指的是函数作为另一个函数的最后一条语句被调用。尾调用优化可以帮助函数保持一个更小的调用栈，从而减小内存的使用，避免栈溢出错误。当程序满足优化条件时，引擎会自动对其优化。当然，你可能希望重写递归函数，从而使引擎更好地优化你的程序.

## 10.说说你对 async/await 的理解？

是一个用同步的思维来解决异步问题的方案

- **async** 是一个修饰符，`async` 定义的函数会默认的返回一个 Promise 对象 resolve 的值，因此对 async 函数可以直接进行 then 操作,返回的值即为 then 方法的传入函数
- await 也是一个修饰符, await 关键字 只能放在 async 函数内部， await 关键字的作用 就是获取 Promise 中返回的内容， 获取的是 Promise 函数中 resolve 或者 reject 的值  
  // 如果 await 后面并不是一个 Promise 的返回值，则会按照同步程序返回值处理

## 11.Generator 函数是什么？它有什么应用场景？

Generator 函数是一个函数的内部状态的遍历器（也就是说，Generator 函数是一个状态机）。

形式上，Generator 函数是一个普通函数，但是有两个特征。

一是，function 命令与函数名之间有一个星号； 二是，函数体内部使用 yield 语句，定义遍历器的每个成员，即不同的内部状态。

generator 的应用场景举例如下：

1. 延迟执行
   generator 调用后，其状态是挂起的，通过调用 next()来让其继续执行，从而达到延迟执行的效果：

   ```js
   function* fibGen(n) {
     var current = 0,
       next = 1,
       swap;
     for (var i = 0; i < n; i++) {
       (swap = current), (current = next);
       next = swap + next;
       yield current;
     }
   }
   var fibIter = fibGen(20);
   var next = fibIter.next();
   console.log(next.value);

   setTimeout(function() {
     var next = fibIter.next();
     console.log(next.value);
   }, 2000);
   ```

2. 无限长的序列
   由于 generator 是延迟执行的，因此你可以使用 generator 创建一个无限长的序列：
   ```js
   function* fibGen() {
     var current = 0,
       next = 1,
       swap;
     while (true) {
       (swap = current), (current = next);
       next = swap + next;
       yield current;
     }
   }
   for (var num of fibGen()) {
     if (num < 5000) break;
   }
   console.log(num); // 6765
   ```
3. 异步流程控制

### Generator 实现

```js
// cb 也就是编译过的test函数
function generator(cb) {
  return (function() {
    var object = {
      next: 0,
      stop: function() {}
    };

    return {
      next: function() {
        var ret = cb(object);
        if (ret === undefined) {
          return {
            value: undefined,
            done: true
          };
        }

        return {
          value: ret,
          done: false
        };
      }
    };
  })();
}
```

## 12.Object.is()和比较操作符"="的区别是什么？

`Object.is` 用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。返回布尔值，相等返回 `true`，不相等返回 `false`。

**不同之处只有两个：一是+0 不等于-0，二是 NaN 等于自身**。

```js
+0 === -0; //true
NaN === NaN; // false

Object.is(+0, -0); // false
Object.is(NaN, NaN); // true
```

Object.is()判断两个值是否相同。如果下列任何一项成立，则两个值相同：

1. 两个值都是 undefined
1. 两个值都是 null
1. 两个值都是 true/false
1. 两个值是由相同个数的字符按照相同的顺序组成的字符串
1. 两个值指向同一个对象
1. 两个值都是数字并且都是正零+0/都是负零-0
1. 都是 NaN
1. 都是除零和 NaN 外的其它同一个数字

对于不兼容 ES6 的浏览器，可以在 ES5 环境下通过下面的代码，部署 Object.is。

```js
Object.defineProperty(Object, "is", {
  value: function(x, y) {
    if (x === y) {
      // 针对+0 不等于 -0的情况
      return x !== 0 || 1 / x === 1 / y;
    }
    // 针对NaN的情况
    return x !== x && y !== y;
  },
  configurable: true,
  enumerable: false,
  writable: true
});
```

## 13.说说你对 Iterator 的理解

遍历器（Iterator）是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。

Iterator 的作用有三个：

1. 为各种数据结构，提供一个统一的、简便的访问接口；
2. 使得数据结构的成员能够按某种次序排列；
3. ES6 创造了一种新的遍历命令 for...of 循环，Iterator 接口主要供 for...of 消费。

遍历过程：

1. 创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。
2. 第一次调用指针对象的 next 方法，可以将指针指向数据结构的第一个成员。
3. 第二次调用指针对象的 next 方法，指针就指向数据结构的第二个成员。
4. 不断调用指针对象的 next 方法，直到它指向数据结构的结束位置。

每一次调用 next 方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含 value 和 done 两个属性的对象。其中，value 属性是当前成员的值，done 属性是一个布尔值，表示遍历是否结束。

**原生具备 Iterator 接口的数据结构如下**：

1. Array
2. Map
3. Set
4. String
5. TypedArray
6. 函数的 arguments 对象
7. NodeList 对象

一个为对象添加 Iterator 接口的例子

```js
let obj = {
  data: ["hello", "world"],
  [Symbol.iterator]() {
    const self = this;
    let index = 0;
    return {
      next() {
        if (index < self.data.length) {
          return {
            value: self.data[index++],
            done: false
          };
        } else {
          return { value: undefined, done: true };
        }
      }
    };
  }
};
```

下面是类似数组的对象调用数组的 Symbol.iterator 方法的例子

```js
let iterable = {
  0: "a",
  1: "b",
  2: "c",
  length: 3,
  [Symbol.iterator]: Array.prototype[Symbol.iterator]
};
for (let item of iterable) {
  console.log(item); // 'a', 'b', 'c'
}
```

## 14.Reflect 是什么，有什么应用场景？

Reflect 词意为“反射”，其对象方法与 Proxy 对象的方法对应，并且也与 Object 的方法对应，也就是 javaScript 用来实现映射的 API，注意 Reflect 不能执行 new 指令。

对于 JS 中的 reflect，我们就可以理解为：**有这么一个全局对象，上面直接挂载了对象的某些特殊方法，这些方法可以通过 Reflect.apply 这种形式来使用，当然所有方法都是可以在 Object 的原型链中找到的**。

Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法。Reflect 不是一个函数对象，因此它是不可构造的。Reflect 的所有的方法都是静态的就和 Math 一样，目前它还没有静态属性。

常见方法

1. Reflect.apply
1. Reflect.construct
1. Reflect.defineProperty
1. Reflect.deleteProperty
1. Reflect.enumerate // 废弃的
1. Reflect.get
1. Reflect.getOwnPropertyDescriptor
1. Reflect.getPrototypeOf
1. Reflect.has
1. Reflect.isExtensible
1. Reflect.ownKeys
1. Reflect.preventExtensions
1. Reflect.set
1. Reflect.setPrototypeOf

一个使用 proxy 和 reflect 实现监听对象的小例子

```js
// on-change是一个可以监听对象或者数组内部变化的小工具，
// 主要使用proxy来实现。以下是核心代码：
// onChange 即要进行的监听操作
module.exports = (object, onChange) => {
  const handler = {
    get(target, property, receiver) {
      try {
        return new Proxy(target[property], handler);
      } catch (err) {
        return Reflect.get(target, property, receiver);
      }
    },
    defineProperty(target, property, descriptor) {
      onChange();
      return Reflect.defineProperty(target, property, descriptor);
    },
    deleteProperty(target, property) {
      onChange();
      return Reflect.deleteProperty(target, property);
    }
  };

  return new Proxy(object, handler);
};
```

## 15.Proxy 是什么，有什么应用场景？

1. Proxy 用于修改某些操作的默认行为，同等于在语言层面做出修改，所以属于一种“元编程”，即对编程语言进行编程。
2. Proxy 可以理解在目标对象前架设一个拦截层，外界对该对象的访问都必须先通过这层拦截，因此可以提供一种机制对外界的访问进行过滤和改写。Proxy 词意为“代理”，所以通常也被称为代理器。

应用场景: **数据验证、值修正及附加属性、扩展构造函数等**

**proxy 支持的方法有**

1. `get()`：拦截对象属性的读取。
2. `set()`：拦截对象属性的设置。
3. `apply()`：拦截函数的调用、call 和 apply 操作。
4. `has()`：即判断对象是否具有某个属性时，这个方法会生效，返回一个布尔值。它有两个参数：目标对象、需查询的属性名。
5. `construct()`：用于拦截 new 命令。参数：`target`(目标对象)、`args`(构造函数的参数对象)、`newTarget`(创建实例对象时，`new`命令作用的构造函数)。
6. `deleteProperty()`：拦截`delete proxy[propKey]`的操作，返回一个布尔值。
7. `defineProperty()`：拦截`object.definePropert`y 操作
8. `getOwnPropertyDescriptor()`：拦截`object.getownPropertyDescriptor()`，返回一个属性描述对象或者`undefined`。
9. `getPrototypeOf()`：用来拦截获取对象原型。可以拦截`Object.prototype.__proto__`、 `Object.prototype.isPrototypeOf()`、 `Object.getPrototypeOf()`、 `Reflect.getPrototypeOf()`、 `instanceof`
10. `isExtensible()`：拦截`Object.isExtensible`操作，返回布尔值。
11. `ownKeys()`：拦截对象自身属性的读取操作。可拦截`Object.getOwnPropertyNames()`、`Object.getOwnPropertySymbols()`、`Object.keys()`、`for...in`循环。
12. `preventExtensions()`：拦截`Object.preventExtensions()`，返回一个布尔值。
13. `setPrototypeOf()`：拦截`Object.setPrototypeOf`方法。
14. `revocable()`：返回一个可取消的`proxy`实例。

## 16.es6 对 es5 有哪些方面的优化呢？

let, const, class, extends, super, arrow functions, template string, destructuring, default, rest arguments

## 17.举例说明你对 es6 的 extends 的理解

- extends 的继承通过两种方式完成了三类值的继承
- 构造函数设置的属性通过复制完成继承
- 实例方法通过实例原型之间的原型链完成继承
- 构造函数的静态方法通过构造函数之间的原型链完成继承

## 18.举例说明你对 es6 的 class 的理解

定义一个类

```js
class Person {
  constructor(skin, language) {
    this.skin = skin;
    this.language = language;
  }
  say() {
    console.log("I am a Person");
  }
}
```

由于 class 本质还是一个 function 因此它就会拥有一个 prototype 属性，当 new 一个 class 时，会把 class 的 porototype 属性赋值给这个新对象的 proto 属性。（prototype 是函数的一个属性，它是一个指针。对于构造函数来说，prototype 是作为构造函数的属性。prototype 也可以是一个对象，prototype 是对象实例的原型对象。所以 prototype 即是属性，又是对象。在 new 一个对象时,可以理解为一个对象没有 ptototype 属性，所以把 ptototype 给一个对象的 proto。

## 19.你喜欢 es6 的哪些特性？

1. 解构赋值
2. let const 块级作用域
3. promise 等等

## 20.举例说明拓展运算符有什么用途？

替代 arguments，方便数据获取，方便数据合并，方便拷贝

```js
function func(...args) {}
let { notNeed, ...newObj } = oldObj;
newObj = { ...newObj, ...newNewObj };
```

## 21.es6 的模板字符串有什么新的特性？

1. 支持多行；
2. 所有的空格被保留；
3. 可以嵌入变量或表达式；

## 22.使用 es6 怎么快速给一个数组去重？

```js
[...new Set([1, 1, 2, 3, 4, 5, 5, 6, 7, 8, 8])];
```

## 23.TypedArray 有什么应用场景？

主要用于二进制文件（音频，文件，视频，图片...）的处理，一般用不到

`ArrayBuffer`对象作为内存区域，可以存放多种类型的数据。同一段内存，不同数据有不同的解读方式，这就叫做“视图”（view）。`ArrayBuffer`有两种视图，一种是`TypedArray视图`，另一种是`DataView视图`。前者的数组成员都是同一个数据类型，后者的数组成员可以是不同的数据类型。

目前，`TypedArray`视图一共包括 9 种类型，每一种视图都是一种构造函数。

1. `Int8Array`：8 位有符号整数，长度 1 个字节。
2. `Uint8Array`：8 位无符号整数，长度 1 个字节。
3. `Uint8ClampedArray`：8 位无符号整数，长度 1 个字节，溢出处理不同。
4. `Int16Array`：16 位有符号整数，长度 2 个字节。
5. `Uint16Array`：16 位无符号整数，长度 2 个字节。
6. `Int32Array`：32 位有符号整数，长度 4 个字节。
7. `Uint32Array`：32 位无符号整数，长度 4 个字节。
8. `Float32Array`：32 位浮点数，长度 4 个字节。
9. `Float64Array`：64 位浮点数，长度 8 个字节。

这 9 个构造函数生成的数组，统称为`TypedArray视图`。它们很像普通数组，都有`length`属性，都能用方括号运算符（`[]`）获取单个元素，所有数组的方法，在它们上面都能使用。普通数组与 TypedArray 数组的差异主要在以下方面。

- TypedArray 数组的所有成员，都是同一种类型。
- TypedArray 数组的成员是连续的，不会有空位。
- TypedArray 数组成员的默认值为 0。比如，`new Array(10)`返回一个普通数组，里面没有任何成员，只是 10 个空位；`new Uint8Array(10)`返回一个 TypedArray 数组，里面 10 个成员都是 0。
- TypedArray 数组只是一层视图，本身不储存数据，它的数据都储存在底层的`ArrayBuffer`对象之中，要获取底层对象必须使用`buffer`属性。

[来源详见简书 JavaScript(ES6) - ArrayBuffer](https://www.jianshu.com/p/5a841d6d7cc3)

## 24.Set 和 WeakSet 有什么区别？

Set 有 forEach keys values 等方法，类数组结构，可以 add 进各种类型，可以用 keys 和 for-in 取出；
WeakSet 没有那些方法，只能 add 进对象，没法取出，只能 has 判断。
将它们视为始终去重的数组来看就可以了

1. Set

   - 成员唯一、无序且不重复；
   - [value, value]，键值与键名是一致的（或者说只有键值，没有键名）；
   - 可以遍历，方法有：add、delete、has。

2. WeakSet
   - 成员都是对象；
   - 成员都是弱引用，可以被垃圾回收机制回收，可以用来保存 DOM 节点，不容易造成内存泄漏；
   - 不能遍历，方法有 add、delete、has。

## 25.Map 和 WeakMap 有什么区别？

1. Map

   - 本质上是键值对的集合，类似集合；
   - 可以遍历，方法很多，可以跟各种数据格式转换。

2. WeakMap
   - 只接受对象最为键名（null 除外），不接受其他类型的值作为键名；
   - 键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的；
   - 不能遍历，方法有 get、set、has、delete。

## 26.如何让一个对象具有私有属性？

- Symbol 生成的每个值都是独一无二的 用 Symbol 作 key 值 无论是 for in 或 for of 都遍历不到 只能用 Object.getOwnPropertySymbols 才可以遍历到
- 类的构造函数里定义的 function，即为私有方法；而在构造函数里用 var 声明的变量，也相当于是私有变量。

  ```js
  var Person = function(name, sex) {
    this.name = name;
    this.sex = sex;
    var _privateVariable = ""; //私有变量
    //构造器中定义的方法，即为私有方法
    function privateMethod() {
      _privateVariable = "private value";
      alert("私有方法被调用！私有成员值：" + _privateVariable);
    }
    privateMethod(); //构造器内部可以调用私有方法
  };

  Person.prototype.sayHello = function() {
    alert("姓名：" + this.name + "，性别：" + this.sex);
  };

  var p = new Person("菩提树下的杨过", "男");
  p.sayHello();

  //p.privateMethod();//这里将报错，私成方法无法被实例调用
  alert(p._privateVariable); //显示: undefined
  ```

- 实现类似 set,get 属性的封装

  ```js
  var Person = function() {
    var salary = 0.0;

    this.setSalary = function(value) {
      salary = value;
    };

    this.getSalary = function() {
      return salary;
    };
  };

  var p = new Person();

  p.setSalary(1000);
  alert(p.getSalary()); //返回1000
  alert(p.salary); //返回undefined
  ```

## 27.Symbol 有什么作用？

在 ES5 中，对象属性名都是字符串容易造成属性名冲突。为了避免这种情况的发生，ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。
symbol 是 JavaScript 在 ES6 中一种基本数据类型。Symbol() 函数返回的是 Symbol 类型的值，该类型具有静态方法和静态属性。

## 28.for…of 和 for…in 有什么区别？

- `for..of`适用遍历数/数组对象/字符串/map/set 等`拥有迭代器对象的集合`.但是不能遍历对象,因为没有迭代器对象.与 forEach()不同的是，它可以正确响应 break、continue 和 return 语句
- `for-of`循环不支持普通对象，但如果你想迭代一个对象的属性，你可以用 for-in 循环（这也是它的本职工作）或内建的 Object.keys()方法：
- for...in 循环出的是 key，for...of 循环出的是 value
- for...of 不能循环普通的对象，需要通过和 Object.keys()搭配使用

for...of 循环不会循环对象的 key，只会循环出数组的 value，因此 for...of 不能循环遍历普通对象,对普通对象的属性遍历推荐使用 for...in

如果实在想用 for...of 来遍历普通对象的属性的话，可以通过和 Object.keys()搭配使用，先获取对象的所有 key 的数组 然后遍历：

```js
var student = {
  name: "wujunchuan",
  age: 22,
  locate: {
    country: "china",
    city: "xiamen",
    school: "XMUT"
  }
};
for (var key of Object.keys(student)) {
  //使用Object.keys()方法获取对象key的数组
  console.log(key + ": " + student[key]);
}
```

## 29.es6 新增了哪些数据类型？

1. symbol
2. Set
3. Map
4. WeakSet 类型（复杂）
5. WeakMap 类型（复杂）
6. TypedArray 类型（复杂）

`TypedArray`主要用于二进制文件（音频，文件，视频，图片...）的处理，一般用不到

## 30.说下 var、let 和 const 有什么区别？

相同之处

1. var, let 都是定义变量的，
2. let, const 有块级作用域（以大括号为边界），不存在变量提升。
3. var, let, const 都受函数作用域限制。

不同之处

1. const 定义常量之后，存储的是变量的内存地址，如果指向的是一个数组或者对象，数组对象里面依然可以增删元素。
2. var 声明的变量会提升到当前函数作用域的顶部，`function name(){}` 方式声明的函数，隐性的也是一个 var 声明，函数的 name 会提升到函数作用域的顶部，如果没有父级函数作用域，就是挂载到 window 下, 在一个 if 条件内部声明 let 和 var，var 会提升到外部函数作用域里，let 不会。

## 31.使用箭头函数应该需要注意什么？

在使用箭头函数的时候要注意 this 的指向，同时也要注意 arguments

什么时候不该使用 es6 箭头函数

1. **在对象上定义函数**

   ```js
   var obj = {
     array: [1, 2, 3],
     sum: () => {
       console.log(this === window); // => true
       return this.array.reduce((result, item) => result + item);
     }
   };

   // Throws "TypeError: Cannot read property 'reduce' of undefined"
   obj.sum();
   ```

   sum 方法定义在 obj 对象上，当调用的时候我们发现抛出了一个 TypeError，因为函数中的 this 是 window 对象，所以 this.array 也就是 undefined。原因也很简单，相信只要了解过 es6 箭头函数的都知道

   > 箭头函数没有它自己的 this 值，箭头函数内的 this 值继承自外围作用域

   解决方法也很简单，就是不用呗。这里可以用 es6 里函数表达式的简洁语法，在这种情况下，this 值就取决于函数的调用方式了。

   ```js
   var obj = {
     array: [1, 2, 3],
     sum() {
       console.log(this === obj); // => true
       return this.array.reduce((result, item) => result + item);
     }
   };

   obj.sum(); // => 6
   ```

2. **在原型上定义函数**  
   在对象原型上定义函数也是遵循着一样的规则

   ```js
   function Person(pName) {
     this.pName = pName;
   }

   Person.prototype.sayName = () => {
     console.log(this === window); // => true
     return this.pName;
   };

   var person = new Person("wdg");

   person.sayName(); // => undefined
   ```

   使用 function 函数表达式

   ```js
   function Person(pName) {
     this.pName = pName;
   }

   Person.prototype.sayName = function() {
     console.log(this === person); // => true
     return this.pName;
   };

   var person = new Person("wdg");

   person.sayName(); // => wdg
   ```

   所以给对象原型挂载方法时，使用 function 函数表达式

3. **动态上下文中的回调函数**  
   this 是 js 中非常强大的特点，他让函数可以根据其调用方式动态的改变上下文，然后箭头函数直接在声明时就绑定了 this 对象，所以不再是动态的。<br />
   在客户端，在 dom 元素上绑定事件监听函数是非常普遍的行为，在 dom 事件被触发时，回调函数中的 this 指向该 dom,可当我们使用箭头函数时:

   ```js
   var button = document.getElementById("myButton");
   button.addEventListener("click", () => {
     console.log(this === window); // => true
     this.innerHTML = "Clicked button";
   });
   ```

   因为这个回调的箭头函数是在全局上下文中被定义的，所以他的 this 是 window。所以当 this 是由目标对象决定时，我们应该使用函数表达式:

   ```js
   var button = document.getElementById("myButton");
   button.addEventListener("click", function() {
     console.log(this === button); // => true
     this.innerHTML = "Clicked button";
   });
   ```

4. **构造函数中**  
   在构造函数中，this 指向新创建的对象实例

   ```js
   this instanceOf MyFunction === true
   ```

   需要注意的是，构造函数不能使用箭头函数，如果这样做会抛出异常

   ```js
   var Person = name => {
     this.name = name;
   };

   // Uncaught TypeError: Person is not a constructor
   var person = new Person("wdg");
   ```

   理论上来说也是不能这么做的，因为箭头函数在创建时 this 对象就绑定了，更不会指向对象实例。

5. **太简短的（难以理解）函数**  
   箭头函数可以让语句写的非常的简洁，但是一个真实的项目，一般由多个开发者共同协作完成，就算由单人完成，后期也并不一定是同一个人维护，箭头函数有时候并不会让人很好的理解，比如

   ```js
   let multiply = (a, b) => (b === undefined ? b => a * b : a * b);

   let double = multiply(2);

   double(3); // => 6

   multiply(2, 3); // =>6
   ```

   这个函数的作用就是当只有一个参数 a 时，返回接受一个参数 b 返回 a\*b 的函数，接收两个参数时直接返回乘积，这个函数可以很好的工作并且看起很简洁，但是从第一眼看去并不是很好理解。<br />
   为了让这个函数更好的让人理解，我们可以为这个箭头函数加一对花括号，并加上 return 语句，或者直接使用函数表达式:

   ```js
   function multiply(a, b) {
       if (b === undefined) {
           return function (b) {
               return a * b;
           }
       }
       return a * b;
   }

   let double = multiply(2);

   double(3); // => 6
   multiply(2, 3)； // => 6
   ```

## 32.举例说明 setImmediate 有什么作用？

该方法用来把一些需要长时间运行的操作放在一个回调函数里，在浏览器完成后面的其他语句后，就立刻执行这个回调函数。

```js
var immediateID = setImmediate(func, [param1, param2, ...]);
var immediateID = setImmediate(func);
```

- `immediateID` 是这次 setImmediate 方法设置的唯一 ID,可以作为 `window.clearImmediate` 的参数.
- func 是将要执行的回调函数

## 33.请分析如下 promise 执行的结果并解释原因[代码]

```js
console.log(1);
const promise = new Promise((resolve, reject) => {
  console.log(2);
  resolve();
  console.log(3);
});
promise.then(() => {
  console.log(4);
});
```

```js
1234
//why?
1.微任务   promise.
2.宏任务  setInterval,setTimeout，script
3.且微任务执行顺序比宏任务快
```

```js
console.log("1");
setTimeout(function() {
  console.log("2");
  process.nextTick(function() {
    console.log("3");
  });
  new Promise(function(resolve) {
    console.log("4");
    resolve();
  }).then(function() {
    console.log("5");
  });
});
process.nextTick(function() {
  console.log("6");
});
new Promise(function(resolve) {
  console.log("7");
  resolve();
}).then(function() {
  console.log("8");
});

setTimeout(function() {
  console.log("9");
  process.nextTick(function() {
    console.log("10");
  });
  new Promise(function(resolve) {
    console.log("11");
    resolve();
  }).then(function() {
    console.log("12");
  });
});
```

js 代码都是从上到下，一行一行指向，首先遇到第一行 console.log(‘1’)；执行输出 1，然后第二行`setTimeout异步任务`，放入任务队列。下面遇到`process.nextTick是微任务`放到本轮循环的结尾，之后遇到`new Promise`直接指向输出 7，`then`被放到本轮循环的结尾，接着执行又遇到的`setTimeout`放到任务队列，本轮代码执行完，开始依次执行本轮结尾的代码，输出 6,8。然后主线程的任务执行完毕，无任务队列中取出一个`setTimeout`放入主线程开始执行，输出 2，然后遇到`process.nextTick`，放到本轮循环的结尾，执行`new Promise`输出 4,`then`放入本轮循环结尾，主线程代码执行完，开始执行本轮结尾输出 3,5。然后再去任务队列中取第二个`setTimeout`执行输出 9,11,10,12。

所以输出的顺序为 1，7，6，8，2，4，3，5，9，11，10，12。

因为 settimeout 是宏任务，虽然先执行的他，但是他被放到了宏任务的 eventqueue 里面，然后代码继续往下检查看有没有微任务，检测到 Promise 的 then 函数把他放入了微任务序列。等到主线进程的所有代码执行结束后。先从微任务 queue 里拿回掉函数，然后微任务 queue 空了后再从宏任务的 queue 拿函数。

## 34. ES7 新特性（2016）

1. 函数作用域中严格模式的变更
2. Array.prototype.includes
3. 求幂运算符（**） `3 ** 2 == Math.pow(3, 2)`

## 35. Es8 新特性（2017）

- Object.values/Object.entries
- 字符串填充
  - str.padStart(targetLength [, padString])
  - str.padEnd(targetLength [, padString])
- async/await
- Object.getOwnPropertyDescriptors()
- SharedArrayBuffer 对象
- Atomics 对象
  - Atomics 对象提供了一组静态方法用来对 SharedArrayBuffer 对象进行原子操作。

## 36. ES9 新特性（2018）

- 异步迭代
- Promise.finally()
- Rest/Spread 属性
- 正则表达式命名捕获组（Regular Expression Named Capture Groups）
- 正则表达式反向断言（lookbehind）
- 正则表达式 dotAll 模式
- 正则表达式 Unicode 转义
- 非转义序列的模板字符串

## 37. ES10 新特性（2019）

- 行分隔符（U + 2028）和段分隔符（U + 2029）符号现在允许在字符串文字中，与 JSON 匹配
- 更加友好的 JSON.stringify
- 新增了 Array 的 flat()方法和 flatMap()方法
- 新增了 String 的 trimStart()方法和 trimEnd()方法
- Object.fromEntries()
- Symbol.prototype.description
- String.prototype.matchAll
- Function.prototype.toString()现在返回精确字符，包括空格和注释
- 简化 try {} catch {},修改 catch 绑定
- 新的基本数据类型 BigInt
- globalThis
- import()
- Legacy RegEx
- 私有的实例方法和访问器

## 38. ES5 的继承和 ES6 的继承有什么区别？

ES5 的继承是通过 prototype 或构造函数机制来实现。

**ES5** 的继承实质上是**先创建子类的实例对象**，然后再将父类的方法添加到 this 上(Parent.apply(this))。

**ES6** 的继承机制实质上是**先创建父类的实例对象** this(所以必须先调用父类的 super()方法)，然后再用子类的构造函数修改 this。具体为 ES6 通过 class 关键字定义类，里面有构造方法，类之间通过 extends 关键字实现继承。子类必须在 constructor 方法中调用 super 方法，否则新建实例报错。因为子类没有自己的 this 对象，而是继承了父类的 this 对象，然后对其调用。如果不调用 super 方法，子类得不到 this 对象。

注意：super 关键字指代父类的实例，即父类的 this 对象。在子类构造函数中，调用 super 后，才可使用 this 关键字，否则报错。
