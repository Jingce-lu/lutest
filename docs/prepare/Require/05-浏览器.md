# Add 2020 浏览器

[[toc]]

## 1. 在浏览器中输入 url 到页面显示出来的过程发生了什么？

主要过程是：  
浏览器解析 -> 查询缓存 -> dns 查询 -> 建立链接 -> 服务器处理请求 -> 服务器发送响应 -> 客户端收到页面 -> 解析 HTML -> 构建渲染树 -> 开始显示内容(白屏时间) -> 首屏内容加载完成(首屏时间) -> 用户可交户(DOMContentLoaded) -> 加载完成(load)

**大致可以分为如下 8 步**

1. 输入网址，浏览器解析构建请求
2. 查询缓存  
   检查强缓存，命中则直接使用，否则检查协商缓存
3. DNS 解析  
   域名与 IP 地址映射
4. 建立 tcp 连接
   - chrome 限制同一域名下最多 6 个 tcp 连接
   - 通过三次握手建立连接, **三次握手过程**:
     1. 客户端向服务器发送连接请求，传递一个数据包 syn，此时客户端处于 SYN_SEND 状态
     2. 服务器接收 syn 报文后，会以自己的 syn 报文作为应答，传递数据包 syn+ack,此时服务器处于 SYN-REVD 状态
     3. 客户端接收 syn 报文后，发送一个数据包 ack，此时客户端处于 ESTABLISHED 状态，双方已建立连接
   - 通过四次挥手断开连接, **四次挥手过程**:
     1. 客户端发送一个 FIN 报文，报文中指定一个序列号，此时客户端处于 FIN_WAIT1 状态，等待服务器确认
     2. 服务器接收到 FIN 后，会发送 ACK 确认报文，表明已经收到客户端报文，此时服务端处于 CLOSE_WAIT2 状态
     3. 服务器发送 FIN，告诉客户端想断开连接，此时服务端处于 LAST_CHECK 阶段
     4. 客户端收到 FIN 后，一样发送一个 ACK 作为应答，此时客户端处于 TIME_WAIT 阶段。需要过一段时间确认服务端收到自己的 ACK 报文后才会进入 CLOSED 状态
5. 发送 http 请求
6. 网络响应
7. 浏览器解析和渲染  
   分为构建 dom 树、样式计算、生成布局树
8. 生成布局

**详细过程**

1. 在浏览器地址栏输入 URL
2. 浏览器查看 缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤
   - 如果资源未缓存，发起新请求
   - 如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。
   - 检验新鲜通常有两个 HTTP 头进行控制 Expires 和 Cache-Control：
     - HTTP1.0 提供 Expires，值为一个绝对时间表示缓存新鲜日期
     - HTTP1.1 增加了 Cache-Control: max-age=,值为以秒为单位的最大新鲜时间
3. 浏览器`解析URL`获取协议，主机，端口，path
4. 浏览器`组装一个HTTP（GET）请求报文`
5. 浏览器获取主机 ip 地址，过程如下：
   - 浏览器缓存
   - 本机缓存
   - hosts 文件
   - 路由器缓存
   - ISP DNS 缓存
   - DNS 递归查询（可能存在负载均衡导致每次 IP 不一样）
6. `打开一个socket与目标IP地址，端口建立TCP链接`，三次握手如下：
   - 客户端发送一个 TCP 的 SYN=1，Seq=X 的包到服务器端口
   - 服务器发回 SYN=1， ACK=X+1， Seq=Y 的响应包
   - 客户端发送 ACK=Y+1， Seq=Z
7. TCP 链接建立后发送 HTTP 请求
8. 服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用 HTTP Host 头部判断请求的服务程序
9. 服务器检查 HTTP 请求头是否包含缓存验证信息如果验证缓存新鲜，返回`304`等对应状态码
10. 处理程序读取完整请求并准备 HTTP 响应，可能需要查询数据库等操作
11. 服务器将`响应报文通过TCP连接发送回浏览器`
12. 浏览器接收 HTTP 响应，然后根据情况选择 `关闭TCP连接或者保留重用`，关闭 TCP 连接的四次握手如下：
    - 主动方发送 Fin=1， Ack=Z， Seq= X 报文
    - 被动方发送 ACK=X+1， Seq=Z 报文
    - 被动方发送 Fin=1， ACK=X， Seq=Y 报文
    - 主动方发送 ACK=Y， Seq=X 报文
13. 浏览器检查响应状态吗：是否为 1XX，3XX， 4XX， 5XX，这些情况处理与 2XX 不同
14. 如果资源可缓存，`进行缓存`
15. 对响应进行`解码`（例如 gzip 压缩）
16. 根据资源类型决定如何处理（假设资源为 HTML 文档）
17. `解析HTML文档，构建DOM树，下载资源，构造CSSOM树，执行js脚本`，这些操作没有严格的先后顺序，以下分别解释
18. `构建DOM树`：
    - Tokenizing：根据 HTML 规范将字符流解析为标记
    - Lexing：词法分析将标记转换为对象并定义属性和规则
    - DOM construction：根据 HTML 标记关系将对象组成 DOM 树
19. 解析过程中遇到图片、样式表、js 文件，启动下载
20. 构建 CSSOM 树：
    - Tokenizing：字符流转换为标记流
    - Node：根据标记创建节点
    - CSSOM：节点创建 CSSOM 树
21. 根据 DOM 树和 CSSOM 树构建渲染树:
    - 从 DOM 树的根节点遍历所有可见节点，不可见节点包括：1）script,meta 这样本身不可见的标签。2)被 css 隐藏的节点，如 display: none
    - 对每一个可见节点，找到恰当的 CSSOM 规则并应用
    - 发布可视节点的内容和计算样式
22. **js 解析如下**：
    - 浏览器创建 Document 对象并解析 HTML，将解析到的元素和文本节点添加到文档中，此时`document.readystate为loading`
    - HTML 解析器遇到没有`async和defer的script`时，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用 document.write()把文本插入到输入流中。**同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作 script 和他们之前的文档内容**
    - 当解析器遇到设置了`async`属性的 script 时，开始`下载脚本并继续解析文档`。脚本会在它下载完成后尽快执行，但是`解析器不会停下来等它下载`。异步脚本禁止使用 document.write()，它们可以访问自己 script 和之前的文档元素
    - 当文档完成解析，document.readState 变成 interactive
    - 所有 defer 脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用 document.write()
    - 浏览器在 Document 对象上触发 DOMContentLoaded 事件
    - 此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，document.readState 变为 complete,window 触发 load 事件
23. 显示页面（HTML 解析过程中会逐步显示页面）

## 2. 浏览器的渲染机制

浏览器的渲染机制一般分为以下几个步骤

1. 处理 HTML 并构建 DOM 树。
2. 处理 CSS 构建 CSSOM 树。
3. 将 DOM 与 CSSOM 合并成一个渲染树。
4. 根据渲染树来布局，计算每个节点的位置。
5. 调用 GPU 绘制，合成图层，显示在屏幕上。

<img :src="$withBase('/images/prepare/require/04.png')" alt="images/prepare/require/04.png">

在构建 CSSOM 树时，会阻塞渲染，直至 CSSOM 树构建完成。并且构建 CSSOM 树是一个十分消耗性能的过程，所以应该尽量保证层级扁平，减少过度层叠，越是具体的 CSS 选择器，执行速度越慢。

当 HTML 解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件。并且 CSS 也会影响 JS 的执行，只有当解析完样式表才会执行 JS，所以也可以认为这种情况下，CSS 也会暂停构建 DOM。

<img :src="$withBase('/images/prepare/require/05.png')" alt="images/prepare/require/05.png">

## 3. Load 和 DOMContentLoaded 区别

Load 事件触发代表页面中的 DOM，CSS，JS，图片已经全部加载完毕。

DOMContentLoaded 事件触发代表初始的 HTML 被完全加载和解析，不需要等待 CSS，JS，图片加载。

## 4. 重绘（Repaint）和回流（Reflow）

**触发重排: 页面布局和元素几何属性的改变就会导致重排**

重绘和回流是渲染步骤中的一小节，但是这两个步骤对于性能影响很大。

- 重绘是当节点需要更改外观而不会影响布局的，比如改变 color, background-color 就叫称为重绘
- 回流是布局或者几何属性需要改变就称为回流。

回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流。

会触发回流的操作:

- 页面初次渲染
- 浏览器窗口大小改变
- 元素尺寸、位置、内容发生改变
- 元素字体大小变化
- 添加或者删除可见的 dom 元素
- 激活 CSS 伪类（例如：:hover）
- 查询某些属性或调用某些方法
- clientWidth、clientHeight、clientTop、clientLeft
- offsetWidth、offsetHeight、offsetTop、offsetLeft
- scrollWidth、scrollHeight、scrollTop、scrollLeft
- getComputedStyle()
- getBoundingClientRect()
- scrollTo()

所以以下几个动作可能会导致性能问题：

- 改变 window 大小
- 改变字体
- 添加或删除样式
- 文字改变
- 定位或者浮动
- 盒模型

很多人不知道的是，重绘和回流其实和 Event loop 有关。

1. 当 Event loop 执行完 Microtasks 后，会判断 document 是否需要更新。因为浏览器是 60Hz 的刷新率，每 16ms 才会更新一次。
2. 然后判断是否有 resize 或者 scroll ，有的话会去触发事件，所以 resize 和 scroll 事件也是至少 16ms 才会触发一次，并且自带节流功能。
3. 判断是否触发了 media query
4. 更新动画并且发送事件
5. 判断是否有全屏操作事件
6. 执行 requestAnimationFrame 回调
7. 执行 IntersectionObserver 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好
8. 更新界面
9. 以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 requestIdleCallback 回调。

## 5. 减少重绘和回流

1. 使用 `translate` 替代 `top`

```html
<div class="test"></div>
<style>
  .test {
    position: absolute;
    top: 10px;
    width: 100px;
    height: 100px;
    background: red;
  }
</style>
<script>
  setTimeout(() => {
    // 引起回流
    document.querySelector(".test").style.top = "100px";
  }, 1000);
</script>
```

2. 使用 `visibility` 替换`display: none` ，因为前者只会引起重绘，后者会引发回流（改变了布局）

3. 把 DOM 离线后修改，比如：先把 DOM 给 `display:none` (有一次 Reflow)，然后你修改 100 次，然后再把它显示出来

4. 不要把 DOM 结点的属性值放在一个循环里当成循环里的变量

```js
for (let i = 0; i < 1000; i++) {
  // 获取 offsetTop 会导致回流，因为需要去获取正确的值
  console.log(document.querySelector(".test").style.offsetTop);
}
```

5. 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局

6. 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 `requestAnimationFrame`

7. CSS 选择符从右往左匹配查找，避免 DOM 深度过深

8. 将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 `video` 标签，浏览器会自动将该节点变为图层。

## 6. 事件触发三阶段

事件触发有三个阶段

- `window` 往事件触发处传播，遇到注册的捕获事件会触发
- 传播到事件触发处时触发注册的事件
- 从事件触发处往 `window` 传播，遇到注册的冒泡事件会触发

事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个目标节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。

```js
// 以下会先打印冒泡然后是捕获
node.addEventListener(
  "click",
  event => {
    console.log("冒泡");
  },
  false
);
node.addEventListener(
  "click",
  event => {
    console.log("捕获 ");
  },
  true
);
```

## 7. 注册事件

通常我们使用 `addEventListener` 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 `useCapture` 参数来说，该参数默认值为 `false` `。useCapture` 决定了注册的事件是捕获事件还是冒泡事件。对于对象参数来说，可以使用以下几个属性

- `capture`，布尔值，和 `useCapture` 作用一样
- `once`，布尔值，值为 `true` 表示该回调只会调用一次，调用后会移除监听
- `passive`，布尔值，表示永远不会调用 `preventDefault`

一般来说，我们只希望事件只触发在目标上，这时候可以使用 `stopPropagation` 来阻止事件的进一步传播。通常我们认为 `stopPropagation` 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。`stopImmediatePropagation` 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件。

```js
node.addEventListener(
  "click",
  event => {
    event.stopImmediatePropagation();
    console.log("冒泡");
  },
  false
);
// 点击 node 只会执行上面的函数，该函数不会执行
node.addEventListener(
  "click",
  event => {
    console.log("捕获 ");
  },
  true
);
```

## 8. 事件代理

事件委托还有一个名字叫事件代理，JS 高程上讲：**事件委托就是利用事件冒泡，只制定一个事件处理程序，就可以管理某一类型的所有事件**。我用取快递来解释这个现象： 有三个同事预计会在周一收到快递。为签收快递，有两种办法：一是三个人在公司门口等快递；二是委托给前台代为签收。现实当中，我们大都采用委托的方案。前台收到快递后，她会判断收件人是谁，然后按照收件人的要求签收，甚至代为付款。这种方案还有一个优势，那就是即使公司里来了新员工（不管多少），前台也会在收到寄给新员工的快递后核实并代为签收。

事件代理作用主要是 2 个

1. 将事件处理程序代理到父节点，减少内存占用率
2. 动态生成子节点时能自动绑定事件处理程序到父节点

如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上

```html
<ul id="ul">
  <li>1</li>
  <li>2</li>
  <li>3</li>
  <li>4</li>
  <li>5</li>
</ul>
<script>
  let ul = document.querySelector("##ul");
  ul.addEventListener("click", event => {
    console.log(event.target);
  });
</script>
```

事件代理的方式相对于直接给目标注册事件来说，有以下优点

- 节省内存
- 不需要给子节点注销事件

## 9. 预加载、预渲染

### 预加载

在开发中，可能会遇到这样的情况。有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载。

预加载其实是声明式的 `fetch` ，强制浏览器请求资源，并且不会阻塞 `onload` 事件，可以使用以下代码开启预加载

```html
<link rel="preload" href="http://example.com" />
```

预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好。

### 预渲染

可以通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染

```html
<link rel="prerender" href="http://example.com" />
```

预渲染虽然可以提高页面的加载速度，但是要确保该页面百分百会被用户在之后打开，否则就白白浪费资源去渲染

## 10. 介绍下 http1.0、1.1、2.0 协议的区别？

### HTTP/0.9

已过时。只接受 GET 一种请求方法，没有在通讯中指定版本号，且不支持请求头。由于该版本不支持 POST 方法，因此客户端无法向服务器传递太多信息。

### HTTP/1.0

这是第一个在通讯中指定版本号的 HTTP 协议版本，至今仍被广泛采用，特别是在代理服务器中。

- 构建可扩展性

### HTTP/1.1

持久连接被默认采用，并能很好地配合代理服务器工作。还支持以管道方式在同时发送多个请求，以便降低线路负载，提高传输速度。

HTTP/1.1 相较于 HTTP/1.0 协议的区别主要体现在：

- 缓存处理
- 带宽优化及网络连接的使用
- 错误通知的管理
- 消息在网络中的发送
- 互联网地址的维护
- 安全性及完整性

**标准化的协议**

- 连接可以复用，允许在第一个应答被完全发送之前就发送第二个请求，以降低通信延迟。
- 增加流水线操作
- 支持响应分块
- 引入额外的缓存控制机制
- 引入内容协商机制，包括语言，编码，类型等，并允许客户端和服务器之间约定以最合适的内容进行交换
- 感谢 Host 头，能够使不同域名配置在同一个 IP 地址的服务器上

### HTTP/2

在 HTTP/2 的第一版草案（对 SPDY 协议的复刻）中，新增的性能改进不仅包括 HTTP/1.1 中已有的多路复用，修复队头阻塞问题，允许设置设定请求优先级，还包含了一个头部压缩算法(HPACK)[15][16]。此外， HTTP/2 采用了二进制而非明文来打包、传输客户端—服务器间的数据。[12]

- 加密传输层
- Server-sent events，服务器可以偶尔推送消息到浏览器
- WebSocket，一个新协议，可以通过升级现有 HTTP 协议来建立
- 多路复用，一个 Tcp 中多个 http 请求是并行的 (雪碧图、多域名散列等优化手段 http/2 中将变得多余)
- 二进制格式编码传输
- **header 压缩**: 通过压缩，头部大小可以减少一半之多，如果后面重复发送请求，那么可能压缩后的头部大小只有原始大小的 1/10。
- 服务端推送

### 帧、消息、流和 TCP 连接

有别于 HTTP/1.1 在连接中的明文请求，HTTP/2 与 SPDY 一样，将一个 TCP 连接分为若干个流（Stream），每个流中可以传输若干消息（Message），每个消息由若干最小的二进制帧（Frame）组成。[12]这也是 HTTP/1.1 与 HTTP/2 最大的区别所在。 HTTP/2 中，每个用户的操作行为被分配了一个流编号(stream ID)，这意味着用户与服务端之间创建了一个 TCP 通道；协议将每个请求分割为二进制的控制帧与数据帧部分，以便解析。这个举措在 SPDY 中的实践表明，相比 HTTP/1.1，新页面加载可以加快 11.81% 到 47.7%[17]

### HPACK 算法

HPACK 算法是新引入 HTTP/2 的一个算法，用于对 HTTP 头部做压缩。其原理在于：

客户端与服务端根据 RFC 7541 的附录 A，维护一份共同的静态字典（Static Table），其中包含了常见头部名及常见头部名称与值的组合的代码；
客户端和服务端根据先入先出的原则，维护一份可动态添加内容的共同动态字典（Dynamic Table）；
客户端和服务端根据 RFC 7541 的附录 B，支持基于该静态哈夫曼码表的哈夫曼编码（Huffman Coding）。

### 服务器推送

网站为了使请求数减少，通常采用对页面上的图片、脚本进行极简化处理。但是，这一举措十分不方便，也不高效，依然需要诸多 HTTP 链接来加载页面和页面资源。

HTTP/2 引入了服务器推送，即服务端向客户端发送比客户端请求更多的数据。这允许服务器直接提供浏览器渲染页面所需资源，而无须浏览器在收到、解析页面后再提起一轮请求，节约了加载时间。

## 11. 简单讲解一下 http2 的多路复用

HTTP2 采用二进制格式传输，取代了 HTTP1.x 的文本格式，二进制格式解析更高效。
多路复用代替了 HTTP1.x 的序列和阻塞机制，所有的相同域名请求都通过同一个 TCP 连接并发完成。在 HTTP1.x 中，并发多个请求需要多个 TCP 连接，浏览器为了控制资源会有 6-8 个 TCP 连接都限制。

HTTP2 中

- 同域名下所有通信都在单个连接上完成，消除了因多个 TCP 连接而带来的延时和内存消耗。
- 单个连接上可以并行交错的请求和响应，之间互不干扰

在 HTTP/1 中，每次请求都会建立一次 HTTP 连接，也就是我们常说的 3 次握手 4 次挥手，这个过程在一次请求过程中占用了相当长的时间，即使开启了 `Keep-Alive` ，解决了多次连接的问题，但是依然有两个效率上的问题：

- 第一个：串行的文件传输。当请求 a 文件时，b 文件只能等待，等待 a 连接到服务器、服务器处理文件、服务器返回文件，这三个步骤。我们假设这三步用时都是 1 秒，那么 a 文件用时为 3 秒，b 文件传输完成用时为 6 秒，依此类推。（注：此项计算有一个前提条件，就是浏览器和服务器是单通道传输）
- 第二个：连接数过多。我们假设 Apache 设置了最大并发数为 300，因为浏览器限制，浏览器发起的最大请求数为 6，也就是服务器能承载的最高并发为 50，当第 51 个人访问时，就需要等待前面某个请求处理完成。

HTTP/2 的多路复用就是为了解决上述的两个性能问题。  
在 HTTP/2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。  
帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。  
多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。

简单来说， 就是在同一个 TCP 连接，同一时刻可以传输多个 HTTP 请求  
之前是同一个连接只能用一次， 如果开启了`keep-alive`，虽然可以用多次，但是同一时刻只能有一个 HTTP 请求

<p style="color: red">为什么 HTTP1.1 不能实现多路复用</p>

HTTP1.x 是序列和阻塞机制

HTTP 2.0 是多工复用 TCP 连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了"队头堵塞"。

- 举例来说，在一个 TCP 连接里面，服务器同时收到了 A 请求和 B 请求，于是先回应 A 请求，结果发现处理过程非常耗时，于是就发送 A 请求已经处理好的部分， 接着回应 B 请求，完成后，再发送 A 请求剩下的部分。
- 旧的 http1.1 是会等 A 请求完全处理完后在 处理 B 请求，会阻塞
- 另：http1.1 已经实现了管道机制：即 在同一个 TCP 连接里面，客户端可以同时发送多个请求。http 1.0 并做不到，所以效率很低

<p style="color: red"> HTTP2 </p>

1. 强制 https
2. 性能更高 - 面向流、头压缩、 多路复用
3. 双向通信 - 服务器推送

## 12. HTTP 状态码

- **1xx 初始化**
  - 信息状态码，接收的请求正在处理
  - http2.0 已经么有 1xx 了{websocket 例外}
- **2xx 客户端成功**
  - 200：成功；
  - 202：接受;
  - 204: No Content;
  - 206: Partial Content
- **3xx 重定向缓存**
  - 301：永久重定向；
  - 302 临时转移；
  - 303：See Other, 永久重定向
  - 304：缓存；
  - 307：临时重定向；
- **4xx 客户端失败**
  - 400：参数错误；
  - 401：未认证登陆，无权限访问；
  - 403：禁止访问；
  - 404：未找到；
  - 417：发送资源过大
- **5xx 服务器端失败**
  - 500：服务器内部错误；
  - 503：连接数过多，服务器超负载，
  - 504：网关超时

## 12+ HTTP 相关

Web 使用一种名为 HTTP (HyperText Transfer Protocol，超文本传输协议)的协议作为规范，完成从客户端到服务器端等一系列运作流程

HTTP 协议用于客户端和服务器端之间的通信，  
通过请求和响应的交换达成通信，  
HTTP 是不保存状态的协议，即无状态(stateless)协议

HTTP 方法

- GET：获取资源
- POST：传输实体主体
- PUT: 传输文件
- HEAD：获得报文首部
- OPTIONS：询问支持额方法
- TRACE：追踪路径
- CONNECT: 要求用隧道协议连接代理

HTTP 缺点：

- 通信使用明文（不加密），内容可能会被窃听
- 不验证通信方的身份，因此有可能遭遇伪装
- 无法验证报文的完整性，所以有可能已遭篡改

## 13. TCP 三次握手和四次挥手

1. 客户端发送 syn 包到服务器，等待服务器确认接收。
2. 服务器确认接收 syn 包并确认客户的 syn，并发送回来一个 syn+ack 的包给客户端。
3. 客户端确认接收服务器的 syn+ack 包，并向服务器发送确认包 ack，二者相互建立联系后，完成 tcp 三次握手。
4. 四次握手就是中间多了一层 等待服务器再一次响应回复相关数据的过程

**三次握手过程**

1. 客户端向服务器发送连接请求，传递一个数据包 syn，此时客户端处于 SYN_SEND 状态
2. 服务器接收 syn 报文后，会以自己的 syn 报文作为应答，传递数据包 syn+ack,此时服务器处于 SYN-REVD 状态
3. 客户端接收 syn 报文后，发送一个数据包 ack，此时客户端处于 ESTABLISHED 状态，双方已建立连接

通过四次挥手断开连接  
**四次挥手过程**:

1. 客户端发送一个 FIN 报文，报文中指定一个序列号，此时客户端处于 FIN_WAIT1 状态，等待服务器确认
2. 服务器接收到 FIN 后，会发送 ACK 确认报文，表明已经收到客户端报文，此时服务端处于 CLOSE_WAIT2 状态
3. 服务器发送 FIN，告诉客户端想断开连接，此时服务端处于 LAST_CHECK 阶段
4. 客户端收到 FIN 后，一样发送一个 ACK 作为应答，此时客户端处于 TIME_WAIT 阶段。需要过一段时间确认服务端收到自己的 ACK 报文后才会进入 CLOSED 状态

## 14. tcp 怎么保证可靠性

1. 超时重传机制
2. 对失序数据进行重排序
3. 应答机制
4. 滑动窗口： 用于网络数据传输时的流量控制，以避免拥塞的发生  
   所谓滑动窗口，可以理解成接收端所能提供的缓冲区大小。TCP 利用一个滑动的窗口来告诉发送端对它所发送的数据能提供多大的缓 冲区。
5. 拥塞控制

## 15. tcp 和 udp 区别

1. tcp 只能一对一通信，udp 可以一对一、一对多、多对多通信，即支持多播和广播
2. tcp 首部开销消耗 32 字节，udp 仅消耗 8 个字节
3. tcp 适合对数据安全性要求高的场景，比如文件传输，udp 适合对数据实时性要求高的场景，比如视频通话、语音通话
4. tcp 是有状态连接，udp 是无状态的连接
5. tcp-可靠传输 udp-不可靠传输
6. tcp-面向字节流 udp-面向报文

## 16. https 的传输过程

HTTP + 加密 + 认证 + 完整性保护 = HTTPS

1. 在服务器端存在一个公钥及私钥
2. 客户端从服务器取得这个公钥
3. 客户端产生一个随机的密钥
4. 客户端通过公钥对密钥加密（非对称加密）
5. 客户端发送到服务器端
6. 服务器端接受这个密钥并且以后的服务器端和客户端的数据全部通过这个密钥加密

## 17. HTTP 连接请求与线程

HTTP 连接是复杂，有状态的对象，所以它必须被妥善管理。一个 HTTP 连接请求在同一时间只能被一个线程访问。

HttpClient 的使用一个叫做的 Http 连接管理器的特殊实体类来管理的 Http 连接.Http 连接管理器在新建的 HTTP 连接时，作为工厂类;管理持久的 http 连接的生命周期;同步持久连接（确保线程安全，即一个 HTTP 连接同一时间只能被一个线程访问）。

如果一个的 Http 连接被释放或者被它的消费者明确表示要关闭，那么底层的连接就会和它的代理进行分离，并且该连接会被交还给连接管理器。这是，即使服务消费者仍然持有代理的引用，它也不能再执行 I / O 操作，或者更改的 Http 连接的状态。

## 18. 浏览器允许的并发请求资源数

浏览器的并发请求数目限制是针对同一域名的（例如向 www.baidu.com 发送请求）。即一时间针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞。

**浏览器的并发请求数目限制是针对同一域名的（例如向 www.baidu.com 发送请求）。即一时间针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞。**

这个问题实际上涉及非常多的考虑和因此而发生的优化技术：  
首先，是基于端口数量和线程切换开销的考虑，浏览器不可能无限量的并发请求，因此衍生出来了并发限制和 HTTP/1.1 的 Keep alive。 所以，IE6/7 在 HTTP/1.1 下的并发才 2，但 HTTP/1.0 却是 4。 而随着技术的发展，负载均衡和各类 NoSQL 的大量应用，基本已经足以应对 C10K 的问题。 但却并不是每个网站都懂得利用 domain hash 也就是多域名来加速访问。因此，新的浏览器加大了并发数的限制，但却仍控制在 8 以内。  
后端的保护

## 19. 浏览器的机制你了解多少

1. **解析 HTML**  
   在这一步浏览器执行了所有的加载解析逻辑，在解析 HTML 的过程中发出了页面渲染所需的各种外部资源请求。
2. **计算样式**  
   浏览器将识别并加载所有的 CSS 样式信息与 DOM 树合并，最终生成页面 render 树（:after :before 这样的伪元素会在这个环节被构建到 DOM 树中）。
3. **计算图层布局**  
   页面中所有元素的相对位置信息，大小等信息均在这一步得到计算。
4. **绘制图层**  
   在这一步中浏览器会根据我们的 DOM 代码结果，把每一个页面图层转换为像素，并对所有的媒体文件进行解码。
5. **整合图层，得到页面**  
   最后一步浏览器会合并合各个图层，将数据由 CPU 输出给 GPU 最终绘制在屏幕上。（复杂的视图层会给这个阶段的 GPU 计算带来一些压力，在实际应用中为了优化动画性能，我们有时会手动区分不同的图层）。

## 20. 浏览器内核

浏览器内核，即我们的`渲染进程`，有名 Renderer 进程，我们页面的渲染，js 的执行，事件的循环都在这一进程内进行，也就是说，该`进程下面拥有着多个线程`，靠着这些现成共同完成渲染任务。那么这些线程是什么呢，如下：

1. **图形用户界面 GUI 渲染线程**
   - 负责渲染浏览器界面，包括解析 HTML、CSS、构建 DOM 树、Render 树、布局与绘制等
   - 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行
2. **JS 引擎线程**
   - JS 内核，也称 JS 引擎，负责处理执行 javascript 脚本
   - 等待任务队列的任务的到来，然后加以处理，浏览器无论什么时候都只有一个 JS 引擎在运行 JS 程序
3. **事件触发线程**
   - 听起来像 JS 的执行，但是其实归属于浏览器，而不是 JS 引擎，用来控制时间循环（可以理解，JS 引擎自己都忙不过来，需要浏览器另开线程协助）
   - 当 JS 引擎执行代码块如 setTimeout 时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX 异步请求等），会将对应任务添加到事件线程中
   - 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理
   - 注意：由于 JS 的单线程关系，所以这些待处理队列中的事件都得排队等待 JS 引擎处理（当 JS 引擎空闲时才会去执行）
4. **定时触发器线程**
   - setInterval 与 setTimeout 所在线程
   - 定时计时器并不是由 JS 引擎计时的，因为如果 JS 引擎是单线程的，如果 JS 引擎处于堵塞状态，那会影响到计时的准确
   - 当计时完成被触发，事件会被添加到事件队列，等待 JS 引擎空闲了执行
   - 注意：W3C 的 HTML 标准中规定，setTimeout 中低与 4ms 的时间间隔算为 4ms
5. **异步 HTTP 请求线程**
   - 在 XMLHttpRequest 在连接后新启动的一个线程
   - 线程如果检测到请求的状态变更，如果设置有回调函数，该线程会把回调函数添加到事件队列，同理，等待 JS 引擎空闲了执行

浏览器内核，放图加强记忆：

<div align="center"><img :src="$withBase('/images/prepare/new/2020061901.jpg')" alt="images/prepare/new/2020061901.jpg"></div>

**浏览器内核拿到响应报文之后，渲染大概分为以下步骤**

1. 解析 html 生产 DOM 树。
2. 解析 CSS 规则。
3. 根据 DOM Tree 和 CSS Tree 生成 Render Tree。
4. 根据 Render 树进行 layout，负责各个元素节点的尺寸、位置计算。
5. 绘制 Render 树(painting)，绘制页面像素信息。
6. 浏览器会将各层的信息发送给 GPU，GPU 会将各层合成（composite），显示在屏幕上。

## 21. 浏览器内核中线程之间的关系

1. GUI 渲染线程与 JS 引擎线程互斥
2. JS 引擎线程与事件触发线程、定时触发器线程、异步 HTTP 请求线程  
   事件触发线程、定时触发器线程、异步 HTTP 请求线程三个线程有一个共同点，那就是使用回调函数的形式，当满足了特定的条件，这些回调函数会被执行。这些回调函数被浏览器内核理解成事件，在浏览器内核中拥有一个事件队列，这三个线程当满足了内部特定的条件，会将这些回调函数添加到事件队列中，等待 JS 引擎空闲执行。例如异步 HTTP 请求线程，线程如果检测到请求的状态变更，如果设置有回调函数，回调函数会被添加事件队列中，等待 JS 引擎空闲了执行。  
   但是，JS 引擎对事件队列（宏任务）与 JS 引擎内的任务（微任务）执行存在着先后循序，当每执行完一个事件队列的时间，JS 引擎会检测内部是否有未执行的任务，如果有，将会优先执行（微任务）。
3. WebWorker
   - Web Workers 使得一个 Web 应用程序可以在与主执行线程分离的后台线程中运行一个脚本操作。这样做的好处是可以在一个单独的线程中执行费时的处理任务，从而允许主（通常是 UI）线程运行而不被阻塞/放慢。
   - WebWorker 可以向浏览器申请一个子线程，该子线程服务于主线程，完全受主线程控制。
   - JS 引擎线程与 worker 线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）
   - 所以，如果需要进行一些高耗时的计算时，可以单独开启一个 WebWorker 线程，这样不管这个 WebWorker 子线程怎么密集计算、怎么阻塞，都不会影响 JS 引擎主线程，只需要等计算结束，将结果通过 postMessage 传输给主线程就可以了。
4. SharedWorker  
   另外，还有个东西叫 SharedWorker，与 WebWorker 在概念上所不同。
   - WebWorker 只属于某一个页面，不会和其他标签页的 Renderer 进程共享，WebWorker 是属于 Renderer 进程创建的进程。
   - SharedWorker 是由浏览器单独创建的进程来运行的 JS 程序，它被所有的 Renderer 进程所共享，在浏览器中，最多只能存在一个 SharedWorker 进程。

## 22. 介绍下 HTTPS 中间人攻击

https 协议由 http + ssl 协议构成，具体的链接过程可参考 SSL 或 TLS 握手的概述

中间人攻击过程如下：

1. 服务器向客户端发送公钥。
2. 攻击者截获公钥，保留在自己手上。
3. 然后攻击者自己生成一个【伪造的】公钥，发给客户端。
4. 客户端收到伪造的公钥后，生成加密 hash 值发给服务器。
5. 攻击者获得加密 hash 值，用自己的私钥解密获得真秘钥。
6. 同时生成假的加密 hash 值，发给服务器。
7. 服务器用私钥解密获得假秘钥。
8. 服务器用加秘钥加密传输信息

防范方法：

- 服务端在发送浏览器的公钥中加入 CA 证书，浏览器可以验证 CA 证书的有效性

## 23. 跨域时如何处理 cookie

服务端可以根据实际需求修改下面设置，以 Java 代码为做示例：

```js {13}
//允许跨域的域名，*号为允许所有,存在被 DDoS攻击的可能。
getResponse().setHeader("Access-Control-Allow-Origin", "*");

//表明服务器支持的所有头信息字段
getResponse().setHeader(
  "Access-Control-Allow-Headers",
  "Origin, No-Cache, X-Requested-With, If-Modified-Since, Pragma,Last-Modified, Cache-Control, Expires, Content-Type, X-E4M-With,userId,token"
);

/** 目前测试来看为了兼容所有请求方式，上面2个必须设 **/

//如果需要把Cookie发到服务端，需要指定Access-Control-Allow-Credentials字段为true;
getResponse().setHeader("Access-Control-Allow-Credentials", "true");

// 首部字段 Access-Control-Allow-Methods 表明服务器允许客户端使用 POST, GET 和 OPTIONS 方法发起请求。
//该字段与 HTTP/1.1 Allow: response header 类似，但仅限于在需要访问控制的场景中使用。
getResponse().setHeader(
  "Access-Control-Allow-Methods",
  "POST, GET, OPTIONS, DELETE"
);

//表明该响应的有效时间为 86400 秒，也就是 24 小时。在有效时间内，浏览器无须为同一请求再次发起预检请求。
//请注意，浏览器自身维护了一个最大有效时间，如果该首部字段的值超过了最大有效时间，将不会生效。
getResponse().setHeader("Access-Control-Max-Age", "86400");

// IE8 引入XDomainRequest跨站数据获取功能,也就是说为了兼容IE
getResponse().setHeader("XDomainRequestAllowed", "1");
```

**跨域请求携带 Cookie**

服务端可以根据实际需求修改下面设置，以 Java 代码为做示例：

```js {2}
//如果需要把Cookie发到服务端，需要指定Access-Control-Allow-Credentials字段为true;
response.setHeader("Access-Control-Allow-Credentials", "true");

//允许跨域的域名，*号为允许所有,存在被 DDoS攻击的可能。
response.setHeader("Access-Control-Allow-Origin", request.getHeader("Origin"));

//表明服务器支持的头信息字段
response.setHeader("Access-Control-Allow-Headers", "content-type");
```

前端根据实际情况修改发起请求的 ajax，示例：

```js {6,7,8,9}
$.ajax({
    type: "POST",
    url: "实际的请求地址",
    data: {参数：参数值},
    dataType: "json",
    crossDomain:true, //设置跨域为true
    xhrFields: {
      withCredentials: true //默认情况下，标准的跨域请求是不会发送cookie的
    },
    success: function(data){ alert("请求成功");
    }
});
```

**Add**
如果要实现 cookie 的共享，也有两种方案

1. 前端的请求用 jsonp 的形式

2. 前端加上配置：

   ```js
   xhrFields: {
      withCredentials: true 
   },
   ```

   服务端加上配置：`header('Access-Control-Allow-Credentials: true')`;

3. 设置 Nginx 代理服务器，将两个服务器域名统一到一个反向代理服务器。

## 24. 垃圾回收机制

js 的 垃圾回收机制，常用的有两种方法：标记清除，引用计数；

- **标记清除**：当变量进入环境时标记为“进入环境”，当变量离开环境时标记为“离开环境”；然后垃圾收集器会定时去清除，销毁被标记为离开环境的变量，释放其内存；
- **引用计数**：跟踪记录每一个引用的值被引用的次数。即变量每被引用一次，引用计数加 1，相反当包含这个值的 引用变量又取得了另外一个值（另外一个值赋给了引用这个值的变量），引用计数减 1；当引用计数变为 0 时，则说明没有值引用这个值了，此时（你已经猜到了）这个变量就可以被垃圾回收机制回收了，（因为没有在被引用了）；一个对象不被其他对象引用时会被回收

## 25. 开发过程中遇到的内存泄露情况

### 定义

内存泄露是指一块被分配的内存既不能使用，又不能回收，直到浏览器进程结束。C#和 Java 等语言采用了自动垃圾回收方法管理内存，几乎不会发生内存泄露。我们知道，浏览器中也是采用自动垃圾回收方法管理内存，但由于浏览器垃圾回收方法有 bug，会产生内存泄露。

由于每次的垃圾回收开销都相对较大，并且由于机制的一些不完善的地方，可能会导致内存泄露。我们可以利用一些方法减少垃圾回收，并且尽量避免循环引用的问题。

例如，在对象结束使用后 ，令 obj = null。这样利于解除循环引用，使得无用变量及时被回收。

再如，js 中开辟空间的操作有 `new()`, `[ ]`, `{ }`, `function (){..}`。在创建新对象的时候要尽量考虑增大对象的复用性。

### 内存泄露的几种情况:

1. 意外的全局变量引起的内存泄漏  
   原因：全局变量，不会被回收。  
   解决：使用严格模式避免。
2. 闭包引起的内存泄漏  
   原因：闭包可以维持函数内局部变量，使其得不到释放。  
   解决：将事件处理函数定义在外部，解除闭包,或者在定义事件处理函数的外部函数中，删除对 dom 的引用。
3. 没有清理的 DOM 元素引用  
   原因：虽然别的地方删除了，但是对象中还存在对 dom 的引用  
   解决：手动删除。
4. 被遗忘的定时器或者回调  
   原因：定时器中有 dom 的引用，即使 dom 删除了，但是定时器还在，所以内存中还是有这个 dom。  
   解决：手动删除定时器和 dom。
5. 子元素存在引用引起的内存泄漏  
   原因：div 中的 ul li 得到这个 div，会间接引用某个得到的 li，那么此时因为 div 间接引用 li，即使 li 被清空，也还是在内存中，并且只要 li 不被删除，他的父元素都不会被删除。  
   解决：手动删除清空

## 26. js 事件轮询、微任务和宏任务

JavaScript 是单线程语言，也就是说同一个事件只能做一件事。JavaScript 的单线程，与它的用途有关，作为浏览器脚本语言，JavaScript 的主要用途是与用户交互，以及操作 DOM。这决定了它只能是单线程，否则会带来很多复杂的同步问题。为了利用多核 CPU 的计算能力，虽然 HTML5 提出了 Web Worker，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM 和 BOM。所以，依然没有改变 JavaScript 是单线程的本质。

为了解决单线程导致的线程等待资源，cpu 空闲，而其他任务一直等待的问题。将所有的任务分为两种，`一种是同步任务`，`一种是异步任务`。

- **同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行下一个任务。**
- **异步任务指的是，不进入主线程，而进入“任务队列”的任务，自由“任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。**

1. **微任务**包括 `process.nextTick` ，`promise` ，`Object.observe` ，`MutationObserver`
2. **宏任务**包括 `script` ， `setTimeout` ，`setInterval` ，`setImmediate` ，`I/O` ，`UI rendering`

主任务和任务队列示意图：

<div align="center"><img :src="$withBase('/images/prepare/require/01041.png')" alt="images/prepare/require/01041.png"></div>

**执行过程：**

1. 所有的同步任务都在主线程上指向，形成一个执行栈
2. 主线程之外，还存在一个“任务队列”。只要异步任务有了运行结果，就在“任务队列”之中放置一个事件。
3. 一旦“执行栈”中的所有同步任务执行完毕，系统就会读取“任务队列”，将可执行的任务放在主线程执行。任务队列是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。
4. 主线程不短重复上面的第三步。

只要主线程空了，就会去读取“任务队列”。  
Event Loop（事件轮询）  
主线程从“任务队列”中读取事件，这个过程是循环不断的，所以整个过程的这种运行机制又称为 Event Loop（事件循环）

- 执行机制：
  1. 执行一个宏任务（栈中没有就从事件队列中获取）
  2. 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中
  3. 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
  4. 当前宏任务执行完毕，开始检查渲染，然后 GUI 线程接管渲染
  5. 渲染完毕后，JS 引擎线程继续，开始下一个宏任务（从宏任务队列中获取）

* JavaScript 是单线程语言，决定于它的设计最初是用来处理浏览器网页的交互。浏览器负责解释和执行 JavaScript 的线程只有一个（所有说是单线程），即 JS 引擎线程，但是浏览器同样提供其他线程，如：事件触发线程、定时器触发线程等。

* 异步一般是指：

  - 网络请求
  - 计时器
  - DOM 事件监听

* 事件循环机制：
  - JS 引擎线程会维护一个执行栈，同步代码会依次加入到执行栈中依次执行并出栈。
  - JS 引擎线程遇到异步函数，会将异步函数交给相应的 Webapi，而继续执行后面的任务。
  - Webapi 会在条件满足的时候，将异步对应的回调加入到消息队列中，等待执行。
  - 执行栈为空时，JS 引擎线程会去取消息队列中的回调函数（如果有的话），并加入到执行栈中执行。
  - 完成后出栈，执行栈再次为空，重复上面的操作，这就是事件循环(event loop)机制。

下面代码可以帮助理解上面的内容：

```js
console.log("1");
setTimeout(function() {
  console.log("2");
  process.nextTick(function() {
    console.log("3");
  });
  new Promise(function(resolve) {
    console.log("4");
    resolve();
  }).then(function() {
    console.log("5");
  });
});
process.nextTick(function() {
  console.log("6");
});
new Promise(function(resolve) {
  console.log("7");
  resolve();
}).then(function() {
  console.log("8");
});

setTimeout(function() {
  console.log("9");
  process.nextTick(function() {
    console.log("10");
  });
  new Promise(function(resolve) {
    console.log("11");
    resolve();
  }).then(function() {
    console.log("12");
  });
});
```

js 代码都是从上到下，一行一行指向，首先遇到第一行 console.log(‘1’)；执行输出 1，然后第二行`setTimeout异步任务`，放入任务队列。下面遇到`process.nextTick是微任务`放到本轮循环的结尾，之后遇到`new Promise`直接指向输出 7，`then`被放到本轮循环的结尾，接着执行又遇到的`setTimeout`放到任务队列，本轮代码执行完，开始依次执行本轮结尾的代码，输出 6,8。然后主线程的任务执行完毕，无任务队列中取出一个`setTimeout`放入主线程开始执行，输出 2，然后遇到`process.nextTick`，放到本轮循环的结尾，执行`new Promise`输出 4,`then`放入本轮循环结尾，主线程代码执行完，开始执行本轮结尾输出 3,5。然后再去任务队列中取第二个`setTimeout`执行输出 9,11,10,12。

所以输出的顺序为 1，7，6，8，2，4，3，5，9，11，10，12。

因为 settimeout 是宏任务，虽然先执行的他，但是他被放到了宏任务的 eventqueue 里面，然后代码继续往下检查看有没有微任务，检测到 Promise 的 then 函数把他放入了微任务序列。等到主线进程的所有代码执行结束后。先从微任务 queue 里拿回掉函数，然后微任务 queue 空了后再从宏任务的 queue 拿函数。

## 27. 微信网页版登录机制

用 google 浏览器打开网页版微信：https://wx.qq.com/，F12打开开发者工具，选择Network，F5刷新页面，可以看到此网页一直有一个请求处于等待相应状态

请求参数如下：

<div style="word-break: break-all">https://login.wx.qq.com/cgi-bin/mmwebwx-bin/login?loginicon=true&<span style="color: red">uuid=gcWrz8np0Q==</span>&tip=0&r=-1942477294&_=1513770915130</div>

该请求会一直处于等待相应状态，除非等到 25s 左右自动重新请求，或二维码被扫描，二维码被扫描的情况下，页面会加载出用户头像，并等待用户在手机上进行确认登录，确认后就能加载出微信主界面

1. 打开网页版微信，会向微信服务器发送请求得到一个 uuid，用户生成登录二维码
2. 页面用此 uuid 作为参数发送请求，查看该 uuid 被扫描的情况，如果已经被扫描，则返回扫描者的信息，如果没有被扫描，等待一段时间后，继续查看，直到请求超时或找到扫描者信息
3. 用户用手机扫描二维码时，就是向服务器发送请求，用扫描到的二维码 uuid 作为 key，生成扫描记录和授权记录，方便网页版使用该 uuid 查找扫描记录

问题总结
实现的关键在于一个一直处于等待回应状态的请求(长轮询)，该请求保证只要二维码被扫描，就能实时的获取到用户信息

## 28. unicode utf8 utf16 有什么区别

- Unicode 是一个巨大的字符集，给世界上所有的字符定义了一个唯一编码。其仅仅规定了每个符号的二进制代码，没有制定细化的存储规则。UTF-8、UTF-16、UTF-32 才是 Unicode 的存储格式定义。
- Unicode 是「字符集」
- UTF-8 是「编码规则」

## 29. 缓存以键值形式存在浏览器，键是什么，值是什么

键值对存储通常都有如下接口：

Get( key ): 获取之前存储于某标示符“key”之下的一些数据，或者“key”下没有数据时报错。

Set( key, value ): 将“value”存储到存储空间中某标示符“key”下，使得我们可以通过调用相同的“key”来访问它。如果“key”下已经有了一些数据，旧的数据将被替换。

Delete( key ): 删除存储在“key”下的数据。

大部分低层实现都是使用哈希表或者某种自平衡树（例如 B-树或者红黑树）。有时候数据太大而不装不进内存，或者必须维持数据谨防系统因为未知原因而崩溃。在这些情况下，就必须使用到文件系统。

## 30. 讲解一下 https 对称加密和非对称加密

**对称加密**：  
发送方和接收方需要持有同一把密钥，发送消息和接收消息均使用该密钥。相对于非对称加密，对称加密具有更高的加解密速度，但双方都需要事先知道密钥，密钥在传输过程中可能会被窃取，因此安全性没有非对称加密高。

**非对称加密**：  
接收方在发送消息前需要事先生成公钥和私钥，然后将公钥发送给发送方。发送方收到公钥后，将待发送数据用公钥加密，发送给接收方。接收方收到数据后，用私钥解密。  
在这个过程中，公钥负责加密，私钥负责解密，数据在传输过程中即使被截获，攻击者由于没有私钥，因此也无法破解。  
非对称加密算法的加解密速度低于对称加密算法，但是安全性更高。

几个名词要理清

- RSA：非对称加密
- AES：对称加密 生成一个随机字符串 key 只有客户端和服务端有 他们两个通过这个 key 对数据加密和传输跟解密 这一个统称对称加密
- CA：权威认证机构 服务器在建站的时候 去 CA 认证机构认证 得到对应的数字签名 相当于身份证号 客户端每次安装浏览器的时候 都会下载最新的 CA 列表 这个列表有对应的数字签名和服务器 IP 一一对应的列表 这就是为什么我们自己搭建的 localhost 没法发 https 的原因 因为没法进行 CA 认证
- 数字证书：包含了数字签名跟 RSA 公钥
- 数字签名：保证数字证书一定是服务器传给客户端的 相当于服务器的身份证 ID
- 对称密钥： 对数据进行加密的 key
- 非对称密钥： （k1， k2） k1 加密的数据 只有 k2 能解开 k1 位非对称公钥 k2 为非对称私钥
- 非对称公钥：RSA 公钥 k1 加密的数据 只有 k2 能解开
- 非对称私钥：RSA 私钥 k1 加密的数据 只有 k2 能解开

## 31. 如何优化网页上需要展示的超大图片，从请求和性能来解释

1. 图片格式的选择
2. 图片压缩
3. 图片懒加载

## 32. 实现 Adblock 的策略

1. 对 URL 请求的拦截，这种 URL 广告一般是网页中 div 元素嵌入了一个 iframe/image 元素，然后加载一个广告链接或者 GIF 图片。
2. 对于页面 DOM 嵌入广告内容的处理，这种一般是通过 CSS3 Selector 定位到这些 DOM 元素，然后设置其 display 等于 none !important
3. 模拟点击，对于有些可以叉掉的广告，而又没有 cookie，每次访问都会出现，可以写脚本让浏览器帮你进行网页模拟点击，直接帮点击那个叉，但碰到网速不好，特别是移动端很可能出现广告出现一下就消失的效果，用户体验可能不是很好。

## 33. dom0、dom2、dom3 事件

### 0 级 DOM 分为 2 个：

1. 一是在标签内写 `onclick` 事件
   ```html
   <input
     id="myButton"
     type="button"
     value="Press Me"
     onclick="alert('thanks');"
   />
   ```
2. 二是在 JS 写 `onlicke=function(){}`函数
   ```js
   document.getElementById("myButton").onclick = function() {
     alert("thanks");
   };
   ```

**优点**

- 不需要操作 DOM 来完成事件的绑定
  **缺点**
- HTML 和 JS 耦合太强
- 一个元素无法同时绑定多个处理函数
- DOM0 事件解绑的方式：给事件处理属性赋值 null 来解绑事件如： btn.onclick = null

### 2 级 DOM

只有一个：监听方法，原生有两个方法用来添加和移除事件处理程序：`addEventListener()`和`removeEventListener()`。

它们都有三个参数：

- 第一个参数是事件名（如 click）；
- 第二个参数是事件处理程序函数；
- 第三个参数如果是 true 则表示在捕获阶段调用，为 false 表示在冒泡阶段调用。

`addEventListener()`:可以为元素添加多个事件处理程序，触发时会按照添加顺序依次调用。
`removeEventListener()`:不能移除匿名添加的函数。

只有 2 级 DOM 包含 3 个事件：`事件捕获阶段`、`处于目标阶段`和`事件冒泡阶段`

```html
<span>
  <a></a>
</span>
```

点击 a 后 capturing(捕捉)阶段事件传播会从 document -> span -> a，然后发生在 a，最后 bubbling(冒泡)阶段事件传播会从 a -> span -> document 。

区别：

- 如果定义了两个 dom0 级事件，dom0 级事件会覆盖
- dom2 不会覆盖，会依次执行
- dom0 和 dom2 可以共存，不互相覆盖，但是 dom0 之间依然会覆盖

### DOM3

DOM3 级事件是在 DOM2 级事件的基础上添加很多事件类型。

- UI 事件，当用户与页面上的元素交互时触发，如：load、scroll
- 焦点事件，当元素获得或失去焦点时触发，如：blur、focus
- 鼠标事件，当用户通过鼠标在页面执行操作时触发如：dbclick、mouseup
- 滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel
- 文本事件，当在文档中输入文本时触发，如：textInput
- 键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress
- 合成事件，当为 IME（输入法编辑器）输入字符时触发，如：compositionstart
- 变动事件，当底层 DOM 结构发生变化时触发，如：DOMsubtreeModified
- 同时 DOM3 级事件也允许使用者自定义一些事件。

## 34. 如何刷新浏览器的应用缓存？

浏览器缓存可分为`强缓存`和`协商缓存`。

- **强缓存**指的是设置了 expires 或者 cache-control:max-age 的请求，此类缓存在设定的过期时间之前刷新不会再次向浏览器发起请求，直接由客户端决定使用缓存进行页面展示。
- **协商缓存**指的是未设置强缓存对应字段的缓存，浏览器会向服务器发送请求，并带 IF-Modified-Since 和 IF-None-Match 字段，服务器对应的返回字段为 Last-Modified 或 Etag，如果在 etag 未更改 或 last-modified 的时间早于 IF-Modified-Since 则服务器不返回文件，使用浏览器本地缓存。

回到问题，如何刷新应用缓存。<br />
当你直接点击浏览器的刷新按钮或者 F5 刷新时，浏览器会忽略强缓存，必定向服务器发起请求，但是如果服务器返回 304 则会继续使用本地缓存。<br />
当点击 Ctrl+F5 浏览器会忽略一切缓存（cache-control:no-cache），向服务器发起请求，并且一定会使用服务器的返回来渲染页面。

## 35. 浏览器缓存

### 强缓存

强缓存不向 http 发送请求，返回状态码 304.

检查强缓存有两个字段: http1.0 使用 expires，代表过期时间，但是服务器时间和客户端时间可能不一致。为了弥补这个缺点，http1.1 使用 `cache-control` 的 `max-age` 字段，`cache-control` 有多个指令

- public 允许客户端和代理服务器缓存
- private 允许客户端缓存
- no-store 不使用缓存
- no-cache 使用协商缓存 两个字段都存在，cache-control 优先级高于 expires

### 协商缓存

协商缓存向 http 发送请求，返回状态码 200

检查协商缓存有两个字段: http1.0 使用 `last-modified`，即最后修改时间。

1. 在浏览器向服务器发送请求后，服务器会在响应头上加上这个字段
2. 浏览器接收后，如果再次请求，会在请求头上携带 `If-Modified-Since`
3. 服务器拿到 `If-Modified-Since` 字段后，会和服务器中该资源的最后修改时间对比,如果请求头中这个值小于最后修改时间，更新资源；否则返回 304，告诉浏览器直接使用缓存

http1.1 使用 etag，etag 是服务器根据当前文件内容，给文件生成的唯一标识，只要内容改变，这个值就会变。`etag 优先级高于 last-modifed`

缓存位置，按优先级从高到低分别是:

- service worker
- memory cache
- disk cache
- push cache

## 36. CDN 缓存

### CDN 缓存介绍

当服务接入了 CDN 之后，浏览器本地缓存的资源过期之后，浏览器不是直接向源服务器请求资源，而是转而向 CDN 边缘节点请求资源。CDN 边缘节点中将用户的数据缓存起来，如果 CDN 中的缓存也过期了，CDN 边缘节点会向源服务器发出回源请求，从而来获取最新资源。

### CDN 缓存策略

CDN 节点缓存策略一般都会遵循 HTTP 标准协议，又拍云在没有匹配到自定义缓存规则且源服务器也没有返回任何有效缓存头的情况下，默认配置策略如下：

1. 针对静态资源，所有正常状态码（大于等于 200 小于 400）均缓存 8 天。特别地，301 响应缓存 2 小时，302 响应缓存 20 分钟；
2. 针对动态资源，程序会自动识别，则不进行缓存；
3. 对于其他大于等于 400 的不正常响应，则不进行缓存；

### CDN 缓存的不足

CDN 缓存不仅减少了用户的访问延时，相应的也减少了源服务器的负载，但这里需要注意，当源服务器资源更新后，如果 CDN 节点上缓存数据还未过期，用户访问到的依旧是过期的缓存资源，这会导致用户最终访问出现偏差。因此，开发者需要手动刷新相关资源，使 CDN 缓存保持为最新的状态。

## 37. 本地存储的生命周期是什么？

- `cookie`: `expire` 和 `max-age` 都能控制数据的存储时间。`expire` 是一个绝对的过期时间，`max-age` 是文档被访问之后的存活时间（是相对时间）。默认是 `session`。
- `sessionStorage`: 当会话被关闭后（浏览器、标签页被关闭），就会被清除。与 localStorage 用法一样。
- `localStorage`: 除非被主动清除，不然永久储存在浏览器中。
- `IndexedDB`: 没有过期时间，除非主动清除。

## 38. 如何防止 cookie 被盗用？

1. 使用 https
2. 加 IP 判断
3. 缩短有效时间
4. 使用 Token 验证
5. 为 cookie 设置 HttpOnly
6. cookie 带上用户 ip 加密
7. 使用 Referer 验证
8. 禁止网页内嵌
9. 每次请求需要输入图形验证码

## 39. 举例说明什么是 decodeURI()和 encodeURI()是什么？

- encodeURI 编码
- decodeURI 解码

1. `encodeURI()`：将 URI 中的每个字符编码为 1-4 个格式为 `%xx` 的转义序列（xx 为十六进制数），但不包括 ASCII 数字、字母、URL 分隔符（`/`、`?`、`,`、`&`、...）、以及其他部分 ASCII 字符。具体见 [MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURI)。
   - Example: `encodeURI('http://example.com/端点?键=值')` => `'http://example.com/%E7%AB%AF%E7%82%B9?%E9%94%AE=%E5%80%BC'`
2. `decodeURI()`：将已经编码的 URI 中的转义序列解码为它们表示的字符，但除了 `encodeURI()` 不会编码的字符。
3. `encodeURIComponent()`：用于编码 URI 中的组成部分。它除了转义 `encodeURI()` 指定的字符，还会转义 URL 分隔符（`/`、`?`、`,`、`&`、...）
   - <span style="word-break: break-all">Example: `encodeURIComponent('测试/测试?测试=测试')` => `'%E6%B5%8B%E8%AF%95%2F%E6%B5%8B%E8%AF%95%3F%E6%B5%8B%E8%AF%95%3D%E6%B5%8B%E8%AF%95'`</span>
4. `decodeURIComponent()`：将已经编码的 URI 组成部分中的转义序列解码为它们表示的字符，但除了 `encodeURIComponent()` 不会编码的字符。

## 40. 请说说 escape、encodeURI、decodeURI、encodeURIComponent 和 decodeURIComponent 的区别？

1. `escape()` 将会把字符串中除了字母、数字以及一部分符号以外的所有转义为 %XX 格式的转义序列，可以通过 `unescape()` 转回。它们是已经被弃用的方法，不建议使用。
2. `encodeURI()`：将 URI 中的每个字符编码为 1-4 个格式为 `%xx` 的转义序列（xx 为十六进制数），但不包括 ASCII 数字、字母、URL 分隔符（`/`、`?`、`,`、`&`、...）、以及其他部分 ASCII 字符。具体见 [MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURI)。
   - Example: `encodeURI('http://example.com/端点?键=值')` => `'http://example.com/%E7%AB%AF%E7%82%B9?%E9%94%AE=%E5%80%BC'`
3. `decodeURI()`：将已经编码的 URI 中的转义序列解码为它们表示的字符，但除了 `encodeURI()` 不会编码的字符。
4. `encodeURIComponent()`：用于编码 URI 中的组成部分。它除了转义 `encodeURI()` 指定的字符，还会转义 URL 分隔符（`/`、`?`、`,`、`&`、...）
   - <span style="word-break: break-all">Example: `encodeURIComponent('测试/测试?测试=测试')` => `'%E6%B5%8B%E8%AF%95%2F%E6%B5%8B%E8%AF%95%3F%E6%B5%8B%E8%AF%95%3D%E6%B5%8B%E8%AF%95'`</span>
5. `decodeURIComponent()`：将已经编码的 URI 组成部分中的转义序列解码为它们表示的字符，但除了 `encodeURIComponent()` 不会编码的字符。

## 41. 如何实现文件拖动上传？

利用 HTML5 的 `drag & drop` API 来实现。需要注意的是，必须要设置 `dragover` 事件，不然不会触发 `drop` 事件。

```html
<input type="file" />

<div id="dragUpload" class="drag-upload">
  Drag File to Upload
</div>
```

```css
.drag-upload {
  width: 300px;
  font-size: 20px;
  text-align: center;
  line-height: 80px;
  border-radius: 5px;
  border: 1px dashed lightblue;
  cursor: grab;
}
```

```js
const dragUpload = document.getElementById("dragUpload");
dragUpload.addEventListener("dragover", e => {
  e.preventDefault();
  // 必须要有 dragover 同时需要 preventDefault，否则不会触发 drop 事件
});

dragUpload.addEventListener("drop", e => {
  e.preventDefault();
  // 获取到拖拽进来的文件
  const { dataTransfer: { files = {} } = {} } = e || {};
  // console.log(e.dataTransfer.files);
  console.log("dropped: ", files);
  // 获取到文件后就可以做上传的操作了
});
```

## 42. 通过 userAgent 是否包含 MicroMessenger 来判断是否在微信内置浏览器打开网页

```js
function isWeiXin() {
  var ua = window.navigator.userAgent.toLowerCase();
  // 不加window部分Android机会显示不了提示图，即判断不了是否是微信
  if (ua.match(/MicroMessenger/i) == "micromessenger") {
    return true;
  } else {
    return false;
  }
}
```

## 43. Ajax 请求中 get 和 post 方式有什么区别呢？分别在哪些场景下使用？

**get：**

1. GET 请求会将参数跟在 URL 后进行传递，也就是会在 url 中显示
2. GET 请求有数据长度限制，一般在 2000 个字符，而 POST 没有。
3. GET 方式请求的数据会被浏览器缓存起来，POST 没有
4. GET 在某些情况下会有安全问题，POST 没有。
5. 在客户端使用 get 请求时,服务器端使用 Request.QueryString 来获取参数
6. get 请求参数会在 url 中显示，容易被他人窃取，post 在请求体中，不会被窃取

**post：**

1. POST 请求是作为 HTTP 消息的实体内容发送给 WEB 服务器。
2. 客户端使用 post 请求时,服务器端使用 Request.Form 来获取参数。
3. post 一般用于修改服务器上的资源，对所发送的信息没有限制
4. post 比 get 更加安全
5. post 需要设置请求头

## 44. get 和 post 区别

1. 首先是语义上的区别，GET 为获取，POST 为提交
2. 其次是 GET 请求只请求服务器一次，但 POST 会请求两次，第一次是 OPTIONS 方式请求为了确定服务器是否能够接收数据，第二次才是真的 POST 请求，将数据提交到服务器；
3. 首先是语义上的区别，GET 参数有长度限制（受限于 url 长度，具体的数值取决于浏览器和服务器的限制，最长 2048 字节），而 POST 无限制。
4. 首先是语义上的区别，GET 请求的数据会附加在 url 之 ，以 " ？ "分割 url 和传输数据，多个参数用 "&"连接，而 POST 请求会把请求的数据放在 http 请求体中。
5. 首先是语义上的区别，GET 是明文传输，POST 是放在请求体中，但是开发者可以通过抓包工具看到，也相当于是明文的
6. 首先是语义上的区别，GET 请求会保存在浏览器历史记录中，还可能保存在 web 服务器的日志中
7. 从缓存角度 首先是语义上的区别，GET 请求是可以被缓存的， POST 请求是不可以被缓存的
8. GET 和 POST 本质没有区别，都是 tcp 连接

## 45. 简单请求和复杂请求的区别

**简单请求**

> 满足一下两个条件的请求。

1. 请求方法是以下三种方法之一
   - HEAD
   - GET
   - POST
2. HTTP 的头信息不超出以下几种字段:
   - Accept
   - Accept-Language
   - Content-Language
   - Content-Type：只限于三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain

**复杂请求**

> 非简单请求就是复杂请求

复杂请求在正式请求前都会有预检请求，在浏览器中都能看到有 `OPTIONS` 请求，用于向服务器请求权限信息的。
