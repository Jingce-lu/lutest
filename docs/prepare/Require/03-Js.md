# Js 手写

[[toc]]

## 1. 防抖和节流

1. 防抖

   ```js
   function debounce(fn, delay) {
     // 利用闭包保存定时器
     let timer = null;
     return function () {
       let context = this;
       let arg = arguments;
       // 在规定时间内再次触发会先清除定时器后再重设定时器
       clearTimeout(timer);
       timer = setTimeout(function () {
         fn.apply(context, arg);
       }, delay);
     };
   }

   function fn() {
     console.log('防抖');
   }
   addEventListener('scroll', debounce(fn, 1000));
   ```

2. 节流

   ```js
   function throttle(fn, delay) {
     // 利用闭包保存时间
     let prev = Date.now();
     return function () {
       let context = this;
       let arg = arguments;
       let now = Date.now();
       if (now - prev >= delay) {
         fn.apply(context, arg);
         prev = Date.now();
       }
     };
   }

   function fn() {
     console.log('节流');
   }
   addEventListener('scroll', throttle(fn, 1000));
   ```

    ```js
    function throttle(fn, interval) {
      var doing = false;

      return function () {
        if (doing) {
          return;
        }

        doing = true;
        fn.apply(this, arguments);
        setTimeout(function () {
          doing = false;
        }, interval);
      };
    }
    ```

## 2. 深拷贝

```js {10}
// 1. JOSN.stringify()/JSON.parse()
let obj = { a: 1, b: { x: 3 } };
JSON.parse(JSON.stringify(obj));

// 2. 递归拷贝
function deepClone(obj) {
  let copy = obj instanceof Array ? [] : {};
  for (let i in obj) {
    if (obj.hasOwnProperty(i)) {
      copy[i] = typeof obj[i] === 'object' ? deepClone(obj[i]) : obj[i];
    }
  }
  return copy;
}
```

## 3. 数组去重、数组乱序

1. hasOwnProperty 数组去重
   ```js {4,6}
   const unique = arr => {
     let obj = {};
     return arr.filter(item => {
       return obj.hasOwnProperty(typeof item + item)
         ? false
         : (obj[typeof item + item] = true);
     });
   };
   ```
2. 数组乱序 洗牌算法

   **实现思路**：数组从后向前遍历，然后将当前元素与前面（包括自身）随机位置的数进行交换

   ```js {4,5}
   function shuffle(arr) {
     let m = arr.length;
     while (m > 1) {
       let index = Math.floor(Math.random() * m--);
       [arr[m], arr[index]] = [arr[index], arr[m]];
     }
     return arr;
   }
   ```

   ```js {3}
   function shuffle(arr) {
     for (let i = arr.length; i > 0; i--) {
       let j = Math.floor(Math.random() * i);
       [arr[i - 1], arr[j]] = [arr[j], arr[i - 1]];
     }
     return arr;
   }
   ```

## 4. 数组扁平化

```js {3,13,16,19,23,30}
var arr = [1, [2, [3, 4]]];
function flatten(arr) {
  while (arr.some(item => Array.isArray(item))) {
    arr = [].concat(...arr);
  }

  return arr;
}

console.log(flatten(arr)); // [1, 2, 3, 4]

// 2
JSON.parse(`[${arr}]`);

// 3
arr.join().split(',').map(Number);

// 4
arr.toString().split(',').map(Number);

// 5
var list = [1, [2, [3]], 4, [5]];
JSON.parse(`[${list.toString()}]`);
JSON.parse(`[${list.join()}]`);
JSON.parse(`[${arr}]`);

// 6
const flattenDeep = arr =>
  Array.isArray(arr)
    ? arr.reduce((a, b) => [...a, ...flattenDeep(b)], [])
    : [arr];

flattenDeep([1, [[2], [3, [4]], 5]]);
```

## 5. 手写 call、apply、bind

```js {6,7,8,9,20,34,36}
Function.prototype.myCall = function (context) {
  if (typeof this !== 'function') {
    return new TypeError('not a function');
  }
  context = context || window;
  context.fn = this;
  let arg = [...arguments].slice(1);
  let result = context.fn(...arg);
  delete context.fn;
  return result;
};

Function.prototype.myAplly = function (context) {
  if (typeof this !== 'function') {
    return new TypeError('not function');
  }
  context = context || window;
  context.fn = this;
  let result;
  if (arguments[1]) {
    result = context.fn(...arguments[1]);
  } else {
    result = context.fn();
  }
  delete context.fn;
  return result;
};

Function.prototype.mybind = function (context) {
  if (typeof this !== 'function') {
    throw new TypeError('Error');
  }
  let _this = this;
  let arg = [...arguments].slice(1);
  return function F() {
    if (this instanceof F) {
      return new _this(...arg, ...arguments);
    } else {
      return _this.apply(context, arg.concat(...arguments));
    }
  };
};
```

## 6. new

```js {4,5,6}
function myNew(fun) {
  return function () {
    // 创建一个新对象且将其隐式原型指向构造函数原型
    let obj = {
      __proto__: fun.prototype, // 链接到原型
    };
    // 执行构造函数
    fun.call(obj, ...arguments);
    // 返回该对象
    return obj;
  };
}

function person(name, age) {
  this.name = name;
  this.age = age;
}
let obj = myNew(person)('chen', 18); // {name: "chen", age: 18}
```

```js {6,7}
// 手动实现一个 new 关键字的功能的函数 _new(fun, args) --> new fun(args)
function _new(fun, ...args) {
  if (typeof fun !== 'function') {
    return new Error('参数必须是一个函数');
  }
  let obj = Object.create(fun.prototype);
  let res = fun.call(obj, ...args);
  if (res !== null && (typeof res === 'object' || typeof res === 'function')) {
    return res;
  }
  return obj;
}
```

```js {3}
const createNew = (Con, ...args) => {
  const obj = {};
  Object.setPrototypeOf(obj, Con.prototype);
  let result = Con.apply(obj, args);
  return result instanceof Object ? result : obj;
};
```

## 7. 双向数据绑定

```js {4,7,11}
let obj = {};
let input = document.getElementById('input');
let span = document.getElementById('span');
Object.defineProperty(obj, 'text', {
  configurable: true,
  enumerable: true,
  get() {
    console.log('获取数据了');
    return obj.text;
  },
  set(newVal) {
    console.log('数据更新了');
    input.value = newVal;
    span.innerHTML = newVal;
  },
});
input.addEventListener('keyup', function (e) {
  obj.text = e.target.value;
});
```

## 8. curry

```js
const curry = (fn, arr = []) => (...args) =>
  (arg => (arg.length === fn.length ? fn(...arg) : curry(fn, arg)))([
    ...arr,
    ...args,
  ]);

let curryTest = curry((a, b, c, d) => a + b + c + d);
curryTest(1, 2, 3)(4); //返回10
curryTest(1, 2)(4)(3); //返回10
curryTest(1, 2)(3, 4); //返回10
```

```java
const curry = (fn, arr = []) => (...args) =>
  (arg => (
    arg.length === fn.length ? fn(...arg) : curry(fn, arg)
  ))([...arr,...args]);
```

## 9. 实现 sleep 函数

```js
function sleep(interval) {
  return new Promise(resolve => {
    setTimeout(resolve, interval);
  });
}
async function test() {
  for (let index = 0; index < 10; index++) {
    console.log(index);
    await sleep(2000);
  }
}
```

## 10. Object.is

```js
Object.defineProperty(Object, 'is', {
  value: function (x, y) {
    if (x === y) {
      // 针对+0 不等于 -0的情况
      return x !== 0 || 1 / x === 1 / y;
    }
    // 针对NaN的情况
    return x !== x && y !== y;
  },
  configurable: true,
  enumerable: false,
  writable: true,
});
```

## 11. instanceof 原理

```js
function instanceof(left, right) {
  // 获得类型的原型
  let prototype = right.prototype;
  // 获得对象的原型
  let left = left.__proto__;
  // 判断对象的类型是否等于类型的原型
  while (true) {
    if (left === null) return false;
    if (left === prototype) return true;
    left = left.__proto__;
  }
}
```

```js
// a instanceof b
function _instanceof(a, b) {
  while (a) {
    if (a.__proto__ === b.prototype) return true;
    a = a.__proto__;
  }
  return false;
}
```

## 12. reduce 实现

```js
Array.prototype.reduce = function (callback, initialValue) {
  if (typeof callback !== 'function') {
    throw new TypeError(`${callback} is not a function`);
  }
  let arr = this;
  let acc = initialValue || arr[0];
  let startIndex = initialValue ? 0 : 1;
  for (let i = startIndex; i < arr.length; i++) {
    const cur = arr[i];
    acc = callback(acc, cur, i, arr);
  }
  return acc;
};
```

```js
function reduce(arr, callback, initial) {
  let i = 0;
  let acc = initial === undefined ? arr[i++] : initial;
  for (; i < arr.length; i++) {
    acc = callback(acc, arr[i], i, arr);
  }
  return acc;
}
```

```js
Array.prototype.myRedeceRight = function (reducer, initValue) {
  for (let i = this.length - 1; i >= 0; i--) {
    initValue = reducer(initValue, this[i], i, this);
  }
  return initValue;
};

const arr = [1, 2, 3];
const res1 = arr.myRedeceRight(function (val, item) {
  return val + item;
}, 0);

console.log(res1);
```

## 13. Generator 实现

```js
// cb 也就是编译过的test函数
function generator(cb) {
  return (function () {
    var object = {
      next: 0,
      stop: function () {},
    };

    return {
      next: function () {
        var ret = cb(object);
        if (ret === undefined) {
          return {
            value: undefined,
            done: true,
          };
        }

        return {
          value: ret,
          done: false,
        };
      },
    };
  })();
}
```

## 14. 实现系统 Math.max 方法

```js
function Mymax() {
  // 添加一个方法
  this.getMax = function () {
    // 假设这个数是最大值
    var max = arguments[0];
    for (var i = 0; i < arguments.length; i++) {
      if (max < arguments[i]) {
        max = arguments[i];
      }
    }
    return max;
  };
}

// 实例对象
var my = new Mymax();
console.log(my.getMax(9, 5, 6, 32));
```

## 15. 手写 Promise

### es5 基本实现 Promise

```js
const PENDING = 1;
const FULFILLED = 2;
const REJECTED = 3;

function MyPromise(fn) {
  let self = this;
  this.resolveQueue = [];
  this.rejectQueue = [];
  this.state = PENDING;
  this.val = undefined;
  function resolve(val) {
    if (self.state === PENDING) {
      setTimeout(() => {
        self.state = FULFILLED;
        self.val = val;
        self.resolveQueue.forEach(cb => cb(val));
      });
    }
  }
  function reject(err) {
    if (self.state === PENDING) {
      setTimeout(() => {
        self.state = REJECTED;
        self.val = err;
        self.rejectQueue.forEach(cb => cb(err));
      });
    }
  }
  try {
    // 回调是异步执行 函数是同步执行
    fn(resolve, reject);
  } catch (err) {
    reject(err);
  }
}

MyPromise.prototype.then = function (onResolve, onReject) {
  let self = this;
  // 不传值的话默认是一个返回原值的函数
  onResolve = typeof onResolve === 'function' ? onResolve : v => v;
  onReject =
    typeof onReject === 'function'
      ? onReject
      : e => {
          throw e;
        };
  if (self.state === FULFILLED) {
    return new MyPromise(function (resolve, reject) {
      setTimeout(() => {
        try {
          let x = onResolve(self.val);
          if (x instanceof MyPromise) {
            x.then(resolve);
          } else {
            resolve(x);
          }
        } catch (e) {
          reject(e);
        }
      });
    });
  }

  if (self.state === REJECTED) {
    return new MyPromise(function (resolve, reject) {
      setTimeout(() => {
        try {
          let x = onReject(self.val);
          if (x instanceof MyPromise) {
            x.then(resolve);
          } else {
            resolve(x);
          }
        } catch (e) {
          reject(e);
        }
      });
    });
  }

  if (self.state === PENDING) {
    return new MyPromise(function (resolve, reject) {
      self.resolveQueue.push(val => {
        try {
          let x = onResolve(val);
          if (x instanceof MyPromise) {
            x.then(resolve);
          } else {
            resolve(x);
          }
        } catch (e) {
          reject(e);
        }
      });
      self.rejectQueue.push(val => {
        try {
          let x = onReject(val);
          if (x instanceof MyPromise) {
            x.then(resolve);
          } else {
            resolve(x);
          }
        } catch (e) {
          reject(e);
        }
      });
    });
  }
};

MyPromise.prototype.catch = function (onReject) {
  return this.then(null, onReject);
};

MyPromise.all = function (promises) {
  return new MyPromise(function (resolve, reject) {
    let cnt = 0;
    let result = [];
    for (let i = 0; i < promises.length; i++) {
      promises[i].then(
        res => {
          result[i] = res;
          if (++cnt === promises.length) resolve(result);
        },
        err => {
          reject(err);
        }
      );
    }
  });
};

MyPromise.race = function (promises) {
  return new MyPromise(function (resolve, reject) {
    for (let i = 0; i < promises.length; i++) {
      promises[i].then(resolve, reject);
    }
  });
};

MyPromise.resolve = function (val) {
  return new MyPromise(function (resolve, reject) {
    resolve(val);
  });
};

MyPromise.reject = function (err) {
  return new MyPromise(function (resolve, reject) {
    reject(err);
  });
};
```

### class 实现一个完整的 Promise

```js
// 判断变量否为function
const isFunction = variable => typeof variable === 'function';
// 定义Promise的三种状态常量
const PENDING = 'PENDING';
const FULFILLED = 'FULFILLED';
const REJECTED = 'REJECTED';

class MyPromise {
  constructor(cb) {
    if (!isFunction(cb)) {
      throw new Error('MyPromise must accept a function as a parameter');
    }
    // 添加状态
    this._status = PENDING;
    // 添加状态
    this._value = undefined;
    // 添加成功回调函数队列
    this._fulfilledQueues = [];
    // 添加失败回调函数队列
    this._rejectedQueues = [];
    // 执行cb
    try {
      cb(this._resolve.bind(this), this._reject.bind(this));
    } catch (err) {
      this._reject(err);
    }
  }
  // 添加resovle时执行的函数
  _resolve(val) {
    const run = () => {
      if (this._status !== PENDING) return;
      // 依次执行成功队列中的函数，并清空队列
      const runFulfilled = value => {
        let cb;
        while ((cb = this._fulfilledQueues.shift())) {
          cb(value);
        }
      };
      // 依次执行失败队列中的函数，并清空队列
      const runRejected = error => {
        let cb;
        while ((cb = this._rejectedQueues.shift())) {
          cb(error);
        }
      };
      /* 如果resolve的参数为Promise对象，则必须等待该Promise对象状态改变后,
        当前Promsie的状态才会改变，且状态取决于参数Promsie对象的状态
      */
      if (val instanceof MyPromise) {
        val.then(
          value => {
            this._value = value;
            this._status = FULFILLED;
            runFulfilled(value);
          },
          err => {
            this._value = err;
            this._status = REJECTED;
            runRejected(err);
          }
        );
      } else {
        this._value = val;
        this._status = FULFILLED;
        runFulfilled(val);
      }
    };
    // 为了支持同步的Promise，这里采用异步调用
    setTimeout(run, 0);
  }
  // 添加reject时执行的函数
  _reject(err) {
    if (this._status !== PENDING) return;
    // 依次执行失败队列中的函数，并清空队列
    const run = () => {
      this._status = REJECTED;
      this._value = err;
      let cb;
      while ((cb = this._rejectedQueues.shift())) {
        cb(err);
      }
    };
    // 为了支持同步的Promise，这里采用异步调用
    setTimeout(run, 0);
  }
  // 添加then方法
  then(onFulfilled, onRejected) {
    const { _value, _status } = this;
    // 返回一个新的Promise对象
    return new MyPromise((onFulfilledNext, onRejectedNext) => {
      // 封装一个成功时执行的函数
      let fulfilled = value => {
        try {
          if (!isFunction(onFulfilled)) {
            onFulfilledNext(value);
          } else {
            let res = onFulfilled(value);
            if (res instanceof MyPromise) {
              // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调
              res.then(onFulfilledNext, onRejectedNext);
            } else {
              //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数
              onFulfilledNext(res);
            }
          }
        } catch (err) {
          // 如果函数执行出错，新的Promise对象的状态为失败
          onRejectedNext(err);
        }
      };
      // 封装一个失败时执行的函数
      let rejected = error => {
        try {
          if (!isFunction(onRejected)) {
            onRejectedNext(error);
          } else {
            let res = onRejected(error);
            if (res instanceof MyPromise) {
              // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调
              res.then(onFulfilledNext, onRejectedNext);
            } else {
              //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数
              onFulfilledNext(res);
            }
          }
        } catch (err) {
          // 如果函数执行出错，新的Promise对象的状态为失败
          onRejectedNext(err);
        }
      };
      switch (_status) {
        // 当状态为pending时，将then方法回调函数加入执行队列等待执行
        case PENDING:
          this._fulfilledQueues.push(fulfilled);
          this._rejectedQueues.push(rejected);
          break;
        // 当状态已经改变时，立即执行对应的回调函数
        case FULFILLED:
          fulfilled(_value);
          break;
        case REJECTED:
          rejected(_value);
          break;
      }
    });
  }
  // 添加catch方法
  catch(onRejected) {
    return this.then(undefined, onRejected);
  }
  // 添加静态resolve方法
  static resolve(value) {
    // 如果参数是MyPromise实例，直接返回这个实例
    if (value instanceof MyPromise) return value;
    return new MyPromise(resolve => resolve(value));
  }
  // 添加静态reject方法
  static reject(value) {
    return new MyPromise((resolve, reject) => reject(value));
  }
  // 添加静态all方法
  static all(list) {
    return new MyPromise((resolve, reject) => {
      /**
       * 返回值的集合
       */
      let values = [];
      let count = 0;
      for (let [i, p] of list.entries()) {
        // 数组参数如果不是MyPromise实例，先调用MyPromise.resolve
        this.resolve(p).then(
          res => {
            values[i] = res;
            count++;
            // 所有状态都变成fulfilled时返回的MyPromise状态就变成fulfilled
            if (count === list.length) resolve(values);
          },
          err => {
            // 有一个被rejected时返回的MyPromise状态就变成rejected
            reject(err);
          }
        );
      }
    });
  }
  // 添加静态race方法
  static race(list) {
    return new MyPromise((resolve, reject) => {
      for (let p of list) {
        // 只要有一个实例率先改变状态，新的MyPromise的状态就跟着改变
        this.resolve(p).then(
          res => {
            resolve(res);
          },
          err => {
            reject(err);
          }
        );
      }
    });
  }
  finally(cb) {
    return this.then(
      value => MyPromise.resolve(cb()).then(() => value),
      reason =>
        MyPromise.resolve(cb()).then(() => {
          throw reason;
        })
    );
  }
}
```

```js
var p1 = MyPromise.resolve(3);
var p2 = 1337;
var p3 = new MyPromise((resolve, reject) => {
  setTimeout(resolve, 100, 'foo');
});
MyPromise.all([p1, p2, p3]).then(values => {
  console.log(values);
});

// [3, 1337, "foo"]
```

## 16. 实现 Promise.all

`Promise.all` 需要等到所有的 promise 的状态都变成 fulfilled 之后才 resolve, 但只要有一个 promise 失败即返回失败的结果。

`Promise.all`等待所有 Promise 执行完毕之后，按照放在 all 中的先后顺序将 resolve()返回的数据放在 Promise.all 的 resolve 中

`Promise.all()`中的 Promise 对象执行先后顺序由自己快慢控制，全部执行完毕后，按照放入 all()的先后顺序放入 Promise.all().then 的 resolve 中

```js
Promise.all = function (arr) {
  return new Promise((resolve, reject) => {
    if (!Array.isArray(arr)) {
      throw new TypeError(`argument must be a array`);
    }
    var length = arr.length;
    var resolveNum = 0;
    var resolveResult = [];
    for (let i = 0; i < length; i++) {
      arr[i]
        .then(data => {
          resolveNum++;
          resolveResult.push(data);
          if (resolveNum == length) {
            return resolve(resolveResult);
          }
        })
        .catch(data => {
          return reject(data);
        });
    }
  });
};
```

```js
function promiseAll(promises) {
  return new Promise(function (resolve, reject) {
    if (!Array.isArray(promises)) {
      return reject(new TypeError('argument must be anarray'));
    }

    var countNum = 0;
    var promiseNum = promises.length;
    var resolvedvalue = new Array(promiseNum);

    for (var i = 0; i < promiseNum; i++) {
      (function (i) {
        Promise.resolve(promises[i]).then(
          function (value) {
            countNum++;
            resolvedvalue[i] = value;

            if (countNum === promiseNum) {
              return resolve(resolvedvalue);
            }
          },
          function (reason) {
            return reject(reason);
          }
        );
      })(i);
    }
  });
}

var p1 = Promise.resolve(1),
  p2 = Promise.resolve(2),
  p3 = Promise.resolve(3);

promiseAll([p1, p2, p3]).then(function (value) {
  console.log(value);
});
```

## 17. promise.retry

`promise.retry` 的作用是执行一个函数，如果不成功最多可以尝试 times 次。传参需要三个变量，所要执行的函数，尝试的次数以及延迟的时间。

```js
Promise.retry = function (fn, times, delay) {
  return new Promise(function (resolve, reject) {
    var error;
    var attempt = function () {
      if (times == 0) {
        reject(error);
      } else {
        fn()
          .then(resolve)
          .catch(function (e) {
            times--;
            error = e;
            setTimeout(function () {
              attempt();
            }, delay);
          });
      }
    };
    attempt();
  });
};
```

## 18. Promise.finally

```js
Promise.prototype.finally = function (callback) {
  let P = this.constructor;
  return this.then(
    value => P.resolve(callback()).then(() => value),
    error =>
      P.resolve(callback()).then(() => {
        throw error;
      })
  );
};
```

为什么需要`Promise.resolve(callback()).then(() => value)`  
而不能直接执行`callback, return value`  
因为 callback 如果是个异步操作，返回 promise 呢.希望等 callback 执行完再接着执行

## 19. 将一个同步 callback 包装成 promise 形式

同步的 callback 用的最多的是在 node 的回调中，例如下面这种，包装完之后就可以愉快的使用 .then 了。

```js
nodeGet(param, function (err, data) {});
// 转化成promise形式
function nodeGetAysnc(param) {
  return new Promise((resolve, reject) => {
    nodeGet(param, function (err, data) {
      if (err !== null) return reject(err);
      resolve(data);
    });
  });
}
```

按照上面的思路，即可写出通用版的形式。

```js
function promisify(fn, context) {
  return (...args) => {
    return new Promise((resolve, reject) => {
      fn.apply(context, [
        ...args,
        (err, res) => {
          return err ? reject(err) : resolve(res);
        },
      ]);
    });
  };
}
```

传统的 callback 回调方式

```js
let callFn = (arg1, arg2, cb) => {
  //如果arg1>arg2回调正常，否则回调错误信息
  setTimeout(function () {
    if (arg1 > arg2) {
      cb(null, arg1 + arg2);
    } else {
      cb(new Error('err'), null);
    }
  }, 5000);
};

//调用
callFn(1, 2, function (err, data) {
  if (err) {
    //错误处理
  } else {
    //正确处理
  }
});
```

使用 es6 来写上面的功能

```js
let promiseFn = (arg1, arg2) => {
  return new Promise((resole, reject) => {
    if (arg1 > arg2) {
      resole(arg1 + arg2);
    } else {
      reject(new Error('err'));
    }
  });
};

//调用
promiseFn(1, 2)
  .then(data => {
    //正确处理
  })
  .catch(err => {
    //错误处理
  });
```

## 20. 实现一个路由

### Hash

实现原理就是监听 url 的哈希值变化了

```html
<!DOCTYPE html>
<html>
  <head>
    <title>hash 路由</title>
  </head>
  <body>
    <header>
      <a href="#home">首页</a>
      <a href="#center">个人中心页</a>
      <a href="#help">帮助页</a>
    </header>
    <section id="content"></section>
    <script>
      window.addEventListener('hashchange', e => {
        let content = document.getElementById('content');
        content.innerText = location.hash;
      });
    </script>
  </body>
</html>
```

### history

```html
<!DOCTYPE html>
<html>
  <head>
    <title>history 路由</title>
  </head>
  <body>
    <header>
      <a onclick="changeRoute(this)" data-path="home">首页</a>
      <a onclick="changeRoute(this)" data-path="center">个人中心页</a>
      <a onclick="changeRoute(this)" data-path="help">帮助页</a>
    </header>
    <section id="content"></section>
    <script>
      function changeRoute(route) {
        let path = route.dataset.path;
        /**
         * window.history.pushState(state, title, url)
         * state：一个与添加的记录相关联的状态对象，主要用于popstate事件。该事件触发时，该对象会传入回调函数。
         *        也就是说，浏览器会将这个对象序列化以后保留在本地，重新载入这个页面的时候，可以拿到这个对象。
         *        如果不需要这个对象，此处可以填 null。
         * title：新页面的标题。但是，现在所有浏览器都忽视这个参数，所以这里可以填空字符串。
         * url：新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个网址。
         */
        changePage(path);
        history.pushState({ content: path }, null, path);
      }
      /**
       * 调用 history.pushState() 或者 history.replaceState() 不会触发 popstate 事件。
       * 点击后退、前进按钮、或者在 js 中调用 history.back()、history.forward()、history.go() 方法会触发
       */
      window.addEventListener('popstate', e => {
        let content = e.state && e.state.content;
        changePage(content);
      });

      function changePage(pageContent) {
        let content = document.getElementById('content');
        content.innerText = pageContent;
      }
    </script>
  </body>
</html>
```

## 21. 写一个函数，可以控制最大并发数

```js
function concurrentPoll() {
  this.tasks = []; // 任务队列
  this.max = 10; // 最大并发数
  setTimeout(() => {
    // 函数主体执行完后立即执行
    this.run();
  }, 0);
}
concurrentPoll.prototype.addTask = function (task) {
  // 原型添加任务方法
  this.tasks.push(task);
};
concurrentPoll.prototype.run = function () {
  // 原型任务运行方法
  if (this.tasks.length == 0) {
    // 判断是否还有任务
    return;
  }
  var min = Math.min(this.tasks.length, this.max); // 取任务个数与最大并发数最小值
  for (var i = 0; i < min; i++) {
    this.max--; // 执行最大并发递减
    var task = this.tasks.shift(); // 从数组头部取任务
    task()
      .then(res => {
        // 重：此时可理解为，当for循环执行完毕后异步请求执行回调,此时max变为0
        console.log(res);
      })
      .catch(err => {
        console.log(err);
      })
      .finally(() => {
        // 重：当所有请求完成并返回结果后，执行finally回调，此回调将按照for循环依次执行，此时max为0.
        this.max++; // 超过最大并发10以后的任务将按照任务顺序依次执行。此处可理解为递归操作。
        this.run();
      });
  }
};

var poll = new concurrentPoll(); // 实例
for (var i = 0; i < 13; i++) {
  // 数据模拟
  poll.addTask(function () {
    return new Promise(function (resolve, reject) {
      // 一段耗时的异步操作
      resolve('成功'); // 数据处理完成
      // reject('失败') // 数据处理出错
    });
  });
}
```

## 22. jsonp 的实现

jsonp 本质上是一个 Hack，它利用`<script>`标签不受同源策略限制的特性进行跨域操作。

jsonp 优点：

- 实现简单
- 兼容性非常好

jsonp 的缺点：

- 只支持 get 请求（因为`<script>`标签只能 get）
- 有安全性问题，容易遭受 xss 攻击
- 需要服务端配合 jsonp 进行一定程度的改造

jsonp 的实现：

```js
function JSONP({ url, params, callbackKey, callback }) {
  // 在参数里制定 callback 的名字
  params = params || {};
  params[callbackKey] = 'jsonpCallback';
  // 预留 callback
  window.jsonpCallback = callback;
  // 拼接参数字符串
  const paramKeys = Object.keys(params);
  const paramString = paramKeys.map(key => `${key}=${params[key]}`).join('&');
  // 插入 DOM 元素
  const script = document.createElement('script');
  script.setAttribute('src', `${url}?${paramString}`);
  document.body.appendChild(script);
}

JSONP({
  url: 'http://s.weibo.com/ajax/jsonp/suggestion',
  params: {
    key: 'test',
  },
  callbackKey: '_cb',
  callback(result) {
    console.log(result.data);
  },
});
```

## 23. Event bus

```js
// 组件通信，一个触发与监听的过程
class EventEmitter {
  constructor() {
    // 存储事件
    this.events = this.events || new Map();
  }
  // 监听事件
  addListener(type, fn) {
    if (!this.events.get(type)) {
      this.events.set(type, fn);
    }
  }
  // 触发事件
  emit(type) {
    let handle = this.events.get(type);
    handle.apply(this, [...arguments].slice(1));
  }
}

// 测试
let emitter = new EventEmitter();
// 监听事件
emitter.addListener('ages', age => {
  console.log(age);
});
// 触发事件
emitter.emit('ages', 18); // 18
```

## 24. 发布订阅基类 EventEmitter

```js
// 消息接口，订阅发布模式，类似于绑定事件、触发事件
class EventEmitter {
  constructor() {
    this.eventMap = {};
  }

  sub(name, cb) {
    const eventList = (this.eventMap[name] = this.eventMap[name] || []);
    eventList.push(cb);
  }

  pub(name, ...data) {
    (this.eventMap[name] || []).forEach(cb => cb(...data));
  }
}

class Child extends EventEmitter {
  constructor() {
    super();
    // 通过消息接口发布消息
    setTimeout(() => {
      this.pub('update');
    }, 2000);
  }
}

class Parent {
  constructor() {
    // 初始化阶段，传入回调函数
    this.child = new Child();

    // 订阅子组件的消息
    this.child.sub('update', function () {
      console.log('child update');
    });
  }
}
```

## 25. 实现一个 LazyMan

```js
实现一个LazyMan，可以按照以下方式调用:
LazyMan(“Hank”) // 输出: Hi! This is Hank!

LazyMan(“Hank”).sleep(10).eat(“dinner”)
// 输出 
// Hi! This is Hank!
// 等待10秒..
// Wake up after 10
// Eat dinner~

LazyMan(“Hank”).eat(“dinner”).eat(“supper”)
// 输出
// Hi This is Hank!
// Eat dinner~
// Eat supper~

LazyMan(“Hank”).sleepFirst(5).eat(“supper”)
// 输出
// 等待5秒
// Wake up after 5
// Hi This is Hank!
// Eat supper

以此类推。
```

这是典型的 JavaScript 流程控制，问题的关键是如何实现任务的顺序执行。在 Express 有一个类似的东西叫中间件，这个中间件和我们这里的吃饭、睡觉等任务很类似，每一个中间件执行完成后会调用 next()函数，这个函数用来调用下一个中间件。

对于这个问题，我们也可以利用相似的思路来解决，首先创建一个任务队列，然后利用 next()函数来控制任务的顺序执行：

```js
function _LazyMan(name) {
  this.tasks = [];
  var self = this;
  var fn = (function (n) {
    var name = n;
    return function () {
      console.log('Hi! This is ' + name + '!');
      self.next();
    };
  })(name);
  this.tasks.push(fn);
  setTimeout(function () {
    self.next();
  }, 0); // 在下一个事件循环启动任务
}

/* 事件调度函数 */
_LazyMan.prototype.next = function () {
  var fn = this.tasks.shift();
  fn && fn();
};

_LazyMan.prototype.eat = function (name) {
  var self = this;
  var fn = (function (name) {
    return function () {
      console.log('Eat ' + name + '~');
      self.next();
    };
  })(name);
  this.tasks.push(fn);
  return this; // 实现链式调用
};

_LazyMan.prototype.sleep = function (time) {
  var self = this;
  var fn = (function (time) {
    return function () {
      setTimeout(function () {
        console.log('Wake up after ' + time + 's!');
        self.next();
      }, time * 1000);
    };
  })(time);
  this.tasks.push(fn);
  return this;
};

_LazyMan.prototype.sleepFirst = function (time) {
  var self = this;
  var fn = (function (time) {
    return function () {
      setTimeout(function () {
        console.log('Wake up after ' + time + 's!');
        self.next();
      }, time * 1000);
    };
  })(time);
  this.tasks.unshift(fn);
  return this;
};

/* 封装 */
function LazyMan(name) {
  return new _LazyMan(name);
}
```

## 26. 实现数组 flat、filter 等方法

### 实现 forEach

首先明显 forEach 是 Array 上的原型链上的函数所以第一件事就是创建一个原型方法

```js
Array.prototype.MyforEach = function () {};
```

forEach 第一个参数为一个匿名函数 第二个参数为 this 指向 所以

```js
Array.prototype.MyforEach = function (fn, obj) {};
```

forEach 会迭代调用它的数组所以内部肯定是循环

```js
Array.prototype.MyforEach = function (fn, obj) {
  let len = this.length;
  for (let i = 0; i < len; i++) {
    fn(this[i], i, this);
  }
};
```

但还没有考虑 this 指向的事情,所以还需要添加一些调整 this 的代码

```js
Array.prototype.MyforEach = function (fn, obj) {
  let len = this.length;
  if (obj != undefined) {
    fn = fn.bind(obj);
  }
  for (let i = 0; i < len; i++) {
    fn(this[i], i, this);
  }
};
```

### 实现 map

map 与 forEach 的区别是

1. map 中如果是运算,会返回每次函数调用的新的结果组成的数组
2. map 中如果是判断,会返回每次迭代结果组成的数组

所以只要在迭代函数内部创建一个数组,每次迭代都 push 进去,最后返回出去就好

```js
Array.prototype.Mymap = function (fn, obj) {
  var resultData = [];
  var len = this.length;
  if (obj != undefined) {
    fn = fn.bind(obj);
  }
  for (let i = 0; i < len; i++) {
    resultData.push(fn(this[i], i, this));
  }
  return resultData;
};

// 2
Array.prototype.myMap = function (fn, context) {
  // 首先定义一个数组来保存每一项的运算结果，最后返回
  var temp = [];
  if (typeof fn !== 'function') {
    throw new TypeError(`${fn} is not a function`);
  }

  for (let i = 0; i < this.length; i++) {
    // 将每一项的运算操作丢进fn里，
    // 利用call方法指定fn的this指向与具体参数
    temp.push(fn.call(context, this[i], i, this));
  }

  // 返回每一项运算结果组成的新数组
  return temp;
};
```

### 实现 some every

some 与 every 都会有一个特点 默认返回 false

不同的地方在于

- <b>some</b>要求 全部返回 false 返回 false
- <b>​every</b>要求 全部返回 true 返回 true

```js
// -- every --
Array.prototype.Myevery = function (fn, obj) {
  var len = this.length;
  if (obj != undefined) {
    fn = fn.bind(obj);
  }
  for (let i = 0; i < len; i++) {
    if (fn(this[i], i, this) == undefined) {
      // 无返回值 默认返回false
      return false;
    } else if (fn(this[i], i, this) !== true) {
      // 出现一个不为 true 就停止迭代 返回结果
      return false;
    }
  }
  return true;
};

// -- some --
Array.prototype.Mysome = function (fn, obj) {
  var len = this.length;
  if (obj != undefined) {
    fn = fn.bind(obj);
  }
  for (let i = 0; i < len; i++) {
    if (fn(this[i], i, this) == undefined) {
      return false;
    } else if (fn(this[i], i, this) !== false) {
      return true;
    }
  }
  return false;
};
```

### 实现 fliter

```js
Array.prototype.Myfilter = function (fn, obj) {
  let resultData = [];
  var len = this.length;
  if (obj != undefined) {
    fn = fn.bind(obj);
  }
  for (let i = 0; i < len; i++) {
    if (fn(this[i], i, this)) {
      // 返回true则进行处理
      resultData.push(this[i]); // 注意不是push函数结果
    }
  }
  return resultData;
};

// -- 运行 --

var array = [1, 2, 3, 4, 5, 6, 7, 8, 9];
var result = array.Myfilter(e => {
  return e > 5;
});
console.log(result);
//  [6, 7, 8, 9]
```

### 实现 flat

1. 利用数组的 reduce 和 concat 实现数组 flat，并可传参

   ```js
   Array.prototype.flat = function (deep = 1) {
     if (typeof deep !== 'number') {
       throw new TypeError('深度参数必须为数字类型');
     }
     if (deep === 0) return this;
     let arr1 = this;
     return arr1.reduce((acc, val) => {
       console.log(deep);
       if (Array.isArray(val) && deep > 1) {
         console.log(acc);
         return acc.concat(val.flat(--deep));
       } else {
         return acc.concat(val);
       }
     }, []); // [1, 2, 3, 4]
   };
   ```

2. 递归

   ```js
   Array.prototype.flat = function () {
     var arr = [];
     this.forEach((item, idx) => {
       if (Array.isArray(item)) {
         arr = arr.concat(item.flat());
       } else {
         arr.push(item);
       }
     });
     return arr;
   };
   ```

3. 连接数组返回字符串用,进行分割，然后 map 映射将数组的 string 转换为 number

   ```js
   Array.prototype.flat = function () {
     return this.toString() //"1,2,3,4"
       .split(',') //["1", "2", "3", "4"]
       .map(item => +item); //[1, 2, 3, 4]
   };
   console.log([1, [2, [3, 4]]].flat()); //[1, 2, 3, 4]
   ```

4. 扩展运算符

   ```js
   Array.prototype.flat = function () {
     var arr = this;
     while (arr.some(item => Array.isArray(item))) {
       arr = [].concat(...arr);
     }
     return arr;
   };

   console.log([1, [2, [3, 4]]].flat()); //[1, 2, 3, 4]
   ```

5. 正则 replace + split

    ```js
    str.replace(/(\[\]))/g, '').split(',');
    ```

6. 正则 replace + JSON.parse

   ```js
   str = str.replace(/(\[\]))/g, '');
   str = '[' + str + ']';
   var ary = JSON.parse(str);
   ```

## 27. 实现页面加载进度条

网页加载百分比，这个 JS 是不能直接获取的，网上有灰常多投机取巧的办法，但最多也只能做到接近，而不是绝对准确，其实，加载百分比的这个数值，对于用户来说是毫无意义的，用户只要看到进度条有在动，就认为网页不卡，于是，我就有了下面的想法：

做一个进度条，它永远在前进，却永远走不到 100%，只能无限接近于 100%，等到资源或数据加载完成了，再突然地使进度条走满。具体思路：进条度分已加载和未加载两部分，已加载一直在增加，未加载一直在减少，已加载每次增加的量刚好等于未加载部分的 n%（n < 100），于是，效果就会是加载不断地接近 100% 却走不到 100%，而且还能看到进度条一直是动的，用户越是等待就越舍不得放弃，因为进度条没有停滞，用户会认为网页加载一直在进行。

进条度每次增加剩余部分的 20%，为了演示加载完成，在 10s 后强制结束进度条

```js
var loading = (function () {
  var ct = document.getElementById('progressbar'),
    desc = ct.getElementsByTagName('div'),
    idx = 0,
    time = 500,
    bar = desc[1],
    desc = desc[2];
  bar.setValue = function (n) {
    this.style.width = n + '%';
  };
  void (function () {
    bar.setValue((idx += (100 - idx) * 0.2));
    timer = setTimeout(arguments.callee, (time += 100));
  })();
  return {
    remove: function () {
      clearTimeout(timer);
      desc.innerHTML = '加载完成';
      bar.setValue(100);
      setTimeout(function () {
        ct.parentNode.removeChild(ct);
      }, 500);
    },
  };
})();

setTimeout(loading.remove, 10000);
```

## 28. 实现 parseInt

```js
function _parseInt(str, radix) {
  var res = 0;
  if (typeof str != 'string' && typeof str != 'number') {
    return NaN;
  }
  str = String(str).trim().split('.')[0];
  // l(str)
  let len = str.length;
  if (!len) {
    return NaN;
  }
  if (!radix) {
    return (radix = 10);
  }
  if (typeof radix !== 'number' || radix < 2 || radix > 36) {
    return NaN;
  }
  for (let i = 0; i < len; i++) {
    let arr = str.split('');
    console.log(arr instanceof Array);
    console.log(typeof arr);
    res += Math.floor(arr[i]) * Math.pow(radix, i);
  }
  return res;
}

_parseInt('654646', 10);
```

## 29. async 函数

async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里

```js
function spawn(genF) {
  return new Promise(function (resolve, reject) {
    const gen = genF();
    function step(nextF) {
      let next;
      try {
        next = nextF();
      } catch (e) {
        return reject(e);
      }
      if (next.done) {
        return resolve(next.value);
      }
      Promise.resolve(next.value).then(
        function (v) {
          step(function () {
            return gen.next(v);
          });
        },
        function (e) {
          step(function () {
            return gen.throw(e);
          });
        }
      );
    }
    step(function () {
      return gen.next(undefined);
    });
  });
}
```

## 30. 0.1+0.2 为什么不等于 0.3

用一句话概括就是：

> EcmaScrpt 规范定义 Number 的类型遵循了 IEEE754-2008 中的 64 位浮点数规则定义的小数后的有效位数至多为 52 位导致计算出现精度丢失问题！

JS 中采用的 IEEE 754 的双精度标准，计算机内部存储数据的编码的时候，导致精度变化。不是所有浮点数都有舍入误差。二进制能精确地表示位数有限且分母是 2 的倍数的小数（这种情况的小数像乘法 0.1\*0.2 的出五十分之一就不能精确）。

因为精度不足导致的问题，比如二进制表示 0.1 时这这样表示`1001100110011...`(0011 无线循环)，那么这些循环的数字被 js 裁剪后，就会出现精度丢失的问题，也就造成了`0.1`不再是 `0.1` 了，而是变成了 `0.100000000000000002`
我们可以来测试一下：

```js
0.100000000000000002 === 0.1; //true
```

由此我们可以得出:

```js
0.1 + 0.2 === 0.30000000000000004; //true
```

所以自然`0.1+0.2!=0.3`。

那么如何解决这个问题；使用原生最简单的方法:

```js
parseFloat((0.1 + 0.2).toFixed(10)) === 0.3; //true
```

```js
function add() {
  const args = [...arguments];
  const maxLen = Math.max.apply(
    null,
    args.map(item => {
      const str = String(item).split('.')[1];
      return str ? str.length : 0;
    })
  );
  return args.reduce((sum, cur) => sum + cur * 10 ** maxLen, 0) / 10 ** maxLen;
}
console.log(add(0.1, 0.2)); // => 0.3
console.log(add(10, 11)); // => 21
console.log(add(0.001, 0.003)); // => 0.004
console.log(add(0.001, 0.003, 0.005)); // => 0.009
console.log(add(0.001)); // => 0.001
```

## 31. 模拟实现一个 localStorage

```js
const localStorageMock = (function () {
  let store = {};
  return {
    getItem: function (key) {
      return store[key] || null;
    },
    setItem: function (key, value) {
      store[key] = value.toString();
    },
    removeItem: function (key) {
      delete store[key];
    },
    clear: function () {
      store = {};
    },
  };
})();

Object.defineProperty(window, 'localStorage2', {
  value: localStorageMock,
});

localStorage2.setItem('test', 'test');
console.log(localStorage2.getItem('test')); //test
localStorage2.removeItem('test');
console.log(localStorage2.getItem('test')); //null
localStorage2.setItem('test', 'test');
localStorage2.clear();
console.log(localStorage2.getItem('test')); //null
```

用 cookie 模拟 localStorage

```js
if (!window.localStorage) {
  window.localStorage = {
    getItem: function (sKey) {
      if (!sKey || !this.hasOwnProperty(sKey)) {
        return null;
      }
      return unescape(
        document.cookie.replace(
          new RegExp(
            '(?:^|.*;\\s*)' +
              escape(sKey).replace(/[\-\.\+\*]/g, '\\$&') +
              '\\s*\\=\\s*((?:[^;](?!;))*[^;]?).*'
          ),
          '$1'
        )
      );
    },
    key: function (nKeyId) {
      return unescape(
        document.cookie
          .replace(/\s*\=(?:.(?!;))*$/, '')
          .split(/\s*\=(?:[^;](?!;))*[^;]?;\s*/)[nKeyId]
      );
    },
    setItem: function (sKey, sValue) {
      if (!sKey) {
        return;
      }
      document.cookie =
        escape(sKey) +
        '=' +
        escape(sValue) +
        '; expires=Tue, 19 Jan 2038 03:14:07 GMT; path=/';
      this.length = document.cookie.match(/\=/g).length;
    },
    length: 0,
    removeItem: function (sKey) {
      if (!sKey || !this.hasOwnProperty(sKey)) {
        return;
      }
      document.cookie =
        escape(sKey) + '=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/';
      this.length--;
    },
    hasOwnProperty: function (sKey) {
      return new RegExp(
        '(?:^|;\\s*)' + escape(sKey).replace(/[\-\.\+\*]/g, '\\$&') + '\\s*\\='
      ).test(document.cookie);
    },
  };
  window.localStorage.length = (
    document.cookie.match(/\=/g) || window.localStorage
  ).length;
}
```

## 32. pipe

`pipe(f,g,h)`是一个柯里化函数，它返回一个新的函数，这个新的函数将会完成`(...args)=>h(g(f(...args)))`的调用，即 `pipe` 返回的函数会接收一个参数，这个参数将会作为数组 functions 的 reduce 方法的初始值

```js
const pipe = (...functions) => input =>
  functions.reduce((acc, fn) => fn(acc), input);
```

## 33. compose

`compose` 方法和 `pipe` 方法的差别只在于调用顺序的不同

```js
// compose
fn1(fn2(fn3(fn4(args))));

// pipe
fn4(fn3(fn2(fn1(args))));
```

```js
// 实现compose方法的最简单的方案是面向过程的
const compose = function(...args){
  let length = args.length
  let count = length -1;
  let result

  return function f1(...args){
    result = args[count].apply(this,arg1)
    if(count<=0>){
      count = length-1
      return result
    }
    count--
    return f1.call(null,result)
  }
}


// 利用reduce
const reduceFunc = (f,g)=>(...arg)=>g.call(this,f.apply(this,arg));
const compose = (...args)=>args.reverse().reduce(reduceFunc,args.shift())


// 既然实现该方法涉及串联和流程控制，那么应该还可以使用Promise实现
const compose = (...args) => {
  let init = args.pop();
  return (...arg) =>
    args
      .reverse()
      .reduce(
        (sequence, func) => sequence.then((result) => func.call(null, result)),
        Promise.resolve(init.apply(null, arg))
      )
}
```

首先通过 `Promise.resolve(init.apply(null,arg))`启动 `reduce` 逻辑，利用数组的 `reduce` 方法来依次执行函数，因为 `Promise.then()`仍然返回一个 `Promise` 类型的值，所以 reduce 方法完全可以基于 Promise 实例执行下去

```js
// lodash版本
var compose = function (funcs) {
  var length = funcs.length;
  var index = length;
  while (index--) {
    if (typeof funcs[index] !== 'function') {
      throw new TypeError('Expected a function');
    }
  }

  return function (...args) {
    var index = 0;
    var result = length ? funcs.reverse()[index].apply(this, args) : args[0];
    while (++index < length) {
      result = funcs[index].call(this, result);
    }
    return result;
  };
};
```

```js
// Redux 版本
function compose(...funcs) {
  if (funcs.length === 0) {
    return arg => arg;
  }

  if (funcs.length === 1) {
    return funcs[0];
  }

  return funcs.reduce((a, b) => (...args) => a(b(...args)));
}
```

## 34. window.requestAnimationFrame && polyfill

window.requestAnimationFrame:该方法告诉浏览器你希望执行的操作，并请求浏览器在下一次重绘之前调用指定的函数来更新

语法如下：

```js
window.requestAnimationFrame(callback);
```

也就是说当你需要更新屏幕画面时可以调用此方法。浏览器在下次重绘前会统一执行回调函数

```js
// 读
var h1 = element1.clientHeight;
// 写
requestAnimationFrame(() => {
  element1.style.height = h1 * 2 + 'px';
});
```

`polyfill` 是我们常说的垫片，此处指在浏览器兼容性不支持的情况下的备选实现方案

```js
if (!window.requestAnimationFrame) {
  window.requestAnimationFrame = (callback, element) => {
    const id = window.setTimeout(() => {
      callback();
    }, 1000 / 60);
    return id;
  };
}
if (!window.cancelAnimationFrame) {
  window.cancelAnimationFrame = id => {
    clearTimeout(id);
  };
}
```
