# 算法

[[toc]]

## 1. 位运算相关

### 计算汉明重量

**汉明重量**是一串符号中**非零符号的个数**。因此它等同于同样长度的全零符号串的汉明距离。在最为常见的数据位符号串中，它是 1 的个数。

<div align="center"><img :src="$withBase('/images/prepare/require/2020071501.png')" alt="images/prepare/require/2020071501.png"></div>

<div align="center"><img :src="$withBase('/images/prepare/require/2020071502.png')" alt="images/prepare/require/2020071502.png"></div>

```js
function hammingWeight(n) {
  let num = 0;
  while (n !== 0) {
    n &= n - 1;
    num++;
  }
  return num;
}
```

### 判断奇偶

```js
// even 偶数 & 1 = 0
// odd  奇数 & 1 = 1

funciton isOdd(n) {
  return n & 1 === 1;
}
```

## 2. 二分查找

二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法，前提是**数据结构必须先排好序**，可以在数据规模的对数时间复杂度内完成查找。但是，二分查找要求线性表具有有随机访问的特点（例如数组），也要求线性表能够根据中间元素的特点推测它两侧元素的性质，以达到缩减问题规模的效果。

::: tip
数据必须是有序，也就是说排好序
:::

```js
let search = (arr, target) => {
  let begin = 0;
  let end = arr.length - 1; //写成这样，相当于搜索区间为[begin, end]，这是一个闭区间
  while (begin <= end) {
    //重点: 因为闭区间，所以到了begin等于end时，其实区间内还有一个值要判断，
    //因此只有begin>end的时候才能停止
    let mid = (begin + end) >>> 1; //位运算，无符号右移一位，同Math.floor((begin+end)/2)
    if (arr[mid] == target) {
      return mid;
    } else if (arr[mid] > target) {
      end = mid - 1; //因为是闭区间，搜索范围变为[left, mid - 1]
    } else if (arr[mid] < target) {
      begin = mid + 1; //搜索范围变成[mid + 1, end]
    }
  }
  return -1;
};
```

顺便提一下，根据上面的思路，我们也可以写成递归的方式:

```js
let search = (nums, target) => {
  let helpSearch = (nums, begin, end, target) => {
    if (begin > end) return -1;
    let mid = (begin + end) >>> 1;
    if (nums[mid] == target) return mid;
    else if (nums[mid] > target)
      return helpSearch(nums, begin, mid - 1, target);
    else return helpSearch(nums, mid + 1, end, target);
  };
  //闭区间形式
  return helpSearch(nums, 0, nums.length - 1, target);
};
```

## 3. 常见排序

### 快速排序

```js
function quickSort(arr) {
  if (arr.length <= 1) return arr;

  let left = [];
  let right = [];
  let pivot = arr[0];

  for (let i = 1; i < arr.length; i++) {
    if (arr[i] >= pivot) {
      right.push(arr[i]);
    } else {
      left.push(arr[i]);
    }
  }

  return [...quickSort(left), pivot, ...quickSort(right)];
}
```

### 冒泡排序

```js
function bubbleSort(arr) {
  let i = arr.length - 1;
  while (i >= 0) {
    for (let j = 0; j < i; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
      }
    }
    i--;
  }
  return arr;
}
```

## 4. 二叉树遍历相关

### 先序遍历（中->左->右）

递归实现

```js
function preOrderTraverse(root) {
  if (root) {
    console.log(root);
    preOrderTraverse(root.left);
    preOrderTraverse(root.right);
  }
}
```

非递归实现

```js
function preOrderTraverse(root) {
  let stack = [];

  if (root) {
    stack.push(root);
  }

  while (stack.length) {
    let temp = stack.pop();

    console.log(temp);

    if (temp.right) stack.push(temp.right);
    if (temp.left) stack.pus(temp.left);
  }
}
```

### 中序遍历（左->中->右）

递归实现

```js
function midOrderTraverse(root) {
  if (root) {
    midOrderTraverse(root.left);

    console.log(root);

    midOrderTraverse(root.right);
  }
}
```

非递归实现

```js
function midOrderTraverse(root) {
  let stack = [];

  while (true) {
    while (root) {
      stack.push(root);
      root = root.left;
    }

    if (!stack.length) break;

    let temp = stack.pop();

    console.log(temp);

    root = temp.right;
  }
}
```

### 后序遍历（左->右->中）

递归实现

```js
function postOrderTraverse(root) {
  if (root) {
    postOrderTraverse(root.left);
    postOrderTraverse(root.right);

    console.log(root);
  }
}
```

非递归实现

```js
function postOrderTraverse(root) {
  let stack = [];
  let rest = [];
  if (root) stack.push(root);
  while (stack.length) {
    let temp = stack.pop();
    rest.push(temp);
    if (temp.left) stack.push(temp.left);
    if (temp.right) stack.push(temp.right);
  }
  return rest.reverse();
}
```

### 层次遍历

```js
function levelTraverse(root) {
  if (!root) return;

  let stack = [];
  stack.push(root);

  while (stack.length) {
    let temp = stack.shift();

    console.log(temp);

    if (temp.left) stack.push(temp.left);
    if (temp.right) stack.push(temp.right);
  }
}
```

## 5. 质数判断和筛选

普通的质数判断方法。

```js
function judge(n) {
  for (let i = 2, len = Math.sqrt(n); i <= len; i++) {
    if (n % i === 0) return false;
  }
  return true;
}
```

厄拉多塞筛法，时间复杂度 O(n \* loglog n)：从 2 开始遍历，把 2 的倍数都标记为 false（表示不是素数），再从 2 的下一位素数 3 开始也同样标记其倍数。以此类推，最后仍为 true 的则为素数。

```js
function choosePrimes(n = 10000) {
  // 标记是否为素数
  let mark = Array(n).fill(true);
  // 存放素数
  let primes = [];
  let index = 0;
  for (let i = 2; i <= n; i++) {
    // 如果i是质数则放入primes数组，并标记i的倍数
    if (mark[i] === true) {
      primes[index++] = i;
      for (let j = i + i; j <= n; j += i) {
        mark[j] = false;
      }
    }
  }
  console.log(primes);
}
```

## 6. 线性顺序存储结构和链式存储结构有什么区别？以及优缺点

区别：

1. 顺序存储需要开辟一个定长的空间，读写速度快，缺点不可扩充容量(如果要扩充需要开辟一个新的足够大的空间把原来的数据重写进去)。
2. 链式存储无需担心容量问题，读写速度相对慢些，由 zd 于要存储下一个数据的地址所以需要的存储空间比顺序存储大

优缺点:

1. 空间上  
   顺序比链式节约空间。是因为链式结构每一个节点都有一个指针存储域。
2. 存储操作上：  
   顺序支持随机存取，方便操作
3. 插入和删除上  
   链式的要比顺序的方便（因为插入的话顺序表也很方便，问题是顺序表的插入要执行更大的空间复杂度，包括一个从表头索引以及索引后的元素后移，而链表是索引后，插入就完成了）  
   例如：当你在字典中查询一个字母 j 的时候，你可以选择两种方式，第一，顺序查询，从第一页依次查找直到查询到 j。第二，索引查询，从字典的索引中，直接查出 j 的页数，直接找页数，或许是比顺序查询最快的。

## 7. 单链表反转

使用递归的方式。

优势：

1. 借用 JS 强大的闭包功能
2. 只需遍历一遍链表

缺点：

递归的缺点：占空间

思路：

1. 递归的基线条件：遍历到末节点（node.next === null）
2. 递归的递归条件：node.next !== null
3. 当遇到末节点时，返回末节点，前一节点接收末节点，并把末节点的 next 设置为自身，返回前一节的，继续下去
4. 考虑特殊情况：undefined 和 null

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
  // 闭包
  if (head === undefined || head === null) return null;
  var originalHead = head;
  var reverseHead;
  var reverse = function(head) {
    if (head.next === null) {
      reverseHead = head;
      return head;
    } else {
      var node = reverse(head.next);
      node.next = head;
      if (originalHead === head) {
        head.next = null;
        return reverseHead;
      } else {
        return head;
      }
    }
  };
  return reverse(head);
};
```

```js
function reverse(linkedList) {
  var head = linkedList.head;

  // 如果只有一个节点 或者 是空链表
  if (head === null || head.next === null) {
    return;
  }
  var p = head;
  var q = p.next;
  // 反转后的头结点变成尾节点
  head.next = null;
  while (q) {
    r = q.next;
    q.next = p;
    p = q;
    q = r;
  }
  // 退出循环后 r = q.next = null, q.next = q; p=q; q=null;
  // p指向原来节点的尾节点， 那么翻转后，尾节点变成头结点
  linkedList.head = p;
}
```

## 8. 链表

链表也是一种存储数据的工具，不同于数组，链表中的元素并不是连续存储的。因此不能通过下标去访问。 链表分为单(向)链表，双向链表，循环链表等。.今天来实现一下单链表。

单链表中的每个元素包括两个两个域，一个是保存元素本身的域，另一个是指向一下一个节点的指针域

```js
function LinkedList() {
  var Node = function(ele) {
    this.ele = ele; //ele  属性代表插入的值
    this.next = null; //  next属性 代表 指向下一个节点的指针
  };
  var head = null;
  var length = 0;

  // 向链表末尾插入一个元素
  this.append = function(ele) {
    var node = new Node(ele);
    var currentNode = null;

    if (head === null) {
      // 列表为空，插入的节点是第一个头结点
      head = node;
    } else {
      currentNode = head;
      // 循环链表，直到最后一个节点
      while (currentNode.next !== null) {
        currentNode = currentNode.next;
      }
      // 出了while循环，说明找到了最后一个节点
      currentNode.next = node;
    }
    length++;
  };
  // 删除链表中指定的某个节点:删除头结点 or  除了头结点以外的节点
  this.removeAt = function(position) {
    var currentNode = head;
    var previousNode = null;
    var index = 0;

    if (position >= 0 && position < length) {
      if (position === 0) {
        node = currentNode.next;
      } else {
        while (index++ < position) {
          previousNode = currentNode;
          currentNode = currentNode.next;
        }
        // 出了while循环， index === position
        previousNode.next = currentNode.next;
      }
      length--;
      return currentNode.ele;
    }
    // 要删除的节点的不存在
    else {
      return -1;
    }
  };
  // 在任意位置插入一个元素
  this.insert = function() {
    // 检查是否越界
    if (position >= 0 && position <= length) {
      var newNode = new Node(ele);
      var currentNode = head; // 保存一下头结点
      var previousNode = null;
      var index = 0;

      if (position === 0) {
        newNode.next = currentNode;
        head = newNode;
      } else {
        while (index++ < position) {
          previousNode = currentNode;
          currentNode = currentNode.next;
        }
        // 出了循环表示找到位置
        newNode.next = currentNode;
        previousNode.next = currentNode;
      }
      length++;
      return 1;
    } else {
      return -1;
    }
  };

  //查找链表中的某个元素所在位置， 无此元素返回 -1
  this.find = function(ele) {
    var currentNode = head;
    var index = 0;
    while (currentNode) {
      if ((currentNode.ele = ele)) {
        return index;
      }
      currentNode = currentNode.next;
      index++;
    }
    return -1;
  };

  this.isEmpty = function() {
    return length === 0;
  };

  this.size = function() {
    return length;
  };
}
```

## 9. 二分法

在开始之前，我们来玩一个**猜数字游戏**：

**规则**：在数字 1-100 之间，你朋友选择要猜的数字之后，由你来猜数字。你每猜一个数字，你的朋友将会作出下面三种回应之一：

- 猜对了
- 猜大了
- 猜小了

这个游戏很简单，如果我们使用二分查找的策略进行的话，我们只需要经过短短的几次就确定我们要查找的数据了。

那么二分查找的原理是什么呢？

二分查找又称为折半查找，对有序的列表每次进行对半查找。就是这么简单@～@！

代码实现走一波：

```js
/*
 * @param { Array } arr 有序的数组 ⚠️注意：是有序的有序的有序的
 * @param { Number } data 要查找的数据
 * @return { Number } 返回查找到的位置，未查找到放回-1值
 **/
function binSearch(arr, data) {
  let upperBound = arr.length - 1,
    lowerBound = 0;

  while (lowerBound <= upperBound) {
    let mid = Math.floor((upperBound + lowerBound) / 2);
    if (arr[mid] < data) {
      lowerBound = mid + 1;
    } else if (arr[mid] > data) {
      upperBound = mid + 1;
    } else {
      return mid;
    }
  }
  return -1; // 你朋友选要猜的数据在1-100范围之外
}
```

---

**在数组里查找数据，找到数据所在的索引**

```js
// 在数组里面查找数据，找到数据所在位置的索引
var arr = new Array(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
var a = 2;

//方法一
console.log(arr.indexOf(a));

//方法二
for (var i = 0; i < arr.length; i++) {
  if (a == arr[i]) {
    console.log(i);
  }
}

// 二分法查找数据,数组必须是排好序的
var minx = 0; //定义最小值
var maxx = arr.length - 1; //定义最大值
while (true) {
  //不确定循环次数，使用while循环
  //定义中间值等于最大值和最小值和的一半
  var zjx = parseInt((minx + maxx) / 2);
  if (zjx == minx) {
    //中间值等于最小值的情况下
    if (a == arr[zjx + 1]) {
      console.log(zjx + 1); //如果要查找的数据等于中间值+1，也就是中间值右边得数，输出值，跳出循环
      break;
    }
  }
  if (a == arr[zjx]) {
    console.log(zjx); //如果中间值等于要查找的数，输出
    break;
  } else if (a > arr[zjx]) {
    //如果中间值大于要查找的数
    minx = zjx; //中间值赋给最小值，然后继续循环
  } else {
    maxx = zjx; //如果中间值小于要查找的数，中间值赋给最大值，然后继续循环
  }
}
```

二分法查找的前提: **数组必须为有序**

**思路**：  
找到数组的中间数 zjx 和要查找的数 a,若`a<zjx`,则要查找的数在中间数 zjx 的左边，就把数组二分，只在左边查找，右边同理,直到找到要查找的数。

**二分法对于数据特别多的情况能极大的节约效率**。

在上面的二分法中：

- 首先定义最大值 maxx，最小值 minx
- 中间值 zjx 也可以再循环中定义
- 我们不能确定循环的次数，所以这里使用 while 循环
- 首先找出中间值，中间值等于最大值和最小值的和除以 2
- 如果要查找的数等于中间值，输出
- 如果中间值大于要查找的数，说明要查找的数比中间值小，在中间值左边，然后把中间值作为最大，继续循环
- 如果中间值小于要查找的数，说明要查找的数比中间值大，在中间值右边，然后把中间值作为最小，继续循环
- 如果遇到还剩下两个数的情况，这两个值就一个大的是最大值，一个小的是最小值，取出的中间值因为在程序中去掉了分数，只留整数，所以中间值也就是最小值，这时判断要查找的数是否是中间值即最小值右边的数即最大值，如果是，输出

## 10. 寻找数组中第 k 大的元素

**问题描述**：在数组中找到第 k 大的元素。要求时间复杂度为 O(n),空间复杂度为 O(1)

分析：此类问题为排序问题，主要难点在于时间复杂度为 O(n),采用快速排序算法进行排序

```js
function quickSort(nums, k, start, end) {
  if (start >= end) {
    return nums[k];
  }
  var left = start,
    right = end;
  var key = nums[Math.floor((start + end) / 2)];
  while (left <= right) {
    while (left <= right && nums[left] < key) {
      left++;
    }
    while (left <= right && nums[right] > key) {
      right--;
    }
    if (left <= right) {
      swap(nums, left, right);
      left++;
      right--;
    }
  }

  if (k <= right) {
    return quickSort(nums, k, start, right);
  }
  if (k >= left) {
    return quickSort(nums, k, left, end);
  }
  return nums[k];
}

function swap(nums, i, j) {
  var tmp = nums[i];
  nums[i] = nums[j];
  nums[j] = tmp;
}
```

1. 基数的选择影响时间复杂度，O(选最左边的为基数)>O(选最中间的数为基数)，一般来说当块划分的相对平均的时候时间复杂度较低
2. js 中/得出的结果为实际值，如果要取整需要使用相应的函数如（parseInt 丢弃小数部分，保留整数,floor 向下取整,round 四舍五入,ceil 向上取整）

## 11. 给定一个链表，判断链表中是否有环，比如下图这种即为有环链表

<br />
<div align="center"><img :src="$withBase('/images/prepare/new/2020050901.png')" alt="images/prepare/new/2020050901.png"></div>

加分项：使用空间复杂度 O(1) 实现

```js
// 可以用快慢指针或者简单的集合
const cycle1 = function(node) {
  let set = new Set();
  while (node) {
    if (set.has(node)) return true;
    else set.add(node);
    node = node.next;
  }
  return false;
};

const cycle2 = function(node) {
  let start = node;
  let end = node.next;
  while (start !== end) {
    // 没有环就null
    if (end === null || end.next === null) return false;
    start = start.next;
    end = end.next.next;
  }
  return true;
};
```

## 12. 分析一个项目的依赖结构，并按依赖优先级排序。

已知一个项目的依赖结构，期望在前端通过 loader 的方式异步加载相关的组件，而我们期望依赖在加载的过程中：

- 每一个依赖被加载后都会被立刻执行，那么如果要争取加载一个依赖，则其子依赖都应该优先被加载
- 每一个依赖不希望在钱多出现冗余的情况，若依赖出现多版本的情况，则默认使用更新的版本，比如已知项目依赖结构为（其中 @ 后面的为依赖版本号）：

```
ProjectA
- a@0.1.0
    - d@0.2.0
    - c@0.1.0
- b@0.1.1
    - e@0.1.2
    - c@0.1.2
- c@0.2.0
```

则其中一种输出的依赖优先级排序为：  
['d@0.2.0', 'c@0.2.0', 'a@0.1.0', 'e@0.1.2', 'b@0.1.1']

输出分析：为了让 a 加载后可以争取执行，则必须先加载 d 和 c，b 的加载同理，又因为在整个依赖关系下，c 的最新版本为 0.2.0 于是有了如上的输出结果。

拿到题目第一个想到的就是 DFS 来寻找那些依赖，然后最后再对依赖这些进行版本比较（其实应该用集合、还有拓扑排序来优化）

```js
function update(npmList) {
  let versions = {};
  let res = [];

  // 比较版本号
  function cmp(a, b) {
    const versionListA = getVersion(a).split(".");
    const versionListB = getVersion(b).split(".");
    for (let index = 0; index < 3; index++) {
      const versionA = parseInt(versionListA[index]);
      const versionB = parseInt(versionListB[index]);
      if (versionA > versionB) return a;
      else if (versionA === versionB) continue;
      else return b;
    }
    return a;
  }

  // 获得版本号
  function getVersion(str) {
    return str.substr(str.indexOf("@") + 1);
  }

  function dfs(npmList) {
    if (npmList.length === 0) return;

    npmList.forEach(npm => {
      const { name, deps = [] } = npm;
      // 先遍历他们的依赖
      dfs(deps);
      let key = name.substr(0, name.indexOf("@"));
      // 如果依赖不存在则添加，若已存在，则取最新版
      if (!versions[key]) {
        versions[key] = name;
      } else {
        versions[key] = cmp(versions[key], name);
      }
      // 添加进最后的加载列表
      res.push(key);
    });
    return;
  }
  dfs(npmList);
  // 去除重复项，然后将包名转换为依赖名，eg: a -> a@0.1.0
  return [...new Set(res)].map(key => versions[key]);
}
```

## 13. 实现一个函数 reverse(a, n) ，反转一个含有 n 个整数的数组 a（直接在数组 a 上操作，元素交换次数 尽可能少，不能使 js Array 类内置属性和方法）。

```js
var x = [0, 1, 2, 3];
reverse(x, 4); // x = [3, 2, 1, 0]
var y = [1, 2, 3, 4, 1];
reverse(y, 5); // y = [1, 4, 3, 2, 1]

function reverse(arr) {
  let len = arr.length;
  for (let start = 0; start < Math.floor(len / 2); start++) {
    let end = len - start - 1;
    [arr[start], arr[end]] = [arr[end], arr[start]];
  }
  return arr;
}
```

## 14. 实现一个函数 countLongest(tree) ，输入一棵二叉树，返回二叉树中距离最远的两个叶子节点之间 的距离。

```js
var tree1 = {
  value: 1,
  left: {
    value: 2
  },
  right: {
    value: 3
  }
};
/**
    1
   / \
  2   3
*/
countLongest(tree1); // 2

var tree2 = {
  value: 1,
  left: {
    value: 2,
    left: {
      value: 3,
      left: {
        value: 6
      }
    },
    right: {
      value: 4
    }
  },
  right: {
    value: 5
  }
};

/**
       1
      / \
     2   5
    / \
   3   4
  /
 6
*/

countLongest(tree2); // 4
```

```js
function countLongest(tree) {
  if (!tree) return 0;
  let res = 0;

  function dfs(node) {
    if (!node) return 0;
    const leftMax = dfs(node.left);
    const rightMax = dfs(node.right);
    res = Math.max(leftMax + rightMax, res);
    return Math.max(leftMax, rightMax) + 1;
  }
  dfs(tree);
  return res;
}

console.log(
  countLongest({
    value: 1,
    left: {
      value: 2
    },
    right: {
      value: 3
    }
  })
);
console.log(
  countLongest({
    value: 1,
    left: {
      value: 2,
      left: {
        value: 3,
        left: {
          value: 6
        }
      },
      right: {
        value: 4
      }
    },
    right: {
      value: 5
    }
  })
);
```

## 15. 实现函数 resolve(tree)

在前端开发中，通常会把多个 js 文件合并成一个文件，以减少⽹络请求次数，达到优化加载速度的⽬ 的，但是当文件之间存在依赖关系时，对 js 合并的顺序，会有一定的要求，例如 A.js 依赖了 B.js，那打 包后的文件，B.js 需要排在 A.js 的前面。实现一个函数 resolve(tree) ，根据 js 的依赖关系树 tree，输出合理的打包顺序的数组（结果可能不 唯一，输出其中一种即可）。

样例

```js
var tree1 = {
  name: "main.js",
  require: [
    {
      name: "A.js"
    },
    {
      name: "B.js"
    }
  ]
};
resolve(tree1); // ['A.js', 'B.js', 'main.js']

var tree2 = {
  name: "page.js",
  require: [
    {
      name: "A.js",
      require: [
        {
          name: "B.js",
          require: [
            {
              name: "C.js"
            }
          ]
        }
      ]
    },
    {
      name: "D.js",
      require: [
        {
          name: "C.js"
        },
        {
          name: "E.js"
        }
      ]
    }
  ]
};
resolve(tree2); // ['C.js', 'E.js', 'D.js', 'B.js', 'A.js', 'page.js']
```

```js
function resolve(npmList) {
  const res = [];

  function dfs(npmList) {
    if (npmList.length === 0) return;

    npmList.forEach(npm => {
      const { name, require = [] } = npm;
      dfs(require);
      !res.includes(name) && res.push(name);
    });
    return;
  }
  dfs(npmList);
  return res;
}

console.log(
  resolve([
    {
      name: "page.js",
      require: [
        {
          name: "A.js",
          require: [
            {
              name: "B.js",
              require: [
                {
                  name: "C.js"
                }
              ]
            }
          ]
        },
        {
          name: "D.js",
          require: [
            {
              name: "C.js"
            },
            {
              name: "E.js"
            }
          ]
        }
      ]
    }
  ])
);
```

## 16. 给定一个整数数组 a，实现一个函数 countMax(a) ，计算出从 a 中选择出多个不相邻元素组成最大的 和是多少。

样例

```js
var x = [1, 4, 5, 3];
countMax(x); // 7
var y = [3, 12, 6, 2, 4];
countMax(y); // 16
```

用动态规划来找

```js
function countMax(arr) {
  const len = arr.length;
  const dp = new Array(len).fill(0);
  dp[0] = arr[0];
  dp[1] = arr[1];
  dp[2] = arr[0] + arr[2];
  for (let i = 3; i < len; i++) {
    dp[i] = arr[i] + Math.max(dp[i - 2], dp[i - 3]);
  }
  return Math.max(dp[len - 1], dp[len - 2]);
}

console.log(countMax2([1, 4, 5, 3]));
console.log(countMax2([3, 12, 6, 2, 4]));
```

## 17. 使用两个栈来模拟队列

思路:模拟先入先出的特点，出栈时使用另一个栈来反转原来栈里的内容，已达到先入先出的效果。

```js
function Queue() {
  let s1 = [];
  let s2 = [];
  this.enqueue = function(ele) {
    s1.push(ele);
  };
  this.dequeue = function() {
    if (s2.length == 0 && s1.length == 0) {
      return null;
    }
    if (s2.length == 0) {
      while (s1.length != 0) {
        s2.push(s1.pop());
      }
    }
    // console.log(s2);
    return s2.pop();
  };
  this.show = function() {
    return s1.reverse().concat(s2);
  };
}

let a = new Queue();
a.enqueue(1);
a.enqueue(2);
console.log(a.dequeue());
a.enqueue(1);
a.enqueue(5);
a.dequeue();
console.log(a.show());
```

## 18. 如何遍历一个 dom 树

```js
function traversal(node) {
  //对node的处理
  if (node && node.nodeType === 1) {
    console.log(node.tagName);
  }
  var i = 0,
    childNodes = node.childNodes,
    item;
  for (; i < childNodes.length; i++) {
    item = childNodes[i];
    if (item.nodeType === 1) {
      //递归先序遍历子节点
      traversal(item);
    }
  }
}
```

```js
function traversal(node) {
  const stack = [];
  stack.push(node);
  while (stack.length > 0) {
    const elem = stack.pop();
    if (elem && elem.nodeType === 1) {
      console.log(elem.tagName);

      const children = elem.children;
      const len = children.length;
      for (let i = 0; i < len; i++) {
        stack.push(children[i]);
      }
    }
  }
}
```

## 19. 数组编程题

随机生成一个长度为 10 的整数类型的数组，例如 `[2, 10, 3, 4, 5, 11, 10, 11, 20]`，将其排列成一个新数组，要求新数组形式如下，例如 `[[2, 3, 4, 5], [10, 11], [20]]`。

```js
// 随机生成长度为 10 的整数
let arr = (function randomArray() {
  let arr = [];
  for (let i = 0; i < 10; i++) {
    arr.push(Math.floor(Math.random() * 100));
  }
  return arr;
})();

// 排序
arr.sort((a, b) => a - b);

// 去重
arr = [...new Set(arr)];

// 连续值存一个数组，不连续的单独存一个数组
let resultArr = [],
  newArr = [arr[0]];
// index = 0;
for (let i = 1; i < arr.length; i++) {
  if (arr[i] == arr[i - 1] + 1) {
    newArr.push(arr[i]);
  } else {
    resultArr.push(newArr);
    newArr = [arr[i]];
    // index++;
  }
}

console.log(arr); // [36, 37, 44, 50, 57, 61, 62, 78, 79]
console.log(resultArr); // [[36, 37], [44], [50], [57], [61, 62]]
```

```js
// 得到一个两数之间的随机整数，包括两个数在内
function getRandomIntInclusive(min, max) {
  min = Math.ceil(min);
  max = Math.floor(max);
  return Math.floor(Math.random() * (max - min + 1)) + min; //含最大值，含最小值
}
// 随机生成10个整数数组, 排序, 去重
let initArr = Array.from({ length: 10 }, v => {
  return getRandomIntInclusive(0, 99);
});
initArr.sort((a, b) => {
  return a - b;
});
initArr = [...new Set(initArr)];

// 放入hash表
let obj = {};
initArr.map(i => {
  const intNum = Math.floor(i / 10);
  if (!obj[intNum]) obj[intNum] = [];
  obj[intNum].push(i);
});

// 输出结果
const resArr = [];
for (let i in obj) {
  resArr.push(obj[i]);
}
console.log(resArr);
```

## 20. 请写一个函数，完成以下功能

> 输入 `'1, 2, 3, 5, 7, 8, 10'` 输出 `'1~3, 5, 7~8, 10'`

这道题的意思是：如果连续数字的话，就取连续的第一个数和最后一个数，中间用~隔开。如果不连续就用，隔开。

```js
const nums1 = [1, 2, 3, 5, 7, 8, 10];
function simplifyStr(num) {
  var result = [];
  var temp = num[0];
  num.forEach((value, index) => {
    if (value + 1 !== num[index + 1]) {
      if (temp !== value) {
        result.push(`${temp}~${value}`);
      } else {
        result.push(`${value}`);
      }
      temp = num[index + 1];
    }
  });
  return result;
}
console.log(simplifyStr(nums1).join(","));
```

## 21. 实现一个字符串匹配算法，从长度为 n 的字符串 S 中，查找是否存在字符串 T，T 的长度是 m，若存在返回所在位置。

```js
const find = (S, T) => {
  if (S.length < T.length) return -1;
  for (let i = 0; i < S.length; i++) {
    if (S.slice(i, i + T.length) === T) return i;
  }
  return -1;
};
```

```js
// 因为 T 的 length 是一定的，所以在循环S的的时候 ，循环当前项 i 后面至少还有 T.length 个元素
const find = (S, T) => {
  if (S.length < T.length) return -1;
  for (let i = 0; i < S.length - T.length; i++) {
    if (S.substr(i, T.length) === T) return i;
  }
  return -1;
};
```

```js
// 方法一：
const find = (S, T) => S.search(T);

// 方法二：
const find = (S, T) => {
  const matched = S.match(T);
  return matched ? matched.index : -1;
};
```

## 22. 旋转数组

> 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。

示例 1：

```js
输入: [1, 2, 3, 4, 5, 6, 7] 和 k = 3
输出: [5, 6, 7, 1, 2, 3, 4]
解释:
向右旋转 1 步: [7, 1, 2, 3, 4, 5, 6]
向右旋转 2 步: [6, 7, 1, 2, 3, 4, 5]
向右旋转 3 步: [5, 6, 7, 1, 2, 3, 4]
```

示例 2：

```js
输入: [-1, -100, 3, 99] 和 k = 2
输出: [3, 99, -1, -100]
解释:
向右旋转 1 步: [99, -1, -100, 3]
向右旋转 2 步: [3, 99, -1, -100]
```

解答：

```js
// 因为步数有可能大于数组长度，所以要先取余
function rotate(arr, k) {
  const len = arr.length;
  const step = k % len;
  return arr.slice(-step).concat(arr.slice(0, len - step));
}
rotate([1, 2, 3, 4, 5, 6], 7); // => [6, 1, 2, 3, 4, 5]
```

## 23. 打印出 1 - 10000 之间的所有对称数

> 例如：121、1331 等

```js
[...Array(10000).keys()].filter(x => {
  return (
    x.toString().length > 1 &&
    x ===
      Number(
        x
          .toString()
          .split("")
          .reverse()
          .join("")
      )
  );
});
```

```js
// 正则
[...Array(10000).keys()].filter(v => {
  return v === Number((String(v).match(/(^\d)(\d)?\2*\1$/) || [])[0]);
});

// 精简一下;
[...Array(10000).keys()].filter(v => {
  return (String(v).match(/(^\d)(\d)?\2*\1$/) || [])[0];
});

// 再精简一下;
[...Array(1e4).keys()].filter(v => (v + "").match(/(^\d)(\d)?\2*\1$/));
```

```js
[...Array(10000).keys()].filter(
  i => i > 10 && i == [...(i + "")].reverse().join("")
);
```

## 24. 算法题之「移动零」

给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

示例:

```js
输入: [0, 1, 0, 3, 12];
输出: [1, 3, 12, 0, 0];
```

说明:

1. 必须在原数组上操作，不能拷贝额外的数组。
2. 尽量减少操作次数。

```js
function zeroMove(array) {
  let len = array.length;
  let j = 0;
  for (let i = 0; i < len - j; i++) {
    if (array[i] === 0) {
      array.push(0);
      array.splice(i, 1);
      i--;
      j++;
    }
  }
  return array;
}
```

最优解法

```js
function moveZeroToLast(arr) {
  let index = 0;
  for (let i = 0, length = arr.length; i < length; i++) {
    if (arr[i] === 0) {
      index++;
    } else if (index !== 0) {
      arr[i - index] = arr[i];
      arr[i] = 0;
    }
  }
  return arr;
}
```

```js
// 双指针
function displacement(arr) {
  let i = 0;
  for (let j = 0, len = arr.length; j < len; j++) {
    if (arr[j] !== 0) {
      [arr[i], arr[j]] = [arr[j], arr[i]];
      i++;
    }
  }
  return arr;
}
```

```js
// 复杂度为O(n).应该是最低的了
let arr = [0, 1, 0, 0, 12, 0, 0, 1, 0, 0];

function moveZero(arr) {
  let i = 0;
  let k = 0;
  let j = arr.length - 1;
  while (k < arr.length - 1) {
    if (arr[i] == 0) {
      arr.push(arr[i]);
      arr.splice(i, 1);
      j--;
    } else {
      i++;
    }
    k++;
  }
  return arr;
}

console.log(moveZero(arr));
```

## 25. 实现 convert 方法，把原始 list 转换成树形结构，要求尽可能降低时间复杂度

以下数据结构中，id 代表部门编号，name 是部门名称，parentId 是父部门编号，为 0 代表一级部门，现在要求实现一个 convert 方法，把原始 list 转换成树形结构，parentId 为多少就挂载在该 id 的属性 children 数组下，结构如下：

```js
// 原始 list 如下
let list =[
    {id:1,name:'部门A',parentId:0},
    {id:2,name:'部门B',parentId:0},
    {id:3,name:'部门C',parentId:1},
    {id:4,name:'部门D',parentId:1},
    {id:5,name:'部门E',parentId:2},
    {id:6,name:'部门F',parentId:3},
    {id:7,name:'部门G',parentId:2},
    {id:8,name:'部门H',parentId:4}
];
const result = convert(list, ...);

// 转换后的结果如下
let result = [
    {
      id: 1,
      name: '部门A',
      parentId: 0,
      children: [
        {
          id: 3,
          name: '部门C',
          parentId: 1,
          children: [
            {
              id: 6,
              name: '部门F',
              parentId: 3
            }, {
              id: 16,
              name: '部门L',
              parentId: 3
            }
          ]
        },
        {
          id: 4,
          name: '部门D',
          parentId: 1,
          children: [
            {
              id: 8,
              name: '部门H',
              parentId: 4
            }
          ]
        }
      ]
    },
  ···
];
```

```js
function convert(list) {
  const res = [];
  const map = list.reduce((res, v) => ((res[v.id] = v), res), {});
  for (const item of list) {
    if (item.parentId === 0) {
      res.push(item);
      continue;
    }
    if (item.parentId in map) {
      const parent = map[item.parentId];
      parent.children = parent.children || [];
      parent.children.push(item);
    }
  }
  return res;
}
```

```js
function convert(arr) {
  const obj = {};
  const res = [];
  list.forEach(item => {
    obj[item.id] = item;
  });
  list.forEach(item => {
    if (item.parentId !== 0) {
      obj[item.parentId]["children"]
        ? obj[item.parentId]["children"].push(item)
        : (obj[item.parentId]["children"] = [item]);
    } else {
      res.push(item);
    }
  });
  return res;
}
```

```js
let list = [
  { id: 1, name: "部门A", parentId: 0 },
  { id: 2, name: "部门B", parentId: 0 },
  { id: 3, name: "部门C", parentId: 1 },
  { id: 4, name: "部门D", parentId: 1 },
  { id: 5, name: "部门E", parentId: 2 },
  { id: 6, name: "部门F", parentId: 3 },
  { id: 7, name: "部门G", parentId: 2 },
  { id: 8, name: "部门H", parentId: 4 }
];
function convert(array) {
  let reslutArray = array.filter(item => {
    let children = array.filter(child => {
      return item.id === child.parentId;
    });
    item.children = children;
    return item.parentId === 0;
  });
  return reslutArray;
}
let res = convert(list);
console.log(res);
```

```js
// 基于DFS来写
function convert(source, parentId = 0) {
  let trees = [];
  for (let item of source) {
    if (item.parentId === parentId) {
      let children = convert(source, item["id"]);
      if (children.length) {
        item.children = children;
      }
      trees.push(item);
    }
  }
  return trees;
}

let list = [
  { id: 1, name: "部门A", parentId: 0 },
  { id: 2, name: "部门B", parentId: 0 },
  { id: 3, name: "部门C", parentId: 1 },
  { id: 4, name: "部门D", parentId: 1 },
  { id: 5, name: "部门E", parentId: 2 },
  { id: 6, name: "部门F", parentId: 3 },
  { id: 7, name: "部门G", parentId: 2 },
  { id: 8, name: "部门H", parentId: 4 }
];

const result = convert(list);
```

## 26. 编程题，写个程序把 entry 转换成如下对象

```js
var entry = {
  a: {
    b: {
      c: {
        dd: "abcdd"
      }
    },
    d: {
      xx: "adxx"
    },
    e: "ae"
  }
};

// 要求转换成如下对象
var output = {
  "a.b.c.dd": "abcdd",
  "a.d.xx": "adxx",
  "a.e": "ae"
};
```

```js
function flatObj(obj, parentKey = "", result = {}) {
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      let keyName = `${parentKey}${key}`;
      if (typeof obj[key] === "object")
        flatObj(obj[key], keyName + ".", result);
      else result[keyName] = obj[key];
    }
  }
  return result;
}
```

```js
function loop(entry, key = "", result = {}) {
  const obj = Object.keys(entry);
  for (let i = 0; i < obj.length; i++) {
    const keyName = key + obj[i];
    if (typeof entry[obj[i]] === "object") {
      this.loop(entry[obj[i]], `${keyName}.`, result);
    } else {
      result[keyName] = entry[obj[i]];
    }
  }
  return result;
}
```

## 27. 编程题，写个程序把 entry 转换成如下对象（与上个题目相反）

```js
var entry = {
  "a.b.c.dd": "abcdd",
  "a.d.xx": "adxx",
  "a.e": "ae"
};

// 要求转换成如下对象
var output = {
  a: {
    b: {
      c: {
        dd: "abcdd"
      }
    },
    d: {
      xx: "adxx"
    },
    e: "ae"
  }
};
```

```js
var entry = {
  "a.b.c.dd": "abcdd",
  "a.d.xx": "adxx",
  "a.e": "ae"
};

function map(entry) {
  const obj = Object.create(null);
  for (const key in entry) {
    const keymap = key.split(".");
    set(obj, keymap, entry[key]);
  }
  return obj;
}

function set(obj, map, val) {
  let tmp;
  if (!obj[map[0]]) obj[map[0]] = Object.create(null);
  tmp = obj[map[0]];
  for (let i = 1; i < map.length; i++) {
    if (!tmp[map[i]])
      tmp[map[i]] = map.length - 1 === i ? val : Object.create(null);
    tmp = tmp[map[i]];
  }
}
console.log(map(entry));
```

**实现思路**  
遍历对象，如果键名称含有 `.` 将最后一个子键拿出来，构成对象，如 `{'a.b.c.dd': 'abcdd'}`变为 `{'a.b.c': { dd: 'abcdd' }}` , 如果变换后的新父键名中仍还有点，递归进行以上操作即可。

```js
function nested(obj) {
  Object.keys(obj).map(k => {
    getNested(k);
  });

  return obj;

  function getNested(key) {
    const idx = key.lastIndexOf(".");
    const value = obj[key];
    if (idx !== -1) {
      delete obj[key];
      const mainKey = key.substring(0, idx);
      const subKey = key.substr(idx + 1);
      if (obj[mainKey] === undefined) {
        obj[mainKey] = { [subKey]: value };
      } else {
        obj[mainKey][subKey] = value;
      }
      if (/\./.test(mainKey)) {
        getNested(mainKey);
      }
    }
  }
}

console.log(JSON.stringify(nested(entry), 0, 2));
```

## 28. 编程题，根据以下要求，写一个数组去重函数（蘑菇街）

> 1. 如传入的数组元素为[123, "meili", "123", "mogu", 123]，则输出：[123, "meili", "123", "mogu"]
> 2. 如传入的数组元素为[123, [1, 2, 3], [1, "2", 3], [1, 2, 3], "meili"]，则输出：[123, [1, 2, 3], [1, "2", 3], "meili"]
> 3. 如传入的数组元素为[123, {a: 1}, {a: {b: 1}}, {a: "1"}, {a: {b: 1}}, "meili"]，则输出：[123, {a: 1}, {a: {b: 1}}, {a: "1"}, "meili"]

没有考虑到数据类型为 null,undefind 等类型 包括数据为对象时 key 顺序不同的问题

```js
// 判断对象
function isObj(obj) {
  return Object.prototype.toString.call(obj) === "[object Object]";
}
// 对象重整 对key进行排序
function parseObj(obj) {
  let keys = Object.keys(obj).sort();
  let newObj = {};
  for (let key of keys) {
    // 不晓得有没有有必要，反正把value为obj的情况也处理一下 - -
    obj[key] = isObj(obj[key]) ? parseObj(obj[key]) : obj[key];
    newObj[key] = obj[key];
  }
  return newObj;
}

// 最后
const arr = [
  1,
  "1",
  { a: 1, b: "1" },
  { b: "1", a: 1 },
  { a: 1, b: 2 },
  [1, 2, 3],
  null,
  undefined,
  undefined
];

function passArr(arr) {
  return [
    ...new Set(
      arr.map(item =>
        isObj(item)
          ? JSON.stringify(parseObj(item))
          : !item
          ? item
          : JSON.stringify(item)
      )
    )
  ].map(item => (!item ? item : JSON.parse(item)));
}
```

```js
function unique(arr) {
  const result = [];
  const isArray = Array.isArray;
  for (let v of arr) {
    result.every(e => !equal(v, e)) && result.push(v);
  }
  return result;

  function equal(a, b) {
    if (a && b && typeof a === "object" && typeof b === "object") {
      return (
        isArray(a) === isArray(b) &&
        (isArray(a)
          ? a.length === b.length && a.every((e, i) => equal(e, b[i]))
          : Object.keys(a).length === Object.keys(b).length &&
            Object.keys(a).every(k => equal(a[k], b[k])))
      );
    } else {
      return a === b;
    }
  }
}
```

## 29. 编程题，找出字符串中连续出现最多的字符和个数（蘑菇街）

```js
'abcaakjbb' => {'a':2,'b':2}
'abbkejsbcccwqaa' => {'c':3}
```

```js
const arr = str.match(/(\w)\1*/g);
const maxLen = Math.max(...arr.map(s => s.length));
const result = arr.reduce((pre, curr) => {
  if (curr.length === maxLen) {
    pre[curr[0]] = curr.length;
  }
  return pre;
}, {});

console.log(result);
```

## 30. 写一个单向链数据结构的 js 实现并标注复杂度（水滴筹）

```js
class LinkList {
  constructor() {
    this.head = null;
  }

  find(value) {
    let curNode = this.head;
    while (curNode.value !== value) {
      curNode = curNode.next;
    }
    return curNode;
  }

  findPrev(value) {
    let curNode = this.head;
    while (curNode.next !== null && curNode.next.value !== value) {
      curNode = curNode.next;
    }
    return curNode;
  }

  insert(newValue, value) {
    const newNode = new Node(newValue);
    const curNode = this.find(value);
    newNode.next = curNode.next;
    curNode.next = newNode;
  }

  delete(value) {
    const preNode = this.findPrev(value);
    const curNode = preNode.next;
    preNode.next = preNode.next.next;
    return curNode;
  }
}

class Node {
  constructor(value, next) {
    this.value = value;
    this.next = null;
  }
}
```

## 31. 统计 1 ~ n 整数中出现 1 的次数。

> 例如统计 1 ~ 400W 出现 1 的次数。

```js
function count(n) {
  let res = 0;
  for (let i = 0; i <= n; i += 1) {
    `${i}`.split("").forEach(item => {
      if (item === "1") {
        res += 1;
      }
    });
  }
  return res;
}
console.time("count");
console.log(count(4000000));
console.timeEnd("count");
// 3400000
//count: 589.424ms
```

```js
function countOne(n) {
  var factor = 1;
  let count = 0;
  let next = parseInt(n / factor);
  while (next !== 0) {
    var lower = n - next * factor;
    var curr = next % 10;
    var high = parseInt(n / (10 * factor));

    if (curr === 0) {
      count += high * factor;
    } else if (curr === 1) {
      count += high * factor + lower + 1;
    } else {
      count += (high + 1) * factor;
    }

    factor *= 10;
    next = parseInt(n / factor);
  }
  return count;
}
console.time("count");
console.log(countOne(4000000));
console.timeEnd("count");
// 3400000
// count: 2.363ms
```

## 32. 如何将 [{id: 1}, {id: 2, pId: 1}, ...] 的重复数组（有重复数据）转成树形结构的数组 [{id: 1, child: [{id: 2, pId: 1}]}, ...] （需要去重）

哈希表，时间复杂度 O(n)

```js
const fn = arr => {
  const res = []
  // const map = arr.reduce((res, item) => ((res[item.id] = item), res), {})
  const map = arr.reduce((res, item) => ((res[item.id] = Object.assign({}, item)), res), {}) // 复制一下对象，否则会修改原数组
  for (const item of Object.values(map)) {
    if (!item.pId) {
      res.push(item)
    } else {
      const parent = map[item.pId]
      parent.child = parent.child || []
      parent.child.push(item)
    }
  }
  return res
}

// const arr = [{id: 1}, {id:2, pId: 1}, {id: 3, pId: 2}, {id: 4}, {id:3, pId: 2}, {id: 5, pId: 4}]
// fn(arr) => [{id: 1, child: [{id: 2, pId: 1, child: [{ id: 3, pId: 2}]}]}, {id: 4, child: [{id: 5, pId: 4}]}]
 +1 9 tada 3
```

## 33. 扑克牌问题

有一堆扑克牌，将牌堆第一张放到桌子上，再将接下来的牌堆的第一张放到牌底，如此往复；

最后桌子上的牌顺序为： (牌底) 1,2,3,4,5,6,7,8,9,10,11,12,13 (牌顶)；

问：原来那堆牌的顺序，用函数实现。

```js
function poke(arr) {
  let i = 1;
  let out = [];
  while (arr.length) {
    if (i % 2) {
      out.push(arr.shift());
    } else {
      arr.push(arr.shift());
    }
    i++;
  }
  return out;
}

function reverse(arr) {
  let i = 1;
  let out = [];
  while (arr.length) {
    if (i % 2) {
      out.unshift(arr.pop());
    } else {
      out.unshift(out.pop());
    }
    i++;
  }
  return out;
}

reverse([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]);
// [1, 12, 2, 8, 3, 11, 4, 9, 5, 13, 6, 10, 7]4
```

```js
/**
 * 逆向：即从桌牌到手牌
 * @param {*} 桌牌序列 arr
 */
function recover(arr) {
  const res = [];
  while (arr.length > 0) {
    if (res.length) {
      res.push(res.shift());
    }
    const item = arr.pop();
    res.push(item);
  }
  return res;
}

/**
 * 正向：即从手牌到桌牌（用于检验结果）
 * @param {*} 手牌序列arr
 */
function generate(arr) {
  const res = [];
  while (arr.length > 0) {
    const item = arr.pop();
    res.push(item);
    if (arr.length) {
      arr.unshift(arr.pop());
    }
  }
  return res;
}

recover([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]);
// [7, 10, 6, 13, 5, 9, 4, 11, 3, 8, 2, 12, 1]

generate([7, 10, 6, 13, 5, 9, 4, 11, 3, 8, 2, 12, 1]);
// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]
```

## 34. 算法题

在一个字符串数组中有红、黄、蓝三种颜色的球，且个数不相等、顺序不一致，请为该数组排序。使得排序后数组中球的顺序为:黄、红、蓝。

例如：红蓝蓝黄红黄蓝红红黄红，排序后为：黄黄黄红红红红红蓝蓝蓝。

```js
function sortBalls(str) {
  let arr = str.split("");
  arr.sort((a, b) => {
    return getNumByType(a) - getNumByType(b);
  });

  return arr.join("");

  function getNumByType(type) {
    switch (type) {
      case "黄":
        return 1;
      case "红":
        return 2;
      default:
        return 3;
    }
  }
}
```

```js
const strList = "红蓝蓝黄红黄蓝红红黄红";
const sortRules = { 黄: 0, 红: 1, 蓝: 2 };
const list = [[], [], []];
strList.split("").forEach(item => {
  list[sortRules[item]].push(item);
});
list.reduce((pre, cur) => (pre += cur.join("")), "");
//黄黄黄红红红红红蓝蓝蓝
```

## 35. 反转链表，每 k 个节点反转一次，不足 k 就保持原有顺序

> 例如  
> 链表： 1->2->3->4->5->6->7->8->null, k = 3  
> 那么 6->7->8， 3->4->5，1->2 各为一组，
> 调整后： 1->2->5->4->3->8->7->6->null，其中 1，2 不调整，因为不够一组

```js
let a = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: {
          value: 5,
          next: {
            value: 6,
            next: {
              value: 7,
              next: {
                value: 8,
                next: {}
              }
            }
          }
        }
      }
    }
  }
};
```

```js
// 创建链表
function createLinkList(...args) {
  const res = {};
  let current = res;
  while (args.length) {
    current.value = args.shift();
    current.next = {};
    current = current.next;
  }
  return res;
}

function reverse(linklist, k) {
  const stack = [];
  let current = linklist;
  // 前面k个入栈
  while (current.next && stack.length + 1 <= k) {
    stack.push(current.value);
    current = current.next;
  }
  // 不足k不用反转
  if (stack.length < k) {
    return linklist;
  }
  // 出栈+拼接current节点再递归
  let temp = {};
  const ret = stack.reduceRight(
    (res, cur) => ((temp.value = cur), (temp = temp.next = {}), res),
    temp
  );
  current && current.next && Object.assign(temp, reverse(current, k));
  return ret;
}

reverse(createLinkList(1, 2, 3, 4, 5, 6, 7, 8), 3);
```

```js
/**
 * 反转链表，每 k 个节点反转一次，不足 k 就保持原有顺序
 */

interface ListItem {
  next: ListItem | null;
  value: any;
}

interface group {
  head: ListItem;
  tail: ListItem;
}

function reverseEveryKItems(head: ListItem, k: number): ListItem {
  let headTmp: ListItem = head;
  let groupHeads: Array<ListItem> = [];
  let count = 1;
  groupHeads.push(headTmp);

  // 对列表分组
  while (headTmp.next) {
    count = count + 1;
    if (count === k) {
      groupHeads.push(headTmp.next);
      count = 0;
    }
    headTmp = headTmp.next;
  }

  let lastGroupHead: ListItem;
  // 不满K个节点的不反转
  if (count !== 0) {
    lastGroupHead = groupHeads.pop();
  }

  // 每K个节点置换，保存head，tail
  const groups: Array<group> = groupHeads.map(groupHead =>
    reverseGroupList(groupHead, k)
  );

  // 将每个反转后的组前尾后头连起来
  let reverseHead: ListItem = groups[0].head;
  for (let i = 1; i < groups.length; i++) {
    let preTail = groups[i - 1].tail;
    let curHead = groups[i].head;
    preTail.next = curHead;
  }

  groups[-1].tail.next = lastGroupHead || null;

  return reverseHead;
}

/* 每K个列表反转 */
function reverseGroupList(head: ListItem, k: number): group {
  let pre: ListItem = head;
  let cur: ListItem = head.next;

  while (cur && k--) {
    let next: ListItem = cur.next;
    cur.next = pre;
    pre = cur;
    cur = next;
  }

  return {
    head: cur,
    tail: head
  };
}
```

<br/>
<br/>

大致思路：

- 遍历链表，将每个元素添加到一个栈中
- 判断栈的长度，达到指定长度后，出栈，即可反转
- 若最后一次栈的长度没有达到指定长度，则将这个栈当作队列操作，直接出队

实现如下：

```js
class Node {
  constructor(value) {
    this.value = value;
    this.next = null;
  }

  print() {
    let pointer = this;
    let result = "";
    while (pointer) {
      result += pointer.value + ">";
      pointer = pointer.next;
    }
    console.log(result.substring(0, result.length - 1));
  }
}

function reverseLinkedListByk(linkedList, k) {
  if (!linkedList) {
    return null;
  }
  if (k < 1) {
    return linkedList;
  }
  const stack = [];
  let resultHead = null;
  let resultPointer = null;
  let traversePointer = linkedList;
  while (traversePointer) {
    const copy = traversePointer;
    traversePointer = traversePointer.next;
    copy.next = null;
    stack.push(copy);
    if (stack.length == k) {
      while (stack.length) {
        const node = stack.pop();
        if (!resultHead) {
          resultHead = resultPointer = node;
        } else {
          resultPointer.next = node;
          resultPointer = resultPointer.next;
        }
      }
    }
  }
  if (stack.length && stack.length < k) {
    while (stack.length) {
      const node = stack.shift();
      resultPointer.next = node;
      resultPointer = resultPointer.next;
    }
  }
  return resultHead;
}

const linkedList = new Node(5);
n1 = new Node(8);
n2 = new Node(3);
n3 = new Node(6);
n4 = new Node(9);
n5 = new Node(1);
n6 = new Node(10);
n7 = new Node(39);
linkedList.next = n1;
n1.next = n2;
n2.next = n3;
n3.next = n4;
n4.next = n5;
n5.next = n6;
n6.next = n7;
linkedList.print();
console.log("----------");
let reversed = reverseLinkedListByk(linkedList, 3);
reversed.print();

// 5>8>3>6>9>1>10>39
// ----------
// 3>8>5>1>9>6>10>39
```

## 36. 求多个数组之间的交集

```js
let a = new Set([1, 2, 3]);
let b = new Set([4, 3, 2]);
let intersect = new Set([...a].filter(x => b.has(x)));
// set {2, 3}
```

```js
function intersect(...args) {
  if (args.length === 0) {
    return [];
  }

  if (args.length === 1) {
    return args[0];
  }

  return args.reduce((result, arg) => {
    return result.filter(item => arg.includes(item));
  });
}
```

```js
let getMix = arr => {
  return arr.reduce((total, item, index) => {
    if (index === 0) {
      return [...total, ...item];
    } else {
      return total.filter(v => item.includes(v));
    }
  }, []);
};

getMix([[1], [1, 2], [1, 3]]); //[1]
```

```js
const arr1 = [1, 2, 3];
const arr2 = [3, 4, 5];
const arr3 = [3, 6, 7];
const handle = (...arr) => {
  return arr.reduce((rst, ele, i) => {
    return rst.filter(item => ele.includes(item));
  });
};

handle(arr1, arr2, arr3);
```

## 37. 将'10000000000'形式的字符串，以每 3 位进行分隔展示'10.000.000.000',多种实现方式

```js
// 德国以 . 分割金钱, 转到德国当地格式化方案即可
(10000000000).toLocaleString("de-DE");

// 寻找字符空隙加 .
"10000000000".replace(/\B(?=(\d{3})+(?!\d))/g, ".");

// 寻找数字并在其后面加 .
"10000000000".replace(/(\d)(?=(\d{3})+\b)/g, "$1.");
```

```js
str
  .split("")
  .reverse()
  .reduce((prev, cur, index) =>
    (index + 1) % 3 == 0 ? "." + cur + prev : cur + prev
  );
```

## 38. 写一个格式化金额的方法

**普通版**

```js
function formatNumber(str) {
  let arr = [],
    count = str.length;

  while (count >= 3) {
    arr.unshift(str.slice(count - 3, count));
    count -= 3;
  }

  // 如果是不是3的倍数就另外追加到上去
  str.length % 3 && arr.unshift(str.slice(0, str.length % 3));

  return arr.toString();
}
console.log(formatNumber("1234567890")); // 1,234,567,890
```

- 优点：自我感觉比网上写的一堆 for 循环 还有 if-else 判断的逻辑更加清晰直白。
- 缺点：太普通

**进阶版**

```js
function formatNumber(str) {
  // ["0", "9", "8", "7", "6", "5", "4", "3", "2", "1"]
  return str
    .split("")
    .reverse()
    .reduce((prev, next, index) => {
      return (index % 3 ? next : next + ",") + prev;
    });
}

console.log(formatNumber("1234567890")); // 1,234,567,890
```

- 优点：把 JS 的 API 玩的了如指掌
- 缺点：可能没那么好懂，不过读懂之后就会发出我怎么没想到的感觉

**正则版**

```js
function formatNumber(str) {
  return str.replace(/\B(?=(\d{3})+(?!\d))/g, ",");
}

console.log(formatNumber("123456789")); // 1,234,567,890
```

下面简单分析下正则`/\B(?=(\d{3})+(?!\d))/g`：

> 1.  /\B(?=(\d{3})+(?!\d))/g：正则匹配边界\B，边界后面必须跟着(\d{3})+(?!\d);
> 2.  (\d{3})+：必须是 1 个或多个的 3 个连续数字;
> 3.  (?!\d)：第 2 步中的 3 个数字不允许后面跟着数字;
> 4.  (\d{3})+(?!\d)：所以匹配的边界后面必须跟着 3\*n（n>=1）的数字。

最终把匹配到的所有边界换成,即可达成目标。

优点：代码少，浓缩的就是精华
缺点：需要对正则表达式的位置匹配有一个较深的认识，门槛大一点

**API 版**

```js
(1234567890).toLocaleString("en-US"); // 1,234,567,890
```

还可以使用 Intl 对象 - MDN

> Intl 对象是 ECMAScript 国际化 API 的一个命名空间，它提供了精确的字符串对比，数字格式化，日期和时间格式化。Collator，NumberFormat 和 DateTimeFormat 对象的构造函数是 Intl 对象的属性。

```js
new Intl.NumberFormat().format(1234567890); // 1,234,567,890
```

- 优点：简单粗暴，直接调用 API
- 缺点：Intl 兼容性不太好，不过 toLocaleString 的话 IE6 都支持

## 39. 用 js 实现一个九九乘法口诀表

```js
const MAX_WIDTH = 7;
let table = "";
for (let rhs = 1; rhs <= 9; rhs++) {
  for (let lhs = 1; lhs <= 9; lhs++) {
    if (lhs <= rhs) table += `${lhs}*${rhs}=${lhs * rhs}`.padEnd(MAX_WIDTH);
  }
  table += "\n";
}
console.log(table);
```

```js
function row(num) {
  const numMap = {
    1: "一",
    2: "二",
    3: "三",
    4: "四",
    5: "五",
    6: "六",
    7: "七",
    8: "八",
    9: "九"
  };

  return new Array(num)
    .fill(0)
    .map((val, idx) => {
      const n = idx + 1;
      const res = n * num;
      const resStr =
        res > 9
          ? numMap[String(res)[0]] + "十" + (numMap[String(res)[1]] || "")
          : numMap[res];
      return `${numMap[n]}${numMap[num]}${res < 10 ? "得" : ""}${resStr}`;
    })
    .join("\t");
}

const table = new Array(9)
  .fill(0)
  .map((val, idx) => row(idx + 1))
  .join("\n");

console.log(table);
```

```js
一一得一
一二得二        二二得四
一三得三        二三得六        三三得九
一四得四        二四得八        三四一十二      四四一十六
一五得五        二五一十        三五一十五      四五二十        五五二十五
一六得六        二六一十二      三六一十八      四六二十四      五六三十        六六三十六
一七得七        二七一十四      三七二十一      四七二十八      五七三十五      六七四十二      七七四十九
一八得八        二八一十六      三八二十四      四八三十二      五八四十        六八四十八      七八五十六      八八六十四
一九得九        二九一十八      三九二十七      四九三十六      五九四十五      六九五十四      七九六十三      八九七十二      九九八十一
```

```js
function ninenine() {
  let ret = "";
  for (let i = 1; i <= 9; i++) {
    for (let j = 1; j <= i; j++) {
      ret += `${j} × ${i} = ${j * i}  `;
    }
    ret += `\t\n`;
  }
  console.log(ret);
}
ninenine();
```

## 40. 分别封装精确运算的加减乘除四个方法

```js
function isObject(obj) {
  return Object.prototype.toString.call(obj) === "[object Object]";
}

/**
 * 专门处理数字运算
 * 并解决，1. 非数字型数字的运算 2. 小数计算的精度问题
 * count('+', 0.1, '0.2'); // 0.3
 */
function count(type, options) {
  var nums = [].slice.call(arguments, 2);
  var _startConfig = { "+": 0, "-": 0, "*": 1, "/": 1 };
  if (!(type in _startConfig)) return new Error("首位入参有误");

  // 可能往后会加入些配置，但如果不是对象则不是配置
  if (!isObject(options)) {
    nums.splice(0, 0, options);
  }

  // 小数点后面最长字符长度，比如 0.1 和 0.234 则返回 3
  var maxDotLength = nums.reduce(function(max, num) {
    return Math.max(max, ([num].toString().split(".")[1] || "").length);
  }, 0);

  // 改造成整数，并计算出结果，比如 0.1 + 0.2 改为 1+2
  var startNum = _startConfig[type];
  var pow = Math.pow(10, maxDotLength);
  var result = nums.reduce(function(re, num, index) {
    num = Number(num) * pow;
    if (type === "-" && index === 0) return num;
    switch (type) {
      case "-":
        return re - num;
      case "*":
        return re * num;
      case "/":
        return re / num;
      case "+":
      default:
        return re + num;
    }
  }, startNum);

  // 回退到原小数形态，比如 3 转为 0.3
  var _divideConfig = { "+": pow, "-": pow, "*": pow * pow, "/": 1 };
  result = result / _divideConfig[type];

  return result;
}
```

## 41. 请用 js 编写一个红绿灯程序

咋一看题目我还以为是设计十字路口红路灯算法那种，那可是有点复杂 smile ；看了上面的才知道原来是循环显示红绿灯……

```js
function sleep(t) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve();
    }, t);
  });
}

/**
 * 循环显示红绿灯
 * @param {number} green 绿灯显示毫秒数
 * @param {number} yellow 黄灯显示毫秒数
 * @param {number} red 红灯显示毫秒数
 */
async function light(green = 15000, yellow = 3000, red = 10000) {
  let status = "green";
  while (true) {
    await sleep(green).then(() => {
      status = "yellow";
      console.log(status);
    });
    await sleep(yellow).then(() => {
      status = "red";
      console.log(status);
    });
    await sleep(red).then(() => {
      status = "green";
      console.log(status);
    });
  }
}

light(3000, 1000, 1000);
```

```js
function ryg(color, duration) {
  return new Promise(function(resolve) {
    setTimeout(resolve.bind(this, color), duration);
  });
}

async function run() {
  let light;
  while (true) {
    light = await ryg("red", 1000);
    console.log(light);
    light = await ryg("yellow", 2000);
    console.log(light);
    light = await ryg("green", 200);
    console.log(light);
  }
}
run();
```

## 42. 写一个把数字转成中文的方法，例如：101 转成一百零一

```js
/*
 * @param {Number} 数字
 * @return {String} 中文数字
 *
 */
var arg = process.argv.slice(2)[0] + ""; //node命令参数

console.log(CN_Number(arg));

function CN_Number(num) {
  let str = num + "";
  let arr = [];
  let res = [];
  for (let i = str.length - 1; i >= 0; i -= 4) {
    arr.unshift(str.slice(i - 4, i));
  }
  while (arr.length) {
    res.unshift(arr.splice(-3, 3));
  }

  let block = ["亿", "万", ""];
  res = res.map(item => {
    if (item.length < 3) item.unshift("");
    return item.map((n, index) => {
      let res = cn_fy(n);
      res += res ? block[index] : "";
      return res;
    });
  });
  let cn_res = "";
  res.forEach(a => {
    a.forEach(b => {
      cn_res += b;
    });
  });
  return cn_res;
  function cn_fy(n) {
    let unit = ["千", "百", "十"];
    let nums = ["零", "一", "二", "三", "四", "五", "六", "七", "八", "九"];
    let res = "";
    for (let i = 0; i < n.length; ++i) {
      if (n[i] == 0) res += "零";
      else res += nums[n[i]] + (unit[i] || "");
    }
    while (res[0] === "零") {
      res = res.substring(1);
    } //去左零
    while (res[res.length - 1] === "零") {
      res = res.substring(0, res.length - 1);
    } //去右零
    while (res.indexOf("零零") > -1) {
      res = res.replace("零", "");
    } //去连续零
    return res;
  }
}
```

## 43. 写一个方法，将字符串中的单词倒转后输出，如：my love -> ym evol

```js
let b = "my love";
function fn(b) {
  return b
    .split(" ")
    .map(val =>
      val
        .split("")
        .reverse()
        .join("")
    )
    .join(" ");
}
console.log(fn(b)); //ym evol
```

```js
let wordReversal = str =>
  str
    .split(" ")
    .map(e =>
      e
        .split("")
        .reverse()
        .join("")
    )
    .join(" ");
```

## 44. 用 js 实现小写金额转大写的方法

```js
var price = "3452,132.567";
console.log(changePrice(price));

function changePrice(price) {
  var decimal = price.split(".");
  var nums = decimal[0].split(",");
  var resAry = [];
  var str = "";
  resAry.push(strChange(decimal[1], 0));
  for (var j = nums.length - 1, n = 0, k = 0; j >= 0; j--, k += 3, n++) {
    resAry.unshift(strChange(nums[j], k + 3));
  }
  for (var i = 0; i < resAry.length; i++) {
    str += resAry[i];
  }
  return str;
}
function strChange(ary, j) {
  var decimalAry = [
    "厘",
    "分",
    "角",
    "元",
    "拾",
    "佰",
    "仟",
    "万",
    "拾",
    "佰",
    "仟",
    "亿"
  ];
  var numAry = ["零", "壹", "贰", "叁", "肆", "伍", "陆", "柒", "捌", "玖"];
  var str = [];
  var str2 = "";
  if (j == 0) {
    for (var m = 0; m < ary.length; m++) {
      str2 += numAry[ary[m]] + decimalAry[2 - j++];
    }
  } else {
    for (var i = ary.length - 1, n = 0; i >= 0; i--, n++) {
      var item = ary[i];
      str.unshift(numAry[item] + decimalAry[j++]);
    }
    for (var m = 0; m < str.length; m++) {
      str2 += str[m];
    }
  }

  return str2;
}
```

## 45. 写个给图片加水印的方法

```js
/**
 *
 * @param {*} image 图片 img对象
 * @param {*} words 水印内容
 */
export default function(image, words) {
  const { canvas, context } = getCanvas();
  let width = image.width;
  let height = image.height;
  canvas.width = width;
  canvas.height = height;
  canvas.style.width = image.style.width;
  canvas.style.height = image.style.height;

  context.drawImage(image, 0, 0);

  // 重复绘制内容贴图
  const mark = getMark(words);
  for (let i = 0; i < width; i += 250) {
    for (let j = 0; j < height; j += 250) {
      context.drawImage(mark, i, j);
    }
  }
  return toImage(canvas);
}

function toImage(canvas) {
  var image = new Image();
  image.src = canvas.toDataURL("image/png");
  return image;
}

// 构造内容
function getMark(content = "") {
  const { canvas, context } = getCanvas();
  canvas.width = 200;
  canvas.height = 200;
  context.translate(100, 100);
  context.rotate((45 * Math.PI) / 180);
  context.font = "30px 微软雅黑";
  context.textAlign = "center";
  // 隐形水印, 肉眼不可见,图片被人下载后可用ps查看
  // content 一般是登录的信息，用以内部截图外泄后查清截图人身份用
  context.fillStyle = "rgba(220,20,60, 0.005)";

  const words = content.split("\n"); // 以\n为换行
  const lines = words.length;
  const fontHeight = context.measureText("田").width * 1.1;
  const wordsHeight = fontHeight * lines;
  const start = -wordsHeight / 2;
  for (let i = 0; i < lines; i++) {
    context.fillText(words[i], 0, start + i * fontHeight);
  }
  return canvas;
}

function getCanvas() {
  const canvas = document.createElement("canvas");
  return {
    canvas,
    context: canvas.getContext("2d")
  };
}
```

情况一：水印是图片（两张图片 canvas.drawImage 两次重叠即可）

```html
<input type="file" id="uploadFile" class="clip" accept="image/*" />
<label class="ui-button ui-button-primary" for="uploadFile">选择图片</label>
<img id="imgCover" src="./watermark.png" class="clip" />
<p id="imgUploadX"></p>
```

```js
var eleUploadFile = document.getElementById("uploadFile");
var eleImgCover = document.getElementById("imgCover");
var eleImgUploadX = document.getElementById("imgUploadX");

if (history.pushState) {
  eleUploadFile.addEventListener("change", function(event) {
    var reader = new FileReader();
    var file = event.target.files[0] || event.dataTransfer.files[0];

    reader.onload = function(e) {
      var base64 = e.target.result;
      if (base64.length > 1024 * 500) {
        alert("图片尺寸请小于500K");
        return;
      } else {
        // 使用canvas合成图片，并base64化
        imgTogether(base64, function(url) {
          // 尺寸
          var size = 180 / (window.devicePixelRatio || 1);
          // 预览
          eleImgUploadX.innerHTML =
            '<img src="' +
            url +
            '" width="' +
            size +
            '" height="' +
            size +
            '">';
        });
      }
    };

    reader.readAsDataURL(file);
  });

  // canvas图片合成
  var imgTogether = function(url, callback) {
    var canvas = document.createElement("canvas");
    var size = 180;
    canvas.width = size;
    canvas.height = size;

    var context = canvas.getContext("2d");

    // 这是上传图像
    var imgUpload = new Image();
    imgUpload.onload = function() {
      // 绘制
      context.drawImage(imgUpload, 0, 0, size, size, 0, 0, size, size);
      // 再次绘制
      context.drawImage(eleImgCover, 0, 0, size, size, 0, 0, size, size);
      // 回调
      callback(canvas.toDataURL("image/png"));
    };
    imgUpload.src = url;
  };
} else if (eleImgUploadX) {
  eleImgUploadX.className = "remind";
  eleImgUploadX.innerHTML = "本演示IE10+下才有效果";
}
```

情况二：水印是纯文字

```css
#wrap {
  display: inline-block;
}
```

```html
<div id="wrap">
  <img src="http://placekitten.com/600/600" id="xxx" />
</div>
<script src="js/app.js"></script>
```

```js
(function() {
  // canvas 实现 watermark
  function __canvasWM({
    // 使用 ES6 的函数默认值方式设置参数的默认取值
    // 具体参见 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Default_parameters
    container = document.body,
    image,
    width = "200px",
    height = "150px",
    textAlign = "center",
    textBaseline = "middle",
    font = "20px microsoft yahei",
    fillStyle = "rgba(184, 184, 184, 0.8)",
    content = "请勿外传",
    rotate = "30",
    zIndex = 1000
  } = {}) {
    var args = arguments[0];
    var canvas = document.createElement("canvas");

    canvas.setAttribute("width", image.width);
    canvas.setAttribute("height", image.height);
    var ctx = canvas.getContext("2d");

    ctx.textAlign = textAlign;
    ctx.textBaseline = textBaseline;
    ctx.font = font;
    ctx.fillStyle = fillStyle;
    ctx.rotate((Math.PI / 180) * rotate);
    ctx.fillText(
      content,
      parseFloat(image.width) / 2,
      parseFloat(image.height) / 2
    );

    var base64Url = canvas.toDataURL();
    const watermarkDiv = document.createElement("div");
    watermarkDiv.setAttribute(
      "style",
      `
        position:absolute;
        top:0;
        left:0;
        width:100%;
        height:100%;
        z-index:${zIndex};
        pointer-events:none;
        background-repeat:repeat;
        background-image:url('${base64Url}')`
    );
    container.style.position = "relative";
    container.insertBefore(watermarkDiv, container.firstChild);
  }

  window.__canvasWM = __canvasWM;
})();

let imgEl = document.querySelector("#xxx");

imgEl.onload = function() {
  __canvasWM({
    container: document.querySelector("#wrap"),
    image: imgEl,
    content: "fuck"
  });
};
```

## 46. 写一个获取颜色的正则

```js
^#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})$
```

## 47. 写一个方法检测页面中的所有标签是否正确闭合

这道题就是考栈思维嘛，给一个数组，遇到起始标签入栈，遇到结束标签出栈，若最后无法得到一个空栈，说明有未闭合的标签，自闭合的除外

```js
(function() {
  let dom_str = document.querySelector("body").outerHTML;
  let stack = [];
  for (let i in dom_str) {
    const v = dom_str[i];
    if (v === "<") {
      stack.push(v);
    } else if (v === ">") {
      let peak = stack.pop();
      if (peak !== "<") return false;
    }
  }
  if (stack.length > 0) return false;
  return true;
})();
```

类似力扣第 20 题:

```js
var isValid = function(s) {
  let valid = true;
  const stack = [];
  const mapper = {
    "{": "}",
    "[": "]",
    "(": ")"
  };

  for (let i in s) {
    const v = s[i];
    if (["(", "[", "{"].indexOf(v) > -1) {
      stack.push(v);
    } else {
      const peak = stack.pop();
      if (v !== mapper[peak]) {
        return false;
      }
    }
  }

  if (stack.length > 0) return false;

  return valid;
};
```

## 48. 阅读下方程序，写出或者简短描述函数调用：fun(2,3,4)的输出结果。

```js
function fun(...dimentions) {
  const [layer, ...d] = dimentions;
  return d.length
    ? Array(layer)
        .fill(0)
        .map(_ => fun(...d))
    : Array(layer);
}

fun(2, 3, 4);
```

```
(2) [Array(3), Array(3)]
0: Array(3)
  0: (4) [empty × 4]
  1: (4) [empty × 4]
  2: (4) [empty × 4]
  length: 3
  __proto__: Array(0)
1: Array(3)
  0: (4) [empty × 4]
  1: (4) [empty × 4]
  2: (4) [empty × 4]
  length: 3
  __proto__: Array(0)
length: 2
__proto__: Array(0)
```

## 49. 阅读下方程序，其输出为：

```js
new Promise(resolve => {
  console.log(1);
  setTimeout(resolve, 100, 2);
  console.log(3);
}).then(data => {
  console.log(data);
});
```

输出 1， 3， 2

setTimeout 第三个参数相当于给 resolve 传参，  
then 会在 resolve 执行后才会执行

```java
setTimeout((a,b,c) => {
   console.log(a,b,c)
}, 2000, "my", "name", "is starsion");

// my name is starsion
```

## 50. 快速幂算法

算法思路：

1. 如果是奇数幂，x \* p(x,n-1)
2. 如果是偶数幂，p(x , n/2) \* p (x, n/2)
3. 如果 n=0 ，返回 1

时间复杂度 ： O(logN)

具体实现：

```js
function fastPow(x, n) {
  if (n == 0) {
    return 1;
  } else if (n % 2 == 1) {
    return fastPow(x, n - 1) * x;
  } else {
    var r = fastPow(x, n / 2);
    return r * r;
  }
}

console.log(fastPow(2, 100));
```

## 51.
