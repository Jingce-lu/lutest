# Js 基础

[[toc]]

## 1. 内存空间

基础数据类型与变量对象  
包括七种基础数据类型与一种引用数据类型(Object)

基础数据类型表
| 类型 | 值 |
| ----- | -------------|
| Boolean | true / false |
| Null | null |
| Undefined | undefined |
| Number | 所有数字 |
| String | 所有字符串 |
| Symbol | 符号类型 |
| BigInt | 内置对象,表示任意大的整数 |

**引用数据类型(Object)的值是保存在堆内存空间中的对象**。 在 JavaScript 中，不允许直接访问堆内存空间中的数据，因此不能直接操作对象的堆内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。因此，引用数据都是按引用访问的。这里的引用，可以理解为保存在变量对象中的一个地址，该地址与堆内存中的对象相关联

## 2. 执行上下文

JavaScript 代码在执行时，会进入一个执行上下文中。执行上下文可以理解为当前代码的运行环境

JavaScript 中的运行环境主要包括以下三种情况

1. 全局环境： 代码运行起来后首先进入全局环境
2. 函数环境： 当函数被调用执行时，会进入当前函数中执行代码
3. eval 环境： 不建议使用

在一个 JavaScript 程序中，必定会出现多个执行上下文，而且**函数执行时才会创建执行上下文**

JavaScript 引擎会以栈的方式来处理他们，这个栈，就是函数调用栈， 函数调用栈规定了 JavaScript 代码的执行顺序，栈底永远是全局上下文，栈顶则是当前正在执行的上下文，处于栈顶的上下文执行完毕之后，会自动出栈

```js
// demo
function fn2() {
  console.log("fn2");
}
function fn1() {
  console.log("fn1");
  fn2();
}
fn1();
```

上述代码在执行过程中执行上下文栈的行为

```js
/* 伪代码 以数组来表示执行上下文栈 ECStack=[] */
// 代码执行时最先进入全局环境，全局上下文被创建并入栈
ECStack.push(global_EC);
// fn1 被调用，fn1 函数上下文被创建并入栈
ECStack.push(fn1_EC);
// fn1 中调用 fn2，fn2 函数上下文被创建并入栈
ECStack.push(fn2_EC);
// fn2 执行完毕，fn2 函数上下文出栈
ECStack.pop();
// fn1 执行完毕，fn1 函数上下文出栈
ECStack.pop();
// 代码执行完毕，全局上下文出栈
ECStack.pop();
```

<div align="center"><img :src="$withBase('/images/prepare/new/2020053006.jpg')" alt="prepare/new/2020053006.jpg"></div>

<br /><br />

**执行上下文的生命周期**

一个执行上下文的生命周期分为`创建`和`执行`阶段。创建阶段主要工作是生成变量对象、建立作用域链和确定 this 指向。而执行阶段主要工作是变量赋值以及执行其它代码等。

执行上下文的生命周期，如下图。

<img :src="$withBase('/images/prepare/require/19121104.png')" alt="prepare/require/19121104.png">

在执行上下文的创建阶段，会分别`生成变量对象`，`建立作用域链`，`确定 this 指向`。其中变量对象与作用域链我们都已经仔细总结过了，而这里的关键，就是确定 this 指向。

首先我们需要得出一个非常重要一定要牢记于心的结论，**this 的指向，是在函数被调用的时候确定的**。`也就是执行上下文被创建时确定的`。

## 3. 变量对象

在 JavaScript 代码中声明的所有变量都保存在变量对象（**VO, Variable Object**）中，除此之外，变量对象中还可能包含以下内容

- 函数的所有参数（Firefox 中为参数对象 arguments）
- 当前上下文中的所有函数声明（通过 function 声明的函数）
- 当前上下文中的所有变量声明（通过 var 声明的变量）

### 创建过程

变量对象的创建，依次经历了以下几个过程

1. 在 Chrome 浏览器中，变量对象会首先获得函数的参数变量及其值；在 Firefox 浏览器中，是直接将参数对象 arguments 保存在变量对象中
2. 依次获取当前上下文中所有的函数声明，也就是使用 function 关键字声明的函数。在变量对象中会以函数名建立一个属性，属性值为指向该函数所在的内存地址引用。如果函数名的属性已经存在，那么该属性的值会被新的引用覆盖
3. 依次获取当前上下文中的变量声明，也就是使用 var 关键字声明的变量。每找到一个变量声明，就在变量对象中就以变量名建立一个属性，属性值为 undefined。如果该变量名的属性已经存在，为了防止同名的函数被修改为 undefined，则会直接跳过，原属性值不会被修改
4. ES6 变量声明方式 let/const 规则与 var 完全不同，他们是在上下文的执行阶段开始执行的，避免了变量提升带来的一系列问题

### 实例分析

```js
// demo
function test() {
  console.log(a);
  console.log(foo());

  var a = 1;
  function foo() {
    return 2;
  }
}

test();

// 执行过程
function test() {
  function foo() {
    return 2;
  }
  var a = undefined;
  console.log(a);
  console.log(foo());
  a = 1;
}
```

运行 test 函数，对应的上下文开始创建，可以用如下形式来表达这个过程

```js
// 创建过程
testEC = {
  VO: {}, // 变量对象
  scopeChain: [], // 作用域链
  this: {}
}

// VO 为 Variable Object 的缩写，即变量对象
VO = {
  arguments: {...},
  foo: <foo reference>,
  a: undefined
}
```

在函数调用栈中，如果当前执行上下文处于函数调用栈的栈顶，则意味着当前上下文处于激活状态，此时变量对象称为活动对象（**AO, Activation Object**）。 活动对象中包含变量对象的所有属性，并且此时所有的属性都已经完成了赋值，除此之外活动对象还包含了 this 的指向

```js
// 执行阶段
VO -> AO
AO = {
  arguments: {...},
  foo: <foo reference>,
  a: 1,
  this: Window
}
```

## 4. 作用域与作用域链

### 作用域

1. 全局作用域
2. 函数作用域
3. 块级作用域

**函数作用域中声明的变量与方法，只能被下层子作用域访问，而不能被其他不相干的作用域访问**

```js
function foo() {
  var a = 20;
  var b = 30;

  function bar() {
    return a + b;
  }
  return bar();
}

foo(); // 50 bar中的作用域为foo的子作用域，因此能访问到变量a和b
```

```js
var mm = 22;
function a() {
  console.log(mm);
}

function b() {
  var mm = 1;
  a();
}

b(); // 22 a不是b的子作用域
```

在 ES6 以前， ECMAScript 没有块级作用域，因此使用时需要特别注意，一定是在函数环境中才能生成新的作用域，下面的情况则不会有作用域的限制

```js
var arr = [1, 2, 3, 4, 5];

for (var i = 0; i < arr.length; i++) {
  console.log("do something by ", i);
}

console.log(i); // i == 5
```

### 作用域链

执行上下文的生命周期，如下图。

<img :src="$withBase('/images/prepare/require/19121104.png')" alt="prepare/require/19121104.png">

我们知道函数在调用激活时，会开始创建对应的执行上下文，在执行上下文生成的过程中，变量对象，作用域链，以及 this 的值会分别被确定。

**作用域链（Scope Chain），是由当前环境与上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问**。

```js
var a = 20;

function test() {
  var b = a + 10;

  function innerTest() {
    var c = 10;
    return b + c;
  }

  return innerTest();
}

test();
```

在上面的例子中，`全局`，`函数test`，`函数innerTest`的**执行上下文先后创建**。我们设定他们的变量对象分别为`VO(global)`，`VO(test)`, `VO(innerTest)`。而 innerTest 的作用域链，则同时包含了这三个变量对象，所以 innerTest 的执行上下文可如下表示。

```js
innerTestEC = {
  VO: {...}, // 变量对象
  scopeChain: [VO(innerTest), VO(test), VO(global)], // 作用域链
  this: {}
}
```

我们可以直接用一个数组来表示作用域链，数组的第一项 scopeChain[0]为作用域链的最前端，而数组的最后一项，为作用域链的最末端，所有的最末端都为全局变量对象。

很多人会误解为当前作用域与上层作用域为包含关系，但其实并不是。以最前端为起点，最末端为终点的单方向通道我认为是更加贴切的形容。如图。

<img :src="$withBase('/images/prepare/require/19121105.png')" alt="prepare/require/19121105.png">

> 注意，因为变量对象在执行上下文进入执行阶段时，就变成了活动对象

**作用域链是由一系列变量对象组成，我们可以在这个单向通道中，查询变量对象中的标识符，这样就可以访问到上一层作用域中的变量了**。

## 5. 闭包

**闭包是一种特殊的对象**。

它由两部分组成。`执行上下文(代号A)`，以及`在该执行上下文中创建的函数（代号B）`。

当 B 执行时，如果访问了 A 中变量对象中的值，那么闭包就会产生。

在大多数理解中，包括许多著名的书籍，文章里都以函数 B 的名字代指这里生成的闭包。而在 chrome 中，则以执行上下文 A 的函数名代指闭包。

因此我们只需要知道，一个闭包对象，由 A、B 共同组成，在以后的篇幅中，我将以 chrome 的标准来称呼。

```js
// demo01
function foo() {
  var a = 20;
  var b = 30;

  function bar() {
    return a + b;
  }

  return bar;
}

var bar = foo();
bar();
```

上面的例子，首先有执行上下文 foo，在 foo 中定义了函数 bar，而通过对外返回 bar 的方式让 bar 得以执行。当 bar 执行时，访问了 foo 内部的变量 a，b。因此这个时候闭包产生。

**JavaScript 拥有自动的垃圾回收机制，关于垃圾回收机制，有一个重要的行为，那就是，`当一个值，在内存中失去引用时，垃圾回收机制会根据特殊的算法找到它，并将其回收，释放内存`**。

而我们知道，函数的执行上下文，在执行完毕之后，生命周期结束，那么该函数的执行上下文就会失去引用。其占用的内存空间很快就会被垃圾回收器释放。可是闭包的存在，会阻止这一过程。

先来一个简单的例子。

```js
var fn = null;

function foo() {
  var a = 2;

  function innnerFoo() {
    console.log(a);
  }
  fn = innnerFoo; // 将 innnerFoo的引用，赋值给全局变量中的fn
}

function bar() {
  fn(); // 此处的保留的innerFoo的引用
}

foo();
bar(); // 2
```

在上面的例子中，`foo()`执行完毕之后，按照常理，其执行环境生命周期会结束，所占内存被垃圾收集器释放。但是通过`fn = innerFoo`，函数 innerFoo 的引用被保留了下来，复制给了全局变量 fn。这个行为，导致了 foo 的变量对象，也被保留了下来。于是，函数 fn 在函数 bar 内部执行时，依然可以访问这个被保留下来的变量对象。所以此刻仍然能够访问到变量 a 的值。

这样，我们就可以称 foo 为闭包。

下图展示了闭包 foo 的作用域链。

<img :src="$withBase('/images/prepare/require/19121102.png')" alt="prepare/require/19121102.png">

我们可以在 chrome 浏览器的开发者工具中查看这段代码运行时产生的函数调用栈与作用域链的生成情况。如下图。

<img :src="$withBase('/images/prepare/require/19121106.png')" alt="prepare/require/19121106.png">

在上面的图中，红色箭头所指的正是闭包。其中 Call Stack 为当前的函数调用栈，Scope 为当前正在被执行的函数的作用域链，Local 为当前的局部变量。

**所以，通过闭包，我们可以在其他的执行上下文中，访问到函数的内部变量**。比如在上面的例子中，我们在函数 bar 的执行环境中访问到了函数 foo 的 a 变量。个人认为，从应用层面，这是闭包最重要的特性。利用这个特性，我们可以实现很多有意思的东西。

不过需要注意的是，虽然例子中的闭包被保存在了全局变量中，但是闭包的作用域链并不会发生任何改变。在闭包中，能访问到的变量，仍然是作用域链上能够查询到的变量。

对上面的例子稍作修改，如果我们在函数 bar 中声明一个变量 c，并在闭包 fn 中试图访问该变量，运行结果会抛出错误。

```js
var fn = null;

function foo() {
  var a = 2;

  function innnerFoo() {
    console.log(c); // 在这里，试图访问函数bar中的c变量，会抛出错误
    console.log(a);
  }
  fn = innnerFoo; // 将 innnerFoo的引用，赋值给全局变量中的fn
}

function bar() {
  var c = 100;
  fn(); // 此处的保留的innerFoo的引用
}

foo();
bar();
```
