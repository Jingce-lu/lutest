# Add 2020 服务端与网络

[[toc]]

## 1. 前端持久化的方式、区别

现代浏览器主要有 8 中缓存机制： HTTP 文件缓存、LocalStorage、SessionStorage、indexDB、Web SQL、Cookie、CacheStorage、Application Cache

- localStorage  
   localStorage 生命周期是永久，这意味着除非用户显示在浏览器提供的 UI 上清除 localStorage 信息，否则这些信息将永远存在。存放数据大小为一般为 5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。
- sessionStorage  
   为每一个数据源维持一个存储区域，在浏览器打开期间存在，包括页面重新加载

```js
// 保存数据到本地
const info = {
  name: "Lee",
  age: 20,
  id: "001"
};
sessionStorage.setItem("key", JSON.stringify(info));
localStorage.setItem("key", JSON.stringify(info));

// 从本地存储获取数据
var data1 = JSON.parse(sessionStorage.getItem("key"));
var data2 = JSON.parse(localStorage.getItem("key"));

// 本地存储中删除某个保存的数据
sessionStorage.removeItem("key");
localStorage.removeItem("key");

// 删除所有保存的数据
sessionStorage.clear();
localStorage.clear();

// 监听本地存储的变化
window.addEventListener("storage", function(e) {
  console.log("key", e.key);
  console.log("oldValue", e.oldValue);
  console.log("newValue", e.newValue);
  console.log("url", e.url);
});
```

## 2. DNS 是怎么解析的

当一个用户在地址栏输入 www.taobao.com 时，DNS 解析有大致十个过程

1. 浏览器先检查自身缓存中有没有被解析过的这个域名对应的 ip 地址，如果有，解析结束。同时域名被缓存的时间也可通过 TTL 属性来设置。
2. 如果浏览器缓存中没有（专业点叫还没命中），浏览器会检查操作系统缓存中有没有对应的已解析过的结果。而操作系统也有一个域名解析的过程。在 windows 中可通过 c 盘里一个叫 hosts 的文件来设置，如果你在这里指定了一个域名对应的 ip 地址，那浏览器会首先使用这个 ip 地址。
3. 如果至此还没有命中域名，才会真正的请求本地域名服务器（LDNS）来解析这个域名，这台服务器一般在你的城市的某个角落，距离你不会很远，并且这台服务器的性能都很好，一般都会缓存域名解析结果，大约 80%的域名解析到这里就完成了。
4. 如果 LDNS 仍然没有命中，就直接跳到 Root Server 域名服务器请求解析
5. 根域名服务器返回给 LDNS 一个所查询域的主域名服务器（gTLD Server，国际顶尖域名服务器，如.com .cn .org 等）地址
6. 此时 LDNS 再发送请求给上一步返回的 gTLD
7. 接受请求的 gTLD 查找并返回这个域名对应的 Name Server 的地址，这个 Name Server 就是网站注册的域名服务器
8. Name Server 根据映射关系表找到目标 ip，返回给 LDNS
9. LDNS 缓存这个域名和对应的 ip
10. LDNS 把解析的结果返回给用户，用户根据 TTL 值缓存到本地系统缓存中，域名解析过程至此结束

- 用户在浏览器中输入网址后，浏览器会先对输入的地址进行解析。比如用的协议 `http` 还是 `https`
- 之后会根据域名进行 IP 的寻址
  - 寻址先从缓存开始，如 host
  - 之后再访问 DNS 服务器，一层一层直至访问到根服务器
  - 服务器再把 IP 告诉客户端
- 客户端拿到 IP 后发起请求
  - 与服务器进行 HTTP 连接建立（3 次握手）
- 建立成功后服务器返回数据，浏览器进行渲染
  - DOM 树构建、CSSOM 树的构建、JavaScript 资源下载
    - CSS 的重排重绘，CSSOM 与 DOM 一起进行绘制
    - JavaScript 资源的阻塞
- 渲染出页面

## 3. XSS

> 跨网站指令码（英语：Cross-site scripting，通常简称为：XSS）是一种网站应用程式的安全漏洞攻击，是代码注入的一种。它允许恶意使用者将程式码注入到网页上，其他使用者在观看网页时就会受到影响。这类攻击通常包含了 HTML 以及使用者端脚本语言。

XSS 分为三种：**反射型**，**存储型**和 **DOM-based**

### 如何攻击

XSS 通过修改 HTML 节点或者执行 JS 代码来攻击网站。

例如通过 URL 获取某些参数

```html
<!-- http://www.domain.com?name=<script>alert(1)</script> -->
<div>{{name}}</div>
```

上述 URL 输入可能会将 HTML 改为 `<div><script>alert(1)</script></div>` ，这样页面中就凭空多了一段可执行脚本。这种攻击类型是反射型攻击，也可以说是 DOM-based 攻击。

也有另一种场景，比如写了一篇包含攻击代码 `<script>alert(1)</script>` 的文章，那么可能浏览文章的用户都会被攻击到。这种攻击类型是存储型攻击，也可以说是 DOM-based 攻击，并且这种攻击打击面更广。

### 如何防御

1. HttpOnly  
   浏览器禁止页面的 Javascript 访问带有 HttpOnly 属性的 cookie。（实质解决的是：XSS 后的 cookie 劫持攻击）如今已成为一种“标准”的做法
2. 输入检查（XSS Filter）  
   让一些基于特殊字符的攻击失效。（常见的 Web 漏洞如 XSS、SQLInjection 等，都要求攻击者构造一些特殊字符）
3. 输出检查  
   在变量输出到 HTML 页面时，使用编码或转义的方式来防御 XSS 攻击

最普遍的做法是转义输入输出的内容，对于引号，尖括号，斜杠进行转义

```js
function escape(str) {
  str = str.replace(/&/g, "&amp;");
  str = str.replace(/</g, "&lt;");
  str = str.replace(/>/g, "&gt;");
  str = str.replace(/"/g, "&quto;");
  str = str.replace(/'/g, "&#39;");
  str = str.replace(/`/g, "&#96;");
  str = str.replace(/\//g, "&#x2F;");
  return str;
}
```

通过转义可以将攻击代码 `<script>alert(1)</script>` 变成

```js
// -> &lt;script&gt;alert(1)&lt;&#x2F;script&gt;
escape("<script>alert(1)</script>");
```

对于显示富文本来说，不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。这种情况通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。

```js
var xss = require("xss");
var html = xss('<h1 id="title">XSS Demo</h1><script>alert("xss");</script>');
// -> <h1>XSS Demo</h1>&lt;script&gt;alert("xss");&lt;/script&gt;
console.log(html);
```

以上示例使用了 `js-xss` 来实现。可以看到在输出中保留了 `h1` 标签且过滤了 `script` 标签

### CSP

> 内容安全策略 (CSP) 是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本 (XSS) 和数据注入攻击等。无论是数据盗取、网站内容污染还是散发恶意软件，这些攻击都是主要的手段。

我们可以通过 CSP 来尽量减少 XSS 攻击。CSP 本质上也是建立白名单，规定了浏览器只能够执行特定来源的代码。

通常可以通过 HTTP Header 中的 `Content-Security-Policy` 来开启 CSP

- 只允许加载本站资源

  ```js
  Content-Security-Policy: default-src ‘self’
  ```

- 只允许加载 HTTPS 协议图片

  ```
  Content-Security-Policy: img-src https://*
  ```

- 允许加载任何来源框架
  ```
  Content-Security-Policy: child-src 'none'
  ```

## 4. CSRF

> 跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。[1] 跟跨網站指令碼（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。

简单点说，CSRF 就是利用用户的登录态发起恶意请求。

### 如何攻击

假设网站中有一个通过 Get 请求提交用户评论的接口，那么攻击者就可以在钓鱼网站中加入一个图片，图片的地址就是评论接口

```html
<img src="http://www.domain.com/xxx?comment='attack'" />
```

如果接口是 Post 提交的，就相对麻烦点，需要用表单来提交接口

```html
<form action="http://www.domain.com/xxx" id="CSRF" method="post">
  <input name="comment" value="attack" type="hidden" />
</form>
```

### 如何防御

防范 CSRF 可以遵循以下几种规则：

1. Get 请求不对数据进行修改
2. 不让第三方网站访问到用户 Cookie
3. 阻止第三方网站请求接口
4. 请求时附带验证信息，比如验证码或者 token
5. 验证 Referer  
   根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限的页面的请求都来自于同一个网站
6. 增加 Token  
   在请求中放入攻击者所不能伪造的信息，并且该信总不存在于 cookie 之中。鉴于此，系统开发人员可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务端进行 token 校验，如果请求中没有 token 或者 token 内容不正确，则认为是 CSRF 攻击而拒绝该请求
7. SameSite  
   可以对 Cookie 设置 SameSite 属性。该属性设置 Cookie 不随着跨域请求发送，该属性可以很大程度减少 CSRF 的攻击，但是该属性目前并不是所有浏览器都兼容。

## 5. 密码安全

密码安全虽然大多是后端的事情，但是作为一名优秀的前端程序员也需要熟悉这方面的知识。

### 加盐

对于密码存储来说，必然是不能明文存储在数据库中的，否则一旦数据库泄露，会对用户造成很大的损失。并且不建议只对密码单纯通过加密算法加密，因为存在彩虹表的关系。

通常需要对密码加盐，然后进行几次不同加密算法的加密。

```js
// 加盐也就是给原密码添加字符串，增加原密码长度
sha256(sha1(md5(salt + password + salt)));
```

但是加盐并不能阻止别人盗取账号，只能确保即使数据库泄露，也不会暴露用户的真实密码。一旦攻击者得到了用户的账号，可以通过暴力破解的方式破解密码。对于这种情况，通常使用验证码增加延时或者限制尝试次数的方式。并且一旦用户输入了错误的密码，也不能直接提示用户输错密码，而应该提示账号或密码错误。

## 6. Http 请求中的 keep-alive

keep-alive 是建立了 tcp 连接后仍然保持，以便下次再请求的时候，可以不用浪费握手的时间。

最早 http 整个流程是：浏览器和服务器建立连接->浏览器向服务器发送请求包->服务器根据请求地址和参数生成响应数据->服务器将处理完的数据返回给客户端->浏览器和服务器断开连接。

增加了 keep-alive 后在一定时间或者请求数内，只要有一次建立连接和断开连接。无论是动态或者静态的都是一样的原理。这样做有个好处就是减少建立连接和断开连接所产生的时间损耗。

比如：有一个网页，网页上有三个图片。那么客户端加载完这个网页需要请求的资源如下：

1. 网页内容
2. 三个图片

所以总共有 4 次 http 请求。
如果没有 keep-alive，那么需要进行 4 次建立连接和断开连接。
但是如果有 keep-alive，那么只要 1 次建立连接和断开连接。

## 7. 模块化，commonJS，es6，cmd，amd

### commonJS

- 一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非定义为 global 对象的属性。
- 输出模块变量的最好方法是使用 module.exports 对象。
- 加载模块使用 require 方法，该方法读取一个文件并执行，返回文件内部的 module.exports 对象

> commonJS 用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载，所以在浏览器端一般就不使用 commonJS 了

CommonJS 规范规定，每个模块内部，module 变量代表当前模块。这个变量是一个对象，它的 exports 属性（即 module.exports）是对外的接口。加载某个模块，其实是加载该模块的 module.exports 属性。

```js
var x = 5;
var addX = function(value) {
  return value + x;
};

//一个一个 导出
module.exports.x = x;
module.exports.addX = addX;

//整体导出
module.exports = { x: x, addX: addX };
```

上面代码通过 module.exports 输出变量 x 和函数 addX。require 方法用于加载模块。

```js
var example = require("./example.js");
console.log(example.x); // 5
console.log(example.addX(1)); // 6
```

### ES6 Module

ES6 Module 主要由两个命令构成：`export` 和 `import`。

- export 命令：用于规定模块的对外接口
- import 命令：用于输入其他模块提供的功能。

**export 命令**

一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用 export 关键字输出该变量

```js
// profile.js
var firstName = "Michael";
var lastName = "Jackson";
var year = 1958;

export { firstName, lastName, year };
```

export 命令除了输出变量，还可以输出函数或类（class）:

```js
export function multiply(x, y) {
  return x * y;
}
```

**import 命令**

使用 export 命令定义了模块的对外接口以后，其他 JS 文件就可以通过 import 命令加载这个模块。

```js
// main.js
import { firstName, lastName, year } from "./profile.js";

function setName(element) {
  element.textContent = firstName + " " + lastName;
}
```

> 如果想为输入的变量重新取一个名字，import 命令要使用 as 关键字，将输入的变量重命名。

```js
import { lastName as surname } from "./profile.js";
```

**export default 命令**

```js
// export-default.js
export default function() {
  console.log("foo");
}

// import-default.js
import customName from "./export-default";
customName(); // 'foo'
```

### CommonJs 和 ES6 Module 的区别

1. CommonJs 导出的是变量的一份拷贝，ES6 Module 导出的是变量的绑定（export default 是特殊的）
2. CommonJs 是单个值导出，ES6 Module 可以导出多个
3. CommonJs 是动态语法可以写在判断里，ES6 Module 静态语法只能写在顶层
4. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。

ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。

```js
// CommonJS模块
let { stat, exists, readFile } = require("fs");

// 等同于
let _fs = require("fs");
let stat = _fs.stat;
let exists = _fs.exists;
let readfile = _fs.readfile;
```

> 上面代码的实质是整体加载 fs 模块（即加载 fs 的所有方法），生成一个对象（\_fs），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。

ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，再通过 import 命令输入。

```js
// ES6模块
import { stat, exists, readFile } from "fs";
```

> 上面代码的实质是从 fs 模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。

### AMD 与 CMD 的比较

1. AMD：依赖前置，预执行（异步加载：依赖先执行）;偏浏览器端。
2. CMD：依赖就近，懒（延迟）执行（运行到需加载，根据顺序执行）；偏 l 浏览器端。
3. AMD 用户体验好，因为没有延迟，依赖模块提前执行了; CMD 性能好，因为只有用户需要的时候才执行

- CommonJs 用在服务器端，AMD 和 CMD 用在浏览器环境
- AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。
- CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。
- AMD:提前执行（异步加载：依赖先执行）+ 延迟执行
- CMD:延迟执行（运行到需加载，根据顺序执行）

## 8. 服务器如何处理 http 请求

处理 http 请求分为 7 个步骤

1. **Tcp 连接**  
   建立一条 tcp 链接，（若之前不存在持久链接 keep-alive），把客户端的 ip 和 port，服务端的 ip 和 port 数据放到 web 服务器连接表中。服务器随时监听链接表中的链接，看有没有数据变化
2. **接收 http 请求**  
   一旦我们发送 http 请求了，这条 tcp 链接就开始工作了。因为 web 服务器链接表中有许多链接需要被处理，处理的方式有单线程，多线程这些（这些涉及操作系统的知识）。
3. **处理 http 请求**
4. **访问资源**  
   访问资源可以是访问静态资源，这个就直接根据 url 地址去服务器里找就好了。  
   访问动态资源的话要经过一个叫 cgi 的东西，再用服务端脚本处理，再返回给前端。
5. **构建响应**  
   要是找到资源，则构建响应信息，包括响应的对象类型，长度，状态码。  
   另一个情况是重定向响应，就是直接返回一个重定向，客户端看到之后，立刻再向重定向的地址发起请求。重定向的响应的状态码一般是 3xx。
6. **发送响应**  
   把构建的响应发送给客户端
7. **记录日志**  
   服务端对这个请求响应过程进行记录

## 9. 栈跟堆有什么区别

1、堆空间的内存是动态分配的，一般存放对象，并且需要手动释放内存。当然，iOS 引入了 ARC（自动引用计数管理技术）之后，程序员就不需要用代码管理对象的内存了，之前 MRC（手动管理内存）的时候，程序员需要手动 release 对象。另外，ARC 只是一种中间层的技术，虽然在 ARC 模式下，程序员不需要像之前那么麻烦管理内存，但是需要遵循 ARC 技术的规范操作，比如使用属性限定符 weak、strong、assigen 等。因此，如果程序员没有按 ARC 的规则并合理的使用这些属性限定符的话，同样是会造成内存泄漏的。

2、栈空间的内存是由系统自动分配，一般存放局部变量，比如对象的地址等值，不需要程序员对这块内存进行管理，比如，函数中的局部变量的作用范围（生命周期）就是在调完这个函数之后就结束了。这些在系统层面都已经限定住了，程序员只需要在这种约束下进行程序编程就好，根本就没有把这块内存的管理权给到程序员，肯定也就不存在让程序员管理一说。

从申请的大小方面讲：

- 栈空间比较小；
- 堆空间比较大。

从数据存储方面来说：

- 栈空间中一般存储基本数据类型，对象的地址；
- 堆空间一般存放对象本身，block 的 copy 等。

## 10. post 请求表单发生乱码的情况，有哪些情况

若提交数据是在 form 表单中以 post 方式提交时出现中文乱码解决方案

```js
request.setCharacterEncoding("UTF-8"); //请求页面的编码
response.setCharacterEncoding("UTF-8"); //响应页面的编码
```

## 11. webscoket 协议原理

WebSocket 是 HTML5 一种新的协议。它实现了浏览器与服务器全双工通信，能更好的节省服务器资源和带宽并达到实时通讯，它建立在 TCP 之上，同 HTTP 一样通过 TCP 来传输数据，但是它和 HTTP 最大不同是：

- WebSocket 是一种双向通信协议，在建立连接后，WebSocket 服务器和 Browser/Client Agent 都能主动的向对方发送或接收数据，就像 Socket 一样；
- WebSocket 需要类似 TCP 的客户端和服务器端通过握手连接，连接成功后才能相互通信。

相对于传统 HTTP 每次请求-应答都需要客户端与服务端建立连接的模式，WebSocket 是类似 Socket 的 TCP 长连接的通讯模式，一旦 WebSocket 连接建立后，后续数据都以帧序列的形式传输。在客户端断开 WebSocket 连接或 Server 端断掉连接前，不需要客户端和服务端重新发起连接请求。在海量并发及客户端与服务器交互负载流量大的情况下，极大的节省了网络带宽资源的消耗，有明显的性能优势，且客户端发送和接受消息是在同一个持久连接上发起，实时性优势明显。

Websocket 是 HTML5 的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket 和 HTTP 都是应用层协议，都基于 TCP 协议。但是 **WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据**。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。

原生 WebSocket API 使用起来不太方便，我们使用`Socket.io`，它很好地封装了 webSocket 接口，提供了更简单、灵活的接口，也对不支持 webSocket 的浏览器提供了向下兼容。

我们先来看个例子：本地文件 socket.html 向`localhost:3000`发生数据和接受数据

```html
<!-- socket.html -->
<script>
  let socket = new WebSocket("ws://localhost:3000");
  socket.onopen = function() {
    socket.send("我爱你"); //向服务器发送数据
  };
  socket.onmessage = function(e) {
    console.log(e.data); //接收服务器返回的数据
  };
</script>
```

```js
// server.js
let express = require("express");
let app = express();
let WebSocket = require("ws"); //记得安装ws
let wss = new WebSocket.Server({ port: 3000 });
wss.on("connection", function(ws) {
  ws.on("message", function(data) {
    console.log(data);
    ws.send("我不爱你");
  });
});
```

## 12. 讲一门语言的编译原理

编译的基本流程

编译可以分为五个基本步骤:`词法分析`、`语法分析`、`语义分析`及`中间代码的生成优化`、`目标代码的生成`。这是每个编译器都必须的基本步骤和流程, 从源头输入高级语言源程序输出目标语言代码。

1. **词法分析**  
   词法分析器是通过词法分析程序对构成源程序的字符串从左到右的扫描, 逐个字符地读, 识别出每个单词符号, 识别出的符号一般以二元式形式输出, 即包含符号种类的编码和该符号的值。词法分析器一般以函数的形式存在, 供语法分析器调用。当然也可以一个独立的词法分析器程序存在。完成词法分析任务的程序称为词法分析程序或词法分析器或扫描器。
2. **语法分析**  
   语法分析是编译过程的第二个阶段。这阶段的任务是在词法分析的基础上将识别出的单词符号序列组合成各类语法短语, 如“语句”, “表达式”等.语法分析程序的主要步骤是判断源程序语句是否符合定义的语法规则, 在语法结构上是否正确。而一个语法规则又称为文法, 乔姆斯基将文法根据施加不同的限制分为 0 型、1 型、2 型、3 型文法, 0 型文法又称短语文法, 1 型称为上下文有关文法, 2 型称为上下文无关文法, 3 型文法称为正规文法, 限制条件依次递增。
3. **语义分析**  
   词法分析注重的是每个单词是否合法, 以及这个单词属于语言中的哪些部分。语法分析的上下文无关文法注重的是输入语句是否可以依据文法匹配产生式。那么, 语义分析就是要了解各个语法单位之间的关系是否合法。实际应用中就是对结构上正确的源程序进行上下文有关性质的审查, 进行类型审查等。
4. **中间代码生成与优化**  
   在进行了语法分析和语义分析阶段的工作之后, 有的编译程序将源程序变成一种内部表示形式, 这种内部表示形式叫做中间语言或中间表示或中间代码。所谓“中间代码”是一种结构简单、含义明确的记号系统, 这种记号系统复杂性介于源程序语言和机器语言之间, 容易将它翻译成目标代码。另外, 还可以在中间代码一级进行与机器无关的优化。
5. **目标代码的生成**  
   根据优化后的中间代码, 可生成有效的目标代码。而通常编译器将其翻译为汇编代码, 此时还需要将汇编代码经汇编器汇编为目标机器的机器语言。
6. **出错处理**  
   编译的各个阶段都有可能发现源码中的错误, 尤其是语法分析阶段可能会发现大量的错误, 因此编译器需要做出错处理, 报告错误类型及错误位置等信息。

## 13. 基于 nodejs 的云端热部署原理与实现

大家都知道，nodejs 启的后端服务，如果有代码变动，要重启进程，代码才能生效。

nodejs 的进程在重启的时候，爸爸们去访问服务，就会出现短暂的 502 bad gateway，爸爸们会不高兴

如果你的服务器加上了 watch 机制

当服务器上的代码频繁发生变动，或者短时间内发生高频变动，那就会一直 502 bad gateway

所谓“重启一时爽，一直重启一直爽”

近段时间在做云编译相关需求的时候，就出现了短时间内线上服务代码高频变动，代码功能模块高频更新，在不能重启服务的情况下，让更新的代码生效的场景。

这就涉及到一个热部署的概念，在不重启服务的情况下，让新部署的代码生效。

**代码没法实时生效的原因**

当我们通过`require('xx/xx.js')`去加载一个功能模块的时候，node 会把`require('xx/xx.js')`得到的结果缓存在`require.cache('xx/xx.js')`中

当我们多次调用`require('xx/xx.js')`，node 就不再重新加载，而是直接从`require.cache('xx/xx.js')`读取缓存

所以当爸爸在服务器上修改 xx/xx.js 这个路径下的文件时，node 只会去读取缓存，不会去加载爸爸的最新代码

**源码地址和使用**

以下代码是提炼出来、完整可运行的热部署基础原理代码，大家可以基于这个代码去自行拓展：[smart-node-reload](https://github.com/airuikun/smart-node-reload)

```js
const fs = require("fs");
const path = require("path");
const vm = require("vm");

const handlerMap = {};
const hotsPath = path.join(__dirname, "hots");

// 加载文件代码 并 监听指定文件夹目录文件内容变动
const loadHandlers = async () => {
  // 遍历出指定文件夹下的所有文件
  const files = await new Promise((resolve, reject) => {
    fs.readdir(hotsPath, (err, files) => {
      if (err) {
        reject(err);
      } else {
        resolve(files);
      }
    });
  });
  // 初始化加载所有文件 把每个文件结果缓存到handlerMap变量当中
  for (let f in files) {
    handlerMap[files[f]] = await loadHandler(path.join(hotsPath, files[f]));
  }

  // 监听指定文件夹的文件内容变动
  await watchHandlers();
};

// 监视指定文件夹下的文件变动
const watchHandlers = async () => {
  // 这里建议用chokidar的npm包代替文件夹监听
  fs.watch(hotsPath, { recursive: true }, async (eventType, filename) => {
    // 获取到每个文件的绝对路径
    // 包一层require.resolve的原因，拼接好路径以后，它会主动去帮你判断这个路径下的文件是否存在
    const targetFile = require.resolve(path.join(hotsPath, filename));
    // 当你适应require加载一个模块后，模块的数据就会缓存到require.cache中，下次再加载相同模块，就会直接走require.cache
    // 所以我们热加载部署，首要做的就是清除require.cache中对应文件的缓存
    const cacheModule = require.cache[targetFile];
    // 去除掉在require.cache缓存中parent对当前模块的引用，否则会引起内存泄露，具体解释可以看下面的文章
    // 《记录一次由一行代码引发的“血案”》https://cnodejs.org/topic/5aaba2dc19b2e3db18959e63
    // 《一行 delete require.cache 引发的内存泄漏血案》https://zhuanlan.zhihu.com/p/34702356
    if (cacheModule.parent) {
      cacheModule.parent.children.splice(
        cacheModule.parent.children.indexOf(cacheModule),
        1
      );
    }
    // 清除指定路径对应模块的require.cache缓存
    require.cache[targetFile] = null;

    // 重新加载发生变动后的模块文件，实现热加载部署效果，并将重新加载后的结果，更新到handlerMap变量当中
    const code = await loadHandler(targetFile);
    handlerMap[filename] = code;
    console.log("热部署文件：", filename, "，执行结果：", handlerMap);
  });
};

// 加载指定文件的代码
const loadHandler = filename => {
  return new Promise((resolve, reject) => {
    fs.readFile(filename, (err, data) => {
      if (err) {
        resolve(null);
      } else {
        try {
          // 使用vm模块的Script方法来预编译发生变化后的文件代码，检查语法错误，提前发现是否存在语法错误等报错
          new vm.Script(data);
        } catch (e) {
          // 语法错误,编译失败
          reject(e);
          return;
        }
        // 编译通过后，重新require加载最新的代码
        resolve(require(filename));
      }
    });
  });
};

loadHandlers();
```

## 14. 为什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片？

作用：工作中，用于前端监控，比如曝光等等，谷歌和百度的都是用的 1x1 像素的透明 gif 图片；

why?

1. 没有跨域问题，一般这种上报数据，代码要写通用的；（排除 ajax）
2. 不会阻塞页面加载，影响用户的体验，只要 new Image 对象就好了；（排除 JS/CSS 文件资源方式上报）
3. 在所有图片中，体积最小；（比较 PNG/JPG）

补充:

1. 能够完成整个 HTTP 请求+响应（尽管不需要响应内容）
2. 触发 GET 请求之后不需要获取和处理数据、服务器也不需要发送数据
3. 跨域友好
4. 执行过程无阻塞
5. 相比 XMLHttpRequest 对象发送 GET 请求，性能上更好
6. GIF 的最低合法体积最小（最小的 BMP 文件需要 74 个字节，PNG 需要 67 个字节，而合法的 GIF，只需要 43 个字节）
7. 图片请求不占用 Ajax 请求限额

英文术语叫：`image beacon`  
在 Google 的 Make the Web Faster 的 #Track web traffic in the background 中有提到。

主要应用于只需要向服务器发送数据(日志数据)的场合，且无需服务器有消息体回应。比如收集访问者的统计信息。

一般做法是服务器用一个 1x1 的 gif 图片来作为响应，当然这有点浪费服务器资源。因此用 header 来响应比较合适，目前比较合适的做法是服务器发送"204 No Content"，即“服务器成功处理了请求，但不需要返回任何实体内容”。

另外该脚本的位置一般放在页面最后以免阻塞页面渲染,并且一般情况下也不需要 append 到 DOM 中。通过它的 onerror 和 onload 事件来检测发送状态。

```html
<script type="text/javascript">
  var thisPage = location.href;
  var referringPage = document.referrer ? document.referrer : "none";
  var beacon = new Image();
  beacon.src =
    "http://www.example.com/logger/beacon.gif?page=" +
    encodeURI(thisPage) +
    "&ref=" +
    encodeURI(referringPage);
</script>
```

这样做和 ajax 请求的区别在于：

1. 只能是 get 请求，因此可发送的数据量有限。
2. 只关心数据是否发送到服务器，服务器不需要做出消息体响应。并且一般客户端也不需要做出响应。
3. 实现了跨域。

## 15. 计算机网络

1. 五层因特尔协议栈：

   - 应用层（dns、http）：DNS 解析成 IP 并完成 http 请求发送；
   - 传输层（tcp、udp）：三次握手四次挥手模式建立 tcp 连接；
   - 网络层（IP、ARP）：IP 寻址；
   - 数据链路层（PPP）：将请求数据封装成帧；
   - 物理层：利用物理介质传输比特流（传输的时候通过双绞线、电磁波等）
   - **OIS 七层框架**:多了两层即，会话层（处理两个通信系统中交换信息的表示方式）和表示层（管理不同用户和进程之间的对话）。

2. get 和 post 的区别：

   - get 产生一个 tcp 数据包，post 产生两个
   - get 请求时会把 headers 和 data 数据一起发送出去；
   - post 请求时，浏览器先发送 headers，服务器 100 继续，浏览器再发送 data。

3. DNS 查询得到 IP

   1. 请求信息：首先查看域名的本地 DNS 缓存，该缓存存储计算机最近检索到的信息，如果计算机不知道答案，那么就需要执行一个 DNS 查询来查找答案；
   2. 询问递归式 DNS 服务器：
      - 如果信息不存储在本地，计算机会联系您的 ISP（网络提供商）的递归 DNS 服务器；
      - 这些专用计算机会为你执行一个 DNS 查询工作；
      - 递归服务器有自己的缓存，所以这个查询过程通常在这里完成，并将信息还回给用户；
   3. 询问根域名服务器
      - 如果递归服务器没有答案，他们会查询根域名服务器；
      - 根域名服务器是一种计算机，它扮演着一种 DNS 的电话接线员的角色，他们不知道答案，但可以将我们的疑问指向知道在哪里可以找到答案的人。
   4. 询问 TLD 域名服务器：
      - 根域名服务器将查看请求的第一部分，按从右到左的顺序，从 www.dyn.com 中找到.com，并将请求指向.com 对应的顶级域名服务器（TLD）.com;
      - 每个 TLD，如（.com,.org,.us）都有自己的顶级域名服务器，
      - 这些服务器没有我们需要的信息，但他们可以直接将我们引导到有信息的服务器。
   5. 询问权威的 DNS 服务器
      - TLD 域名服务器会继续检查请求的下一部分（dyn）www.dyn.com，并将查询指向负责此特定域名的服务器；
      - 这些权威的服务器将负责了解关于特定域的所有信息，并将信息存储在 DNS 记录。
   6. 找回记录：<br>
      递归服务器从权威服务器中检索 dyn.com 的记录，并将记录存储在本地缓存；
      - 如果其他任何人请求 dyn.com 的主机记录，递归服务器已经有答案了，并不需要再次进行查找；
      - 所有记录都有一个期限，一段时间后，递归服务器将需要要求一个新的记录副本，以确保信息不回过时。
   7. 接收答案：
      - 有了答案，递归服务器将记录返回到计算机，
      - 您的计算机将记录存储在缓存中，从记录中读取 IP 地址，然后将这些信息传递给浏览器；
      - 然后浏览器就可以根据 IP 地址和服务器进行连接建立。

4. TCPIP 请求

   - http 的本质就是 TCPIP 请求；
   - 需要经历 3 次握手建立连接，4 次挥手断开连接；
   - TCP 将 http 长报文划分为短报文，通过三次握手与服务器端建立连接，进行可靠传输。
   - **三次握手**：
     1. 客户端：你是 XXX 服务端吗？
     2. 服务端： 我是 XXX 服务端，你是客户端吗？
     3. 客服端： 是的，我是客户端
        建立连接成功后，接下来就可以进行正式的传输数据。
   - **四次挥手断开连接**
     1. 主动方：我已经关闭了向你那边的信息发送通道，只能被动接受信息了；
     2. 被动方： 收到通道关闭的信息；
     3. 被动方： 我现在也关闭了向你那边发送信息的通道
     4. 主动方： 左后收到信息，连接断开，之后双方无法通信

5. TCP/IP 的并发限制：
   - 浏览器对同一个域名下并发的 TCP 连接是有限制的（2-10 个不等）
   - 而且在 http1.0 中往往一个资源的下载就需要一个 tcp/ip 请求

## 16. 跨域通信的几种方式

1. **JSONP** (只支持 GET 请求)

   > 通过 script 标签的异步加载来实现的。利用 script 标签不受同源策略的限制，天然可以跨域的特性。

   ```html
   <script>
     var script = document.createElement("script");
     script.type = "text/javascript";

     script.src = "https://api.asilu.com/geo/&callback=jsonp"; //这个是获取当前经纬度的接口
     document.head.appendChild(script); //创建并添加script标签到<head>下

     // 回调执行函数
     function jsonp(res) {
       console.log(res); //打印jsonp返回的信息
     }
   </script>
   ```

2. **postMessage**

   > H5 中新增的`postMessage()`方法，可以用来做跨域通信

   ```js
   // 在A窗口中操作如下：向B窗口发送数据
   Bwindow.postMessage("data", "http://B.com"); //这里强调的是B窗口里的window对象

   // 在窗口B中监听 message 事件
   Awindow.addEventListener(
     "message",
     function(event) {
       //这里强调的是A窗口里的window对象
       console.log(event.origin); //获取 ：A窗口url
       console.log(event.source); //获取：A window对象
       console.log(event.data); //获取传过来的数据
     },
     false
   );
   ```

3. **WebSocket**
   > WebSocket protocol 是 HTML5 一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是 server push 技术的一种很好的实现
   ```js
   var ws = new WebSocket("wss://echo.websocket.org");
   ws.onopen = function(evt) {
     console.log("Connection open ...");
     ws.send("Hello WebSockets!");
   };
   ws.onmessage = function(evt) {
     console.log("Received Message: ", evt.data);
     ws.close();
   };
   ws.onclose = function(evt) {
     console.log("Connection closed.");
   };
   ```
4. **CORS**(现代浏览器普遍跨域解决方案)
   > 整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与同源的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信  
   > 服务端设置 `Access-Control-Allow-Origin` 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。
5. **Node 中间件代理(两次跨域)**

   实现原理：**同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略**。

   代理服务器，需要做以下几个步骤：

   - 接受客户端请求 。
   - 将请求 转发给服务器。
   - 拿到服务器 响应 数据。
   - 将 响应 转发给客户端。

    <img :src="$withBase('/images/prepare/require/19122301.png')" alt="prepare/require/19122301.png">

   我们先来看个例子：本地文件 index.html 文件，通过代理服务器`http://localhost:3000`向目标服务器`http://localhost:4000`请求数据。

   ```html
   <!-- index.html(http://127.0.0.1:5500) -->
   <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
   <script>
     $.ajax({
       url: "http://localhost:3000",
       type: "post",
       data: {
         name: "xiamen",
         password: "123456"
       },
       contentType: "application/json;charset=utf-8",
       success: function(result) {
         console.log(result); // {"title":"fontend","password":"123456"}
       },
       error: function(msg) {
         console.log(msg);
       }
     });
   </script>
   ```

   ```js
   // server1.js 代理服务器(http://localhost:3000)
   const http = require("http");
   // 第一步：接受客户端请求
   const server = http.createServer((request, response) => {
     // 代理服务器，直接和浏览器直接交互，需要设置CORS 的首部字段
     response.writeHead(200, {
       "Access-Control-Allow-Origin": "*",
       "Access-Control-Allow-Methods": "*",
       "Access-Control-Allow-Headers": "Content-Type"
     });
     // 第二步：将请求转发给服务器
     const proxyRequest = http
       .request(
         {
           host: "127.0.0.1",
           port: 4000,
           url: "/",
           method: request.method,
           headers: request.headers
         },
         serverResponse => {
           // 第三步：收到服务器的响应
           var body = "";
           serverResponse.on("data", chunk => {
             body += chunk;
           });
           serverResponse.on("end", () => {
             console.log("The data is " + body);
             // 第四步：将响应结果转发给浏览器
             response.end(body);
           });
         }
       )
       .end();
   });
   server.listen(3000, () => {
     console.log("The proxyServer is running at http://localhost:3000");
   });
   ```

   ```js
   // server2.js(http://localhost:4000)
   const http = require("http");
   const data = { title: "fontend", password: "123456" };
   const server = http.createServer((request, response) => {
     if (request.url === "/") {
       response.end(JSON.stringify(data));
     }
   });
   server.listen(4000, () => {
     console.log("The server is running at http://localhost:4000");
   });
   ```

   上述代码经过两次跨域，值得注意的是浏览器向代理服务器发送请求，也遵循同源策略，最后在 index.html 文件打印出`{"title":"fontend","password":"123456"}`

6. **nginx 反向代理**

   实现原理类似于 Node 中间件代理，需要你搭建一个中转 nginx 服务器，用于转发请求。

   使用 nginx 反向代理实现跨域，是最简单的跨域方式。只需要修改 nginx 的配置即可解决跨域问题，支持所有浏览器，支持 session，不需要修改任何代码，并且不会影响服务器性能。

   实现思路：通过 nginx 配置一个代理服务器（域名与 domain1 相同，端口不同）做跳板机，反向代理访问 domain2 接口，并且可以顺便修改 cookie 中 domain 信息，方便当前域 cookie 写入，实现跨域登录。

   先下载[nginx](http://nginx.org/en/download.html)，然后将 nginx 目录下的 nginx.conf 修改如下:

   ```bash
   # proxy服务器
   server {
     listen       81;
     server_name  www.domain1.com;
     location / {
       proxy_pass   http://www.domain2.com:8080;  #反向代理
       proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名
       index  index.html index.htm;

       # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用
       add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*
       add_header Access-Control-Allow-Credentials true;
     }
   }
   ```

   最后通过命令行`nginx -s reload`启动 nginx

   ```js
   // index.html
   var xhr = new XMLHttpRequest();
   // 前端开关：浏览器是否读写cookie
   xhr.withCredentials = true;
   // 访问nginx中的代理服务器
   xhr.open("get", "http://www.domain1.com:81/?user=admin", true);
   xhr.send();
   ```

   ```js
   // server.js
   var http = require("http");
   var server = http.createServer();
   var qs = require("querystring");
   server.on("request", function(req, res) {
     var params = qs.parse(req.url.substring(2));
     // 向前台写cookie
     res.writeHead(200, {
       "Set-Cookie": "l=a123456;Path=/;Domain=www.domain2.com;HttpOnly"
       // HttpOnly:脚本无法读取
     });
     res.write(JSON.stringify(params));
     res.end();
   });
   server.listen("8080");
   console.log("Server is running at port 8080...");
   ```

7. **window.location.hash + iframe**

   > url 的#后面的内容就叫 Hash。Hash 的改变，页面不会刷新。

   ```js
   // 在A中伪代码如下：
   var B = document.getElementsByTagName("iframe");
   B.src = B.src + "#" + "data";

   // 在B中的伪代码如下
   window.onhashchange = function() {
     var data = window.location.hash;
   };
   ```

   优点：不限制域。

   缺点：需要通过代理页；双方都需要创建 iframe 标签；数据直接暴露在 url 中，数据容量和类型有限。

8. **window.name + iframe**
9. **document.domain + iframe**

<table border="1">
  <caption>跨域解决方案一览表</caption>
  <tr>
    <th>序号</th>
    <th>解决方案</th>
    <th>简述</th>
    <th>优点</th>
    <th>优点</th>
  </tr>
  <tr>
    <td>1</td>
    <td>document.domain</td>
    <td>将子域和父域的domain都设置成父域地址</td>
    <td>设置简单</td>
    <td>仅限于子域名与父域名不同的情况</td>
  </tr>
  <tr>
    <td>2</td>
    <td>window.location.hash</td>
    <td>A与B通信，通过代理页C（与A同域）来设置</td>
    <td>用于与iframe标签嵌入的页面进行通信</td>
    <td>1、设置起来比较麻烦，需要借助代理页。<br />
        2、数据容量和类型有限制</td>
  </tr>
  <tr>
    <td>3</td>
    <td>window.name</td>
    <td>A与B通信，也需要通过代理页C（与A同域）完成</td>
    <td>
      1、适用于与iframe标签嵌入的页面进行通信 <br />
      2、与location.hash对比容量较大，可以容纳2MB
    </td>
    <td>设置起来比较麻烦，需要借助代理页。</td>
  </tr>
  <tr>
    <td>4</td>
    <td>Websocket</td>
    <td>Websocket是一种通信协议，不受同源策略限制。 只要设置了Origin字段，并且域名在白名单范围内，服务器就可以通信</td>
    <td>只要设置了Origin字段，并且域名在白名单范围内，服务器就可以通信</td>
    <td>只适用于ws://和wss://作为协议前缀的域名</td>
  </tr>
  <tr>
    <td>5</td>
    <td>postMessage</td>
    <td>
      发送方可通过postMessage（msg,origin）发送消息，写明发送内容和发送方域名地址（协议+域名+端口）即可。<br />
      接收方可通过onmessage进行监听拿到消息。
    </td>
    <td>设置简单，可用于向服务器请求数据，也可以进行网页之间的传值。</td>
    <td>
      1、发送方和接收方均要注意判断源地址，以免信息泄露。<br />
      2、在实际开发中要注意配置不同的环境地址。（开发、测试和生产）
    </td>
  </tr>
  <tr>
    <td>6</td>
    <td>jsonp </td>
    <td>
      通过插入script标签，发送请求，因为非xhr请求，所以不受浏览器限制，即可实现跨越。
    </td>
    <td>设置简单，可兼容老的浏览器</td>
    <td>
      1、需要前后端配合，协同回调函数名。<br />
      2、因为不是xhr请求，所以不具备该请求的特性。
    </td>
  </tr>
  <tr>
    <td>7</td>
    <td>CORS  </td>
    <td>
      CORS即跨域资源共享，是w3c的标准，使用自定义的http请求头，服务端设置Access-Control-Allow-Origin为请求方域名或者* 
    </td>
    <td>设置简单，最常用的跨域办法。</td>
    <td>
      不兼容老的浏览器（IE6、IE7、Opera min）
    </td>
  </tr>
  <tr>
    <td>8</td>
    <td>Ngnix  </td>
    <td>
      通过ngnix配置，将数据发送方的地址转发到数据请求方，就避免了跨域问题。
    </td>
    <td>设置简单</td>
    <td>
      依赖于ngnix配置
    </td>
  </tr>
</table>

## 17. 函数式编程

函数式编程是一种强调以函数使用为主的软件开发风格

好处

1. 促使将任务分解成简单的函数
2. 使用流式的调用链来处理数据
3. 通过响应氏范式降低事件驱动代码的复杂性
