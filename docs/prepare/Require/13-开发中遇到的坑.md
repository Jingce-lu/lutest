# 开发中遇到的坑

[[toc]]

## 1.d3

rgb 百分比 0 需要写成 0% <br>
d3.color('rgba(50%,0%,30%,0.3)')

## 2.Fetch 常见坑

- Fetch 请求默认是不带 cookie 的，需要设置 fetch(url, {credentials: 'include'})
- 服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。

## 3.微信扫码支付坑还是有的，如果你是第一次摸索的话，下面罗列一下需要注意的地方

1. 签名算法要写正确，不然是不会成功的，要拼接正确才行
2. 微信返回的是 xml 格式的数据，我们得通过插件转成 json，这样才方便获取数据
3. 返回的`code_url`要给前端生成二维码用，然后需要开一个定时器查询该订单是否完成支付，最终通知用户结果
4. 回调地址很重要，我们后端需要`post`接收微信返回的回调信息，然后保存信息，不过在保存用户支付信息的之前，我们得知道该订单是否已经保存过，以免重复添加。还有就是返回的是 xml 的数据，后端一定要保证能够接收得到，按照正常的方式是接收不了的，得额外设置。

## 4.关于移动端,webview 监听滚动条的坑

中途需要动态设置滚动条的 scrolltop 值，发现在 PC 上都没问题，然而上测试环境，各种问题，页面老是不按照设想的那样，最终发现是移动端对滚动条的处理不一致导致。

**所以移动端需要设置滚动条请使用**

```js
document.body.scrollTop;
```

**PC 上使用：**

```js
document.documentElement.scrollTop;
```

## 5.压缩图片上传

而压缩图片也并不是直接把图片绘制到 canvas 再调用一下 toDataURL 就行的。

在 IOS 中，canvas 绘制图片是有两个限制的：

首先是图片的大小，如果图片的大小超过两百万像素，图片也是无法绘制到 canvas 上的，调用 drawImage 的时候不会报错，但是你用 toDataURL 获取图片数据的时候获取到的是空的图片数据。

再者就是 canvas 的大小有限制，如果 canvas 的大小大于大概五百万像素（即宽高乘积）的时候，不仅图片画不出来，其他什么东西也都是画不出来的。

应对第一种限制，处理办法就是瓦片绘制了。瓦片绘制，也就是将图片分割成多块绘制到 canvas 上，我代码里的做法是把图片分割成 100 万像素一块的大小，再绘制到 canvas 上。

而应对第二种限制，我的处理办法是对图片的宽高进行适当压缩，我代码里为了保险起见，设的上限是四百万像素，如果图片大于四百万像素就压缩到小于四百万像素。四百万像素的图片应该够了，算起来宽高都有 2000X2000 了。

如此一来就解决了 IOS 上的两种限制了。

除了上面所述的限制，还有两个坑，一个就是 canvas 的 toDataURL 是只能压缩 jpg 的，当用户上传的图片是 png 的话，就需要转成 jpg，也就是统一用 canvas.toDataURL('image/jpeg', 0.1) ， 类型统一设成 jpeg，而压缩比就自己控制了。

另一个就是如果是 png 转 jpg，绘制到 canvas 上的时候，canvas 存在透明区域的话，当转成 jpg 的时候透明区域会变成黑色，因为 canvas 的透明像素默认为 rgba(0,0,0,0)，所以转成 jpg 就变成 rgba(0,0,0,1)了，也就是透明背景会变成了黑色。解决办法就是绘制之前在 canvas 上铺一层白色的底色。

```js
function compress(img) {
  var initSize = img.src.length;
  var width = img.width;
  var height = img.height;

  //如果图片大于四百万像素，计算压缩比并将大小压至400万以下
  var ratio;
  if ((ratio = (width * height) / 4000000) > 1) {
    ratio = Math.sqrt(ratio);
    width /= ratio;
    height /= ratio;
  } else {
    ratio = 1;
  }

  canvas.width = width;
  canvas.height = height;

  //铺底色
  ctx.fillStyle = "#fff";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  //如果图片像素大于100万则使用瓦片绘制
  var count;
  if ((count = (width * height) / 1000000) > 1) {
    count = ~~(Math.sqrt(count) + 1); //计算要分成多少块瓦片

    // ~~ 被用作一个更快的替代 Math.floor()

    //计算每块瓦片的宽和高
    var nw = ~~(width / count);
    var nh = ~~(height / count);

    tCanvas.width = nw;
    tCanvas.height = nh;

    for (var i = 0; i < count; i++) {
      for (var j = 0; j < count; j++) {
        tctx.drawImage(
          img,
          i * nw * ratio,
          j * nh * ratio,
          nw * ratio,
          nh * ratio,
          0,
          0,
          nw,
          nh
        );

        ctx.drawImage(tCanvas, i * nw, j * nh, nw, nh);
      }
    }
  } else {
    ctx.drawImage(img, 0, 0, width, height);
  }

  //进行最小压缩
  var ndata = canvas.toDataURL("image/jpeg", 0.1);

  console.log("压缩前：" + initSize);
  console.log("压缩后：" + ndata.length);
  console.log(
    "压缩率：" + ~~((100 * (initSize - ndata.length)) / initSize) + "%"
  );

  tCanvas.width = tCanvas.height = canvas.width = canvas.height = 0;

  return ndata;
}
```

## 6.rem 布局坑

1. 一开始在项目中用时，在手机端查看，页面是手机屏幕大小的 2~3 倍，我们知道这种方案会动态获取手机的 DPR，然后根据 dpr 设置 html 的 font-size 以及页面缩放比例：

   1. 如果 dpr=1(如电脑端），则 html 的 font-size 为 50px，此时 1rem = 50px， viewport 的 initial-scale 、minimum-scale 和 maximum-scale 都为 “1.0” ；
   2. 如果 dpr=2(如 iphone 5 和 6），则 html 的 font-size 为 100px，此时 1rem = 100px， viewport 的 initial-scale 、minimum-scale 和 maximum-scale 都为 “0.5”
   3. 如果 dpr=3(如 iphone 6 sp），则 html 的 font-size 为 150px，此时 1rem = 150px； viewport 的 initial-scale 、minimum-scale 和 maximum-scale 都为 “0.3333333333”

   由于我们是用的 hybrid 开发，经过查看发现是安卓客户端限制了 viewport 设置的缩放属性，让客户端放开限制就行，但是由于市场上的 app 版本还是不支持，所以需要做兼容性处理。

2. iPhone6 上有 1px 的滚动条，最后处理方案是通过 viewport 中的 maximum-scale 的值加了 0.1，由于设置了`user-scalable=no`，maximum-scale 的值加 0.1 并不会有什么影响，但是却神奇的解决了这个问题。

## 7.vue keep-alive

我先说一下设置了 `<keep-alive>`缓存的属性 以下的一些生命周期不会执行\*\*

1.  created() {}, //只执行一次 之后不会再被执行
2.  beforeDestroy() {},
3.  destroyed() {},

### 采坑 1

由于以上的生命周期不执行,所以前一个页面携带进来的参数不能再 created  以及 data 数据里直接赋值，要么直接在请求接口的方法里使用`this.$route.query.参数名`；  或者在`activated() {}`生命周期里赋值`this.cardId = this.$route.query.cardId`;往后可以直接通过 `this.cardid`得到值

<span style="color: red">顺便说一下 activated() {}这个生命周期函数,这个是只有设置了 keepalive 才会生效的</span>

碰到如下需求

a 组件有一个表单里面的值是从后台获取的但是可以修改,当我点击修改去 b 组件修改值之后需要把 b 组件选中的值带到 a 组件,同时之前填写过的一些信息不能被改

### 采坑 2

我的想法是判断`localStorage`里是否有该值,如果有就从`localStorage`拿,不存在就在从接口拿；但是当你退出页面或者退出编辑的时候要清空`localStorage`

本来是想在生命周期销毁之前删除设置的缓存,由于设置了`<keep-alive>`，销毁的生命周期就失效了,于是想到了切换路由的时候监听页面的路径来清除`localStorage`

### 采坑 3

设置了`<keep-alive>`的组件只要组件被缓存了，在 watch 里监听路由的变化时做相应的操作时,就算在其他的组件也会里也会执行到该组件里的方法

## 8.缓存相关

假设我们有一个 HTML 页面，如下:

```html
<!-- page.html -->
 <!DOCTYPE html>
 http://www.w3.org/1999/xhtml">
 <head>
     <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
     <title>page页</title>
 </head>
 <body>
     <img src="images/head.png" />
     <a href="page.html">重新访问page页</a>
 </body>
 </html>
```

加载此页面后，会获取图片，图片请求返回的响应头为

```http
 HTTP/1.1 200 OK
 Cache-Control: no-cache
 Content-Type: image/png
 Last-Modified: Tue, 08 Nov 2016 06:59:00 GMT
 Accept-Ranges: bytes
 Date: Thu, 10 Nov 2016 02:48:50 GMT
 Content-Length: 3534
```

### 问题一：当点击“重新访问 page 页”链接重新加载该页面后， head.png 如何二次加载？

响应头的`no-cache`表达的是可以缓存，但是每次都需要去服务器确认缓存资源的新鲜度，而不是不缓存，这是个坑。

```http
 Cache-Control: no-cache
```

如果不跳这个坑的话，这个问题就简单了：图片会发出请求头带上`If-Modified-Since: Tue, 08 Nov 2016 06:59:00 GMT`，服务器确认新鲜度，如果客户端资源是新鲜资源则返回 304,否则返回 200 并带上新的图片资源。

### 问题二：如果将上述信息中的 Cache-Control 设置为 private，那么结果又会如何呢？

当`Cache-Control: private`之后，说明一个问题，响应头没有给到任何缓存策略，这个时候客户端会怎么处理？

现在浏览器会有一个处理方法，当响应头没有任何缓存策略的时候有一套自己的处理机制，即 `Expires = 当前时间(Date - Last-Modified) * 10%`,简单理解就是响应头的 Date 时间与 Last-Modified 的时间差的十分之一作为缓存的过期时间。

按照这个处理流程，如果马上重新加载，则会直接读取本地缓存内容
，无需向服务器请求。

## 9.SSR 中异步数据的获取 + Redux 的使用

客户端渲染中，异步数据结合 Redux 的使用方式遵循下面的流程（对应图中第 12 步）：

1. 创建 Store
2. 根据路由显示组件
3. 派发 Action 获取数据
4. 更新 Store 中的数据
5. 组件 Rerender

而在服务器端，页面一旦确定内容，就没有办法 Rerender 了，这就要求组件显示的时候，就要把 Store 的数据都准备好，所以服务器端异步数据结合 Redux 的使用方式，流程是下面的样子（对应图中第 4 步）：

1. 创建 Store
2. 根据路由分析 Store 中需要的数据
3. 派发 Action 获取数据
4. 更新 Store 中的数据
5. 结合数据和组件生成 HTML，一次性返回

下面，我们分析下服务器端渲染这部分的流程：

1. 创建 Store：这一部分有坑，要注意避免，大家知道，客户端渲染中，用户的浏览器中永远只存在一个 Store，所以代码上你可以这么写：

   ```js
   const store = createStore(reducer, defaultState);
   export default store;
   ```

   然而在服务器端，这么写就有问题了，因为服务器端的 Store 是所有用户都要用的，如果像上面这样构建 Store，Store 变成了一个单例，所有用户共享 Store，显然就有问题了。所以在服务器端渲染中，Store 的创建应该像下面这样，返回一个函数，每个用户访问的时候，这个函数重新执行，为每个用户提供一个独立的 Store：

   ```js
   const getStore = req => {
     return createStore(reducer, defaultState);
   };
   export default getStore;
   ```

2. 根据路由分析 Store 中需要的数据： 要想实现这个步骤，在服务器端，首先我们要分析当前出路由要加载的所有组件，这个时候我们可以借助一些第三方的包，比如说 react-router-config, 具体这个包怎么使用，不做过多说明，大家可以查看文档，使用这个包，传入服务器请求路径，它就会帮助你分析出这个路径下要展示的所有组件。

3. 派发 Action 获取数据: 接下来，我们在每个组件上增加一个获取数据的方法：

   ```js
   Home.loadData = store => {
     return store.dispatch(getHomeList());
   };
   ```

   这个方法需要你把服务器端渲染的 Store 传递进来，它的作用就是帮助服务器端的 Store 获取到这个组件所需的数据。 所以，组件上有了这样的方法，同时我们也有当前路由所需要的所有组件，依次调用各个组件上的 loadData 方法，就能够获取到路由所需的所有数据内容了。

4. 更新 Store 中的数据: 其实，当我们执行第三步的时候，已经在更新 Store 中的数据了，但是，我们要在生成 HTML 之前，保证所有的数据都获取完毕，这怎么处理呢？

   ```js
   // matchedRoutes 是当前路由对应的所有需要显示的组件集合
   matchedRoutes.forEach(item => {
     if (item.route.loadData) {
       const promise = new Promise((resolve, reject) => {
         item.route
           .loadData(store)
           .then(resolve)
           .catch(resolve);
       });
       promises.push(promise);
     }
   });

   Promise.all(promises).then(() => {
     // 生成 HTML 逻辑
   });
   ```

   这里，我们使用 Promise 来解决这个问题，我们构建一个 Promise 队列，等待所有的 Promise 都执行结束后，也就是所有 store.dispatch 都执行完毕后，再去生成 HTML。这样的话，我们就实现了结合 Redux 的 SSR 流程。

在上面，我们说到，服务器端渲染时，页面的数据是通过 loadData 函数来获取的。而在客户端，数据获取依然要做，因为如果这个页面是你访问的第一个页面，那么你看到的内容是服务器端渲染出来的，但是如果经过 react-router 路由跳转道第二个页面，那么这个页面就完全是客户端渲染出来的了，所以客户端也要去拿数据。

在客户端获取数据，使用的是我们最习惯的方式，通过 `componentDidMount` 进行数据的获取。这里要注意的是，`componentDidMount` 只在客户端才会执行，在服务器端这个生命周期函数是不会执行的。所以我们不必担心 `componentDidMount` 和 loadData 会有冲突，放心使用即可。这也是为什么数据的获取应该放到 `componentDidMount` 这个生命周期函数中而不是 `componentWillMount` 中的原因，可以避免服务器端获取数据和客户端获取数据的冲突。

## 10.CSS 中的 calc()

calc 使得开发者能够使用四则运算表达式来填写 CSS 属性。

px、%、em 等不同单位的数值均可参与计算，浏览器会进行自动转换。

坑： 当使用 calc 的时候，运算符号 左右需要有空格的哦，否则，属性不生效。例如： `width: calc(100% - 30px)`;

在 less 使用中某些情况是无效的`height: calc('100% - 36px');`，
必须要这样才有效 `height: calc(~'100% - 36px');`

## 11.有在 vue 中使用过 echarts 吗？踩过哪些坑？如何解决的？

- 在切换 tab 时 第二个 tab 的图表无法正常显示 切换 tab 时使用方法@tab-click="handleClick"加载图表的 render 函数
- 多线图垂直坐标轴 click 事件触发问题~ 解决方法 （容器事件封装 判断事件参数处理）

## 12.mint-ui 使用过程中有没有遇到什么坑？怎么解决的？

1. 样式不容易被修改，可以用`/deep/`或者`>>>`进行复写；
2. Field 组件在 ios 上，输入框的提示信息太靠后，由 label 引起的，所以不要用它自带的 label 做提示名；自己写；
3. 无限滚动很坑很坑

## 13. vue 中使用 px2rem 同时引入第三方库的时候 第三方库的 ui 样式也变成 rem 导致错乱 请问如何解决？

vue-cli3.0 结合 lib-flexible、px2rem 实现移动端适配，完美解决第三方 ui 库样式变小问题

第一部分：项目中引入 lib-flexible

1. 项目中安装 lib-flexible
   ```bash
   npm install lib-flexible --save
   ```
2. 在项目的入口 main.js 文件中引入 lib-flexible
   ```js
   import "lib-flexible";
   ```

第二部分：使用 postcss-px2rem 自动将 css 中的 px 转换成 rem

1. 安装 postcss-px2rem

```js
npm install postcss-px2rem --save-dev
```

2. vue 中配置 在 build 下的 utils.js 中，找到 generateLoaders 方法，在这里添加 。

```js
var px2remLoader = {
  loader: "px2rem-loader",
  options: {
    remUnit: 75 //设计稿宽度/10
    // // 这是rem适配的配置  注意： remUnit在这里要根据lib-flexible的规则来配制，如果您的设计稿是750px的，用75就刚刚好。
  }
};

// generate loader string to be used with extract text plugin
function generateLoaders(loader, loaderOptions) {
  var loaders = [cssLoader, px2remLoader]; //添加px2rem 插件
  if (loader) {
    loaders.push({
      loader: loader + "-loader",
      options: Object.assign({}, loaderOptions, {
        sourceMap: options.sourceMap
      })
    });
  }
}
```

**解决方案**

首先使用`postcss-px2rem-exclude`, 卸载项目中的`postcss-px2rem`  
最后是配置 exclude 选项，需要注意的是这个配置在 vue.config.js 中式不起作用的。  
正确的配置位置是项目根目录下的 postcss.config.js 文件或者.postcssrc.js，如果你的项目没有生成这个独立文件，就需要在你的 package.js 里设置。

```js
module.exports = {
  plugins: {
    autoprefixer: {},
    "postcss-px2rem-exclude": {
      remUnit: 75,
      exclude: /node_modules|folder_name/i
      //folder_name如 vant
    }
  }
};
```

## 14.
