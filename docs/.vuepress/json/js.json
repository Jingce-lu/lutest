{
  "msg": "success",
  "result": {
    "list": [
      {
        "audit_flag": 0,
        "corp_tag": ["滴滴"],
        "date": "Fri, 19 Jun 2020 16:21:40 GMT",
        "favorite_num": 12,
        "qid": 16,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "链式调用的核心就在于调用完的方法将自身实例返回\n1）示例一\n```js\nfunction Class1() {\n    console.log('初始化')\n}\nClass1.prototype.method = function(param) {\n    console.log(param)\n    return this\n}\nlet cl = new Class1()\n//由于new 在实例化的时候this会指向创建的对象， 所以this.method这个方法会在原型链中找到。\ncl.method('第一次调用').method('第二次链式调用').method('第三次链式调用')\n```\n2）示例二\n```js\nvar obj = {\n    a: function() {\n        console.log(\"a\");\n        return this;\n    },\n    b: function() {\n        console.log(\"b\");\n        return this;\n    },\n};\nobj.a().b();\n```\n3）示例三\n```js\n// 类\nclass Math {\n    constructor(value) {\n        this.hasInit = true;\n        this.value = value;\n        if (!value) {\n            this.value = 0;\n            this.hasInit = false;\n        }\n    }\n    add() {\n        let args = [...arguments]\n        let initValue = this.hasInit ? this.value : args.shift()\n        const value = args.reduce((prev, curv) => prev + curv, initValue)\n        return new Math(value)\n    }\n    minus() {\n        let args = [...arguments]\n        let initValue = this.hasInit ? this.value : args.shift()\n        const value = args.reduce((prev, curv) => prev - curv, initValue)\n        return new Math(value)\n    }\n    mul() {\n        let args = [...arguments]\n        let initValue = this.hasInit ? this.value : args.shift()\n        const value = args.reduce((prev, curv) => prev * curv, initValue)\n        return new Math(value)\n    }\n    divide() {\n        let args = [...arguments]\n        let initValue = this.hasInit ? this.value : args.shift()\n        const value = args.reduce((prev, curv) => prev / (+curv ? curv : 1), initValue)\n        return new Math(value)\n    }\n}\n\nlet test = new Math()\nconst res = test.add(222, 333, 444).minus(333, 222).mul(3, 3).divide(2, 3)\nconsole.log(res.value)\n\n// 原型链\nNumber.prototype.add = function() {\n    let _that = this\n    _that = [...arguments].reduce((prev, curv) => prev + curv, _that)\n    return _that\n}\nNumber.prototype.minus = function() {\n    let _that = this\n    _that = [...arguments].reduce((prev, curv) => prev - curv, _that)\n    return _that\n}\nNumber.prototype.mul = function() {\n    let _that = this\n    _that = [...arguments].reduce((prev, curv) => prev * curv, _that)\n    return _that\n}\nNumber.prototype.divide = function() {\n    let _that = this\n    _that = [...arguments].reduce((prev, curv) => prev / (+curv ? curv : 1), _that)\n    return _that\n}\nlet num = 0;\nlet newNum = num.add(222, 333, 444).minus(333, 222).mul(3, 3).divide(2, 3)\nconsole.log(newNum)\n```",
          "answer": "",
          "biz_type": 1,
          "qid": 16,
          "subject": "",
          "title": "实现链式调用"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["滴滴"],
        "date": "Fri, 19 Jun 2020 16:21:40 GMT",
        "favorite_num": 16,
        "qid": 15,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "考点：函数柯里化\n\n函数柯里化概念： 柯里化（Currying）是把接受多个参数的函数转变为接受一个单一参数的函数，并且返回接受余下的参数且返回结果的新函数的技术。\n\n1）粗暴版\n\n```js\nfunction add (a) {\n    return function (b) {\n        return function (c) {\n            return a + b + c;\n        }\n    }\n}\nconsole.log(add(1)(2)(3)); // 6\n```\n\n2）柯里化解决方案\n\n- 参数长度固定\n\n```js\nconst curry = (fn) =>\n(judge = (...args) =>\n    args.length === fn.length\n    ? fn(...args)\n    : (...arg) => judge(...args, ...arg));\nconst add = (a, b, c) => a + b + c;\nconst curryAdd = curry(add);\nconsole.log(curryAdd(1)(2)(3)); // 6\nconsole.log(curryAdd(1, 2)(3)); // 6\nconsole.log(curryAdd(1)(2, 3)); // 6\n```\n\n- 参数长度不固定\n\n```js\nfunction add (...args) {\n    //求和\n    return args.reduce((a, b) => a + b)\n}\n\nfunction currying (fn) {\n    let args = []\n    return function temp (...newArgs) {\n        if (newArgs.length) {\n            args = [\n                ...args,\n                ...newArgs\n            ]\n            return temp\n        } else {\n            let val = fn.apply(this, args)\n            args = [] //保证再次调用时清空\n            return val\n        }\n    }\n}\n\nlet addCurry = currying(add)\nconsole.log(addCurry(1)(2)(3)(4, 5)())  //15\nconsole.log(addCurry(1)(2)(3, 4, 5)())  //15\nconsole.log(addCurry(1)(2, 3, 4, 5)())  //15\n```\n",
          "answer": "",
          "biz_type": 1,
          "qid": 15,
          "subject": "",
          "title": "实现 add(1)(2)(3)"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["滴滴"],
        "date": "Fri, 19 Jun 2020 16:21:40 GMT",
        "favorite_num": 15,
        "qid": 14,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "在 js 中经常会出现嵌套调用这种情况，如 a.b.c.d.e，但是这么写很容易抛出异常。你需要这么写 a && a.b && a.b.c && a.b.c.d && a.b.c.d.e，但是显得有些啰嗦与冗长了。特别是在 graphql 中，这种嵌套调用更是难以避免。\n这时就需要一个 get 函数，使用 get(a, 'b.c.d.e') 简单清晰，并且容错性提高了很多。\n\n1）代码实现\n```js\nfunction get(source, path, defaultValue = undefined) {\n  // a[3].b -> a.3.b -> [a,3,b]\n // path 中也可能是数组的路径，全部转化成 . 运算符并组成数组\n  const paths = path.replace(/\\[(\\d+)\\]/g, \".$1\").split(\".\");\n  let result = source;\n  for (const p of paths) {\n    // 注意 null 与 undefined 取属性会报错，所以使用 Object 包装一下。\n    result = Object(result)[p];\n    if (result == undefined) {\n      return defaultValue;\n    }\n  }\n  return result;\n}\n// 测试用例\nconsole.log(get({ a: null }, \"a.b.c\", 3)); // output: 3\nconsole.log(get({ a: undefined }, \"a\", 3)); // output: 3\nconsole.log(get({ a: null }, \"a\", 3)); // output: 3\nconsole.log(get({ a: [{ b: 1 }] }, \"a[0].b\", 3)); // output: 1\n```\n2）代码实现 \n不考虑数组的情况\n```js\nconst _get = (object, keys, val) => {\n return keys.split(/\\./).reduce(\n  (o, j)=>( (o || {})[j] ), \n  object\n ) || val\n}\nconsole.log(get({ a: null }, \"a.b.c\", 3)); // output: 3\nconsole.log(get({ a: undefined }, \"a\", 3)); // output: 3\nconsole.log(get({ a: null }, \"a\", 3)); // output: 3\nconsole.log(get({ a: { b: 1 } }, \"a.b\", 3)); // output: 1\n```",
          "answer": "",
          "biz_type": 1,
          "qid": 14,
          "subject": "",
          "title": "实现 lodash 的\\_.get"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["滴滴"],
        "date": "Fri, 19 Jun 2020 16:21:40 GMT",
        "favorite_num": 5,
        "qid": 30,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "```js\nconst negativeArray = els =>\n    new Proxy(els, {\n        get: (target, propKey, receiver) =>\n            Reflect.get(\n                target,\n                +propKey < 0 ? String(target.length + +propKey) : propKey,\n                receiver\n            )\n    });\nconst unicorn = negativeArray([\"京\", \"程\", \"一\", \"灯\"]);\nunicorn[-1]; \n```",
          "answer": "",
          "biz_type": 1,
          "qid": 30,
          "subject": "",
          "title": "手写用 ES6proxy 如何实现 arr[-1] 的访问"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["滴滴", "头条"],
        "date": "Fri, 19 Jun 2020 16:21:40 GMT",
        "favorite_num": 10,
        "qid": 28,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "```js\n// 发布订阅中心, on-订阅, off取消订阅, emit发布, 内部需要一个单独事件中心caches进行存储;\n\ninterface CacheProps {\n  [key: string]: Array<((data?: unknown) => void)>;\n}\n\nclass Observer {\n\n  private caches: CacheProps = {}; // 事件中心\n\n  on (eventName: string, fn: (data?: unknown) => void){ // eventName事件名-独一无二, fn订阅后执行的自定义行为\n    this.caches[eventName] = this.caches[eventName] || [];\n    this.caches[eventName].push(fn);\n  }\n\n  emit (eventName: string, data?: unknown) { // 发布 => 将订阅的事件进行统一执行\n    if (this.caches[eventName]) {\n      this.caches[eventName].forEach((fn: (data?: unknown) => void) => fn(data));\n    }\n  }\n\n  off (eventName: string, fn?: (data?: unknown) => void) { // 取消订阅 => 若fn不传, 直接取消该事件所有订阅信息\n    if (this.caches[eventName]) {\n      const newCaches = fn ? this.caches[eventName].filter(e => e !== fn) : [];\n      this.caches[eventName] = newCaches;\n    }\n  }\n  \n}\n```",
          "answer": "",
          "biz_type": 1,
          "qid": 28,
          "subject": "",
          "title": "手写发布订阅"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["滴滴"],
        "date": "Fri, 19 Jun 2020 16:21:40 GMT",
        "favorite_num": 8,
        "qid": 29,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "```js\n// 例如将 input 转成output的形式\nlet input = [\n    {\n        id: 1, val: '学校', parentId: null\n    }, {\n        id: 2, val: '班级1', parentId: 1\n    }, {\n        id: 3, val: '班级2', parentId: 1\n    }, {\n        id: 4, val: '学生1', parentId: 2\n    }, {\n        id: 5, val: '学生2', parentId: 3\n    }, {\n        id: 6, val: '学生3', parentId: 3\n    },\n]\n\nlet output = {\n    id: 1,\n    val: '学校',\n    children: [{\n        id: 2,\n        val: '班级1',\n        children: [\n            {\n                id: 4,\n                val: '学生1',\n                children: []\n            },\n            {\n                id: 5,\n                val: '学生2',\n                children: []\n            }\n        ]\n    }, {\n        id: 3,\n        val: '班级2',\n        children: [{\n            id: 6,\n            val: '学生3',\n            children: []\n        }]\n    }]\n}\n```\n\n```js\n// 代码实现\nfunction arrayToTree(array) {\n    let root = array[0]\n    array.shift()\n    let tree = {\n        id: root.id,\n        val: root.val,\n        children: array.length > 0 ? toTree(root.id, array) : []\n    }\n    return tree;\n}\n\nfunction toTree(parenId, array) {\n    let children = []\n    let len = array.length\n    for (let i = 0; i < len; i++) {\n        let node = array[i]\n        if (node.parentId === parenId) {\n            children.push({\n                id: node.id,\n                val: node.val,\n                children: toTree(node.id, array)\n            })\n        }\n    }\n    return children\n}\n\nconsole.log(arrayToTree(input))\n```",
          "answer": "",
          "biz_type": 1,
          "qid": 29,
          "subject": "",
          "title": "手写数组转树"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["滴滴", "虎扑", "挖财", "58", "头条"],
        "date": "Fri, 19 Jun 2020 16:21:40 GMT",
        "favorite_num": 45,
        "qid": 9,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "1）防抖\n- 原理：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。\n- 适用场景：\n  - 按钮提交场景：防止多次提交按钮，只执行最后提交的一次\n  - 搜索框联想场景：防止联想发送请求，只发送最后一次输入\n- 简易版实现\n\n```js\nfunction debounce(func, wait) {\n    let timeout;\n    return function () {\n        const context = this;\n        const args = arguments;\n        clearTimeout(timeout)\n        timeout = setTimeout(function(){\n            func.apply(context, args)\n        }, wait);\n    }\n}\n```\n\n- 立即执行版实现\n  - 有时希望立刻执行函数，然后等到停止触发 n 秒后，才可以重新触发执行。\n\n```js\n// 有时希望立刻执行函数，然后等到停止触发 n 秒后，才可以重新触发执行。\nfunction debounce(func, wait, immediate) {\n  let timeout;\n  return function () {\n    const context = this;\n    const args = arguments;\n    if (timeout) clearTimeout(timeout);\n    if (immediate) {\n      const callNow = !timeout;\n      timeout = setTimeout(function () {\n        timeout = null;\n      }, wait)\n      if (callNow) func.apply(context, args)\n    } else {\n      timeout = setTimeout(function () {\n        func.apply(context, args)\n      }, wait);\n    }\n  }\n}\n```\n\n- 返回值版实现\n  - func函数可能会有返回值，所以需要返回函数结果，但是当 immediate 为 false 的时候，因为使用了 setTimeout ，我们将 func.apply(context, args) 的返回值赋给变量，最后再 return 的时候，值将会一直是 undefined，所以只在 immediate 为 true 的时候返回函数的执行结果。\n\n```js\nfunction debounce(func, wait, immediate) {\n  let timeout, result;\n  return function () {\n    const context = this;\n    const args = arguments;\n    if (timeout) clearTimeout(timeout);\n    if (immediate) {\n      const callNow = !timeout;\n      timeout = setTimeout(function () {\n        timeout = null;\n      }, wait)\n      if (callNow) result = func.apply(context, args)\n    }\n    else {\n      timeout = setTimeout(function () {\n        func.apply(context, args)\n      }, wait);\n    }\n    return result;\n  }\n}\n```\n\n2）节流\n- 原理：规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。\n- 适用场景\n  - 拖拽场景：固定时间内只执行一次，防止超高频次触发位置变动\n  - 缩放场景：监控浏览器resize\n- 使用时间戳实现\n  - 使用时间戳，当触发事件的时候，我们取出当前的时间戳，然后减去之前的时间戳(最一开始值设为 0 )，如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，如果小于，就不执行。\n\n```js\nfunction throttle(func, wait) {\n  let context, args;\n  let previous = 0;\n\n  return function () {\n    let now = +new Date();\n    context = this;\n    args = arguments;\n    if (now - previous > wait) {\n      func.apply(context, args);\n      previous = now;\n    }\n  }\n}\n```\n\n- 使用定时器实现\n  - 当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行，直到定时器执行，然后执行函数，清空定时器，这样就可以设置下个定时器。\n\n```js\nfunction throttle(func, wait) {\n  let timeout;\n  return function () {\n    const context = this;\n    const args = arguments;\n    if (!timeout) {\n      timeout = setTimeout(function () {\n        timeout = null;\n        func.apply(context, args)\n      }, wait)\n    }\n\n  }\n}\n```\n",
          "answer": "",
          "biz_type": 1,
          "qid": 9,
          "subject": "",
          "title": "介绍防抖节流原理、区别以及应用，并用JavaScript进行实现"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["海康威视"],
        "date": "Fri, 19 Jun 2020 16:21:40 GMT",
        "favorite_num": 14,
        "qid": 18,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "1）定义\n\n- 数组是一个特殊对象,与常规对象的区别：\n   1. 当由新元素添加到列表中时，自动更新length属性\n   2. 设置length属性，可以截断数组\n   3. 从Array.protoype中继承了方法\n   4. 属性为'Array'\n- 类数组是一个拥有length属性，并且他属性为非负整数的普通对象，类数组不能直接调用数组方法。\n\n2）区别\n\n本质：类数组是简单对象，它的原型关系与数组不同。\n\n```js\n// 原型关系和原始值转换\nlet arrayLike = {\n    length: 10,\n};\nconsole.log(arrayLike instanceof Array); // false\nconsole.log(arrayLike.__proto__.constructor === Array); // false\nconsole.log(arrayLike.toString()); // [object Object]\nconsole.log(arrayLike.valueOf()); // {length: 10}\n\nlet array = [];\nconsole.log(array instanceof Array); // true\nconsole.log(array.__proto__.constructor === Array); // true\nconsole.log(array.toString()); // ''\nconsole.log(array.valueOf()); // []\n```\n\n3）类数组转换为数组\n\n- 转换方法\n   1. 使用 `Array.from()`\n   2. 使用 `Array.prototype.slice.call()` \n   3. 使用 `Array.prototype.forEach()` 进行属性遍历并组成新的数组 \n- 转换须知\n  - 转换后的数组长度由 `length` 属性决定。索引不连续时转换结果是连续的，会自动补位。\n  - 代码示例\n\n```js\nlet al1 = {\n    length: 4,\n    0: 0,\n    1: 1,\n    3: 3,\n    4: 4,\n    5: 5,\n};\nconsole.log(Array.from(al1)) // [0, 1, undefined, 3]\n```\n\n  - ②仅考虑 0或正整数 的索引\n\n```js\n// 代码示例\nlet al2 = {\n    length: 4,\n    '-1': -1,\n    '0': 0,\n    a: 'a',\n    1: 1\n};\nconsole.log(Array.from(al2)); // [0, 1, undefined, undefined]\n```\n\n  - ③使用slice转换产生稀疏数组\n\n```js\n// 代码示例\nlet al2 = {\n    length: 4,\n    '-1': -1,\n    '0': 0,\n    a: 'a',\n    1: 1\n};\nconsole.log(Array.prototype.slice.call(al2)); //[0, 1, empty × 2]\n```\n\n4）使用数组方法操作类数组注意地方\n\n```js\n  let arrayLike2 = {\n    2: 3,\n    3: 4,\n    length: 2,\n    push: Array.prototype.push\n  }\n\n  // push 操作的是索引值为 length 的位置\n  arrayLike2.push(1);\n  console.log(arrayLike2); // {2: 1, 3: 4, length: 3, push: ƒ}\n  arrayLike2.push(2);\n  console.log(arrayLike2); // {2: 1, 3: 2, length: 4, push: ƒ}\n```",
          "answer": "",
          "biz_type": 1,
          "qid": 18,
          "subject": "",
          "title": "类数组和数组的区别，dom 的类数组如何转换成数组"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["滴滴", "头条", "喜马拉雅", "兑吧", "寺库", "百分点", "58", "安居客"],
        "date": "Fri, 19 Jun 2020 16:21:40 GMT",
        "favorite_num": 18,
        "qid": 23,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "1）Promise基本特性\n- 1、Promise有三种状态：pending(进行中)、fulfilled(已成功)、rejected(已失败)\n- 2、Promise对象接受一个回调函数作为参数, 该回调函数接受两个参数，分别是成功时的回调resolve和失败时的回调reject；另外resolve的参数除了正常值以外， 还可能是一个Promise对象的实例；reject的参数通常是一个Error对象的实例。\n- 3、then方法返回一个新的Promise实例，并接收两个参数onResolved(fulfilled状态的回调)；onRejected(rejected状态的回调，该参数可选)\n- 4、catch方法返回一个新的Promise实例\n- 5、finally方法不管Promise状态如何都会执行，该方法的回调函数不接受任何参数\n- 6、Promise.all()方法将多个多个Promise实例，包装成一个新的Promise实例，该方法接受一个由Promise对象组成的数组作为参数(Promise.all()方法的参数可以不是数组，但必须具有Iterator接口，且返回的每个成员都是Promise实例)，注意参数中只要有一个实例触发catch方法，都会触发Promise.all()方法返回的新的实例的catch方法，如果参数中的某个实例本身调用了catch方法，将不会触发Promise.all()方法返回的新实例的catch方法\n- 7、Promise.race()方法的参数与Promise.all方法一样，参数中的实例只要有一个率先改变状态就会将该实例的状态传给Promise.race()方法，并将返回值作为Promise.race()方法产生的Promise实例的返回值\n- 8、Promise.resolve()将现有对象转为Promise对象，如果该方法的参数为一个Promise对象，Promise.resolve()将不做任何处理；如果参数thenable对象(即具有then方法)，Promise.resolve()将该对象转为Promise对象并立即执行then方法；如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为fulfilled，其参数将会作为then方法中onResolved回调函数的参数，如果Promise.resolve方法不带参数，会直接返回一个fulfilled状态的 Promise 对象。需要注意的是，立即resolve()的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时。\n- 9、Promise.reject()同样返回一个新的Promise对象，状态为rejected，无论传入任何参数都将作为reject()的参数\n\n\n2）Promise优点\n\n- ①统一异步 API\n  - Promise 的一个重要优点是它将逐渐被用作浏览器的异步 API ，统一现在各种各样的 API ，以及不兼容的模式和手法。\n- ②Promise 与事件对比\n  - 和事件相比较， Promise 更适合处理一次性的结果。在结果计算出来之前或之后注册回调函数都是可以的，都可以拿到正确的值。 Promise 的这个优点很自然。但是，不能使用 Promise 处理多次触发的事件。链式处理是 Promise 的又一优点，但是事件却不能这样链式处理。\n- ③Promise 与回调对比\n  - 解决了回调地狱的问题，将异步操作以同步操作的流程表达出来。\n- ④Promise 带来的额外好处是包含了更好的错误处理方式（包含了异常处理），并且写起来很轻松（因为可以重用一些同步的工具，比如 Array.prototype.map() ）。\n\n3）Promise缺点\n\n- 1、无法取消Promise，一旦新建它就会立即执行，无法中途取消。\n- 2、如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。\n- 3、当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。\n- 4、Promise 真正执行回调的时候，定义 Promise 那部分实际上已经走完了，所以 Promise 的报错堆栈上下文不太友好。\n\n\n4）简单代码实现\n最简单的Promise实现有7个主要属性, state(状态), value(成功返回值), reason(错误信息), resolve方法, reject方法, then方法.\n\n```js\nclass Promise{\n  constructor(executor) {\n    this.state = 'pending';\n    this.value = undefined;\n    this.reason = undefined;\n    let resolve = value => {\n      if (this.state === 'pending') {\n        this.state = 'fulfilled';\n        this.value = value;\n      }\n    };\n    let reject = reason => {\n      if (this.state === 'pending') {\n        this.state = 'rejected';\n        this.reason = reason;\n      }\n    };\n    try {\n      // 立即执行函数\n      executor(resolve, reject);\n    } catch (err) {\n      reject(err);\n    }\n  }\n  then(onFulfilled, onRejected) {\n    if (this.state === 'fulfilled') {\n      let x = onFulfilled(this.value);\n    };\n    if (this.state === 'rejected') {\n      let x = onRejected(this.reason);\n    };\n  }\n}\n```\n\n5）面试够用版\n\n```js\nfunction myPromise(constructor){ let self=this;\n  self.status=\"pending\" //定义状态改变前的初始状态 \n  self.value=undefined;//定义状态为resolved的时候的状态 \n  self.reason=undefined;//定义状态为rejected的时候的状态 \n  function resolve(value){\n    //两个===\"pending\"，保证了了状态的改变是不不可逆的 \n    if(self.status===\"pending\"){\n      self.value=value;\n      self.status=\"resolved\"; \n    }\n  }\n  function reject(reason){\n     //两个===\"pending\"，保证了了状态的改变是不不可逆的\n     if(self.status===\"pending\"){\n        self.reason=reason;\n        self.status=\"rejected\"; \n      }\n  }\n  //捕获构造异常 \n  try{\n      constructor(resolve,reject);\n  }catch(e){\n    reject(e);\n    } \n}\nmyPromise.prototype.then=function(onFullfilled,onRejected){ \n  let self=this;\n  switch(self.status){\n    case \"resolved\": onFullfilled(self.value); break;\n    case \"rejected\": onRejected(self.reason); break;\n    default: \n  }\n}\n\n// 测试\nvar p=new myPromise(function(resolve,reject){resolve(1)}); \np.then(function(x){console.log(x)})\n//输出1\n```\n\n6）大厂专供版\n\n```js\nconst PENDING = \"pending\"; \nconst FULFILLED = \"fulfilled\"; \nconst REJECTED = \"rejected\";\nfunction Promise(excutor) {\n  let that = this; // 缓存当前promise实例例对象\n  that.status = PENDING; // 初始状态\n  that.value = undefined; // fulfilled状态时 返回的信息\n  that.reason = undefined; // rejected状态时 拒绝的原因 \n  that.onFulfilledCallbacks = []; // 存储fulfilled状态对应的onFulfilled函数\n  that.onRejectedCallbacks = []; // 存储rejected状态对应的onRejected函数\n  function resolve(value) { // value成功态时接收的终值\n    if(value instanceof Promise) {\n      return value.then(resolve, reject);\n    }\n    // 实践中要确保 onFulfilled 和 onRejected ⽅方法异步执⾏行行，且应该在 then ⽅方法被调⽤用的那⼀一轮事件循环之后的新执⾏行行栈中执⾏行行。\n    setTimeout(() => {\n      // 调⽤用resolve 回调对应onFulfilled函数\n      if (that.status === PENDING) {\n        // 只能由pending状态 => fulfilled状态 (避免调⽤用多次resolve reject)\n        that.status = FULFILLED;\n        that.value = value;\n        that.onFulfilledCallbacks.forEach(cb => cb(that.value));\n      }\n    });\n  }\n  function reject(reason) { // reason失败态时接收的拒因\n    setTimeout(() => {\n      // 调⽤用reject 回调对应onRejected函数\n      if (that.status === PENDING) {\n        // 只能由pending状态 => rejected状态 (避免调⽤用多次resolve reject)\n        that.status = REJECTED;\n        that.reason = reason;\n        that.onRejectedCallbacks.forEach(cb => cb(that.reason));\n      }\n    });\n  }\n\n  // 捕获在excutor执⾏行行器器中抛出的异常\n  // new Promise((resolve, reject) => {\n  //     throw new Error('error in excutor')\n  // })\n  try {\n    excutor(resolve, reject);\n  } catch (e) {\n    reject(e);\n  }\n}\nPromise.prototype.then = function(onFulfilled, onRejected) {\n  const that = this;\n  let newPromise;\n  // 处理理参数默认值 保证参数后续能够继续执⾏行行\n  onFulfilled = typeof onFulfilled === \"function\" ? onFulfilled : value => value;\n  onRejected = typeof onRejected === \"function\" ? onRejected : reason => {\n    throw reason;\n  };\n  if (that.status === FULFILLED) { // 成功态\n    return newPromise = new Promise((resolve, reject) => {\n      setTimeout(() => {\n        try{\n          let x = onFulfilled(that.value);\n          resolvePromise(newPromise, x, resolve, reject); //新的promise resolve 上⼀一个onFulfilled的返回值\n        } catch(e) {\n          reject(e); // 捕获前⾯面onFulfilled中抛出的异常then(onFulfilled, onRejected);\n        }\n      });\n    })\n  }\n  if (that.status === REJECTED) { // 失败态\n    return newPromise = new Promise((resolve, reject) => {\n      setTimeout(() => {\n        try {\n          let x = onRejected(that.reason);\n          resolvePromise(newPromise, x, resolve, reject);\n        } catch(e) {\n          reject(e);\n        }\n      });\n    });\n  }\n  if (that.status === PENDING) { // 等待态\n// 当异步调⽤用resolve/rejected时 将onFulfilled/onRejected收集暂存到集合中\n    return newPromise = new Promise((resolve, reject) => {\n      that.onFulfilledCallbacks.push((value) => {\n        try {\n          let x = onFulfilled(value);\n          resolvePromise(newPromise, x, resolve, reject);\n        } catch(e) {\n          reject(e);\n        }\n      });\n      that.onRejectedCallbacks.push((reason) => {\n        try {\n          let x = onRejected(reason);\n          resolvePromise(newPromise, x, resolve, reject);\n        } catch(e) {\n          reject(e);\n        }\n      });\n    });\n  }\n};\n```",
          "answer": "",
          "biz_type": 1,
          "qid": 23,
          "subject": "",
          "title": "介绍下 promise 的特性、优缺点，内部是如何实现的，动手实现 Promise"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["滴滴", "头条", "有赞", "微医"],
        "date": "Fri, 19 Jun 2020 16:21:40 GMT",
        "favorite_num": 16,
        "qid": 24,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "**1) 核心思路**\n\n- ①接收一个 Promise 实例的数组或具有 Iterator 接口的对象作为参数\n- ②这个方法返回一个新的 promise 对象，\n- ③遍历传入的参数，用Promise.resolve()将参数\"包一层\"，使其变成一个promise对象\n- ④参数所有回调成功才是成功，返回值数组与参数顺序一致\n- ⑤参数数组其中一个失败，则触发失败状态，第一个触发失败的 Promise 错误信息作为 Promise.all 的错误信息。\n\n**2）实现代码**\n一般来说，Promise.all 用来处理多个并发请求，也是为了页面数据构造的方便，将一个页面所用到的在不同接口的数据一起请求过来，不过，如果其中一个接口失败了，多个请求也就失败了，页面可能啥也出不来，这就看当前页面的耦合程度了～\n\n```js\nfunction promiseAll(promises) {\n  return new Promise(function(resolve, reject) {\n    if(!Array.isArray(promises)){\n        throw new TypeError(`argument must be a array`)\n    }\n    var resolvedCounter = 0;\n    var promiseNum = promises.length;\n    var resolvedResult = [];\n    for (let i = 0; i < promiseNum; i++) {\n      Promise.resolve(promises[i]).then(value=>{\n        resolvedCounter++;\n        resolvedResult[i] = value;\n        if (resolvedCounter == promiseNum) {\n            return resolve(resolvedResult)\n          }\n      },error=>{\n        return reject(error)\n      })\n    }\n  })\n}\n\n// test\nlet p1 = new Promise(function (resolve, reject) {\n    setTimeout(function () {\n        resolve(1)\n    }, 1000)\n})\nlet p2 = new Promise(function (resolve, reject) {\n    setTimeout(function () {\n        resolve(2)\n    }, 2000)\n})\nlet p3 = new Promise(function (resolve, reject) {\n    setTimeout(function () {\n        resolve(3)\n    }, 3000)\n})\npromiseAll([p3, p1, p2]).then(res => {\n    console.log(res) // [3, 1, 2]\n})\n```",
          "answer": "",
          "biz_type": 1,
          "qid": 24,
          "subject": "```js\nPromise.all = function (arr) {\n  // 实现代码\n};\n```\n",
          "title": "实现 Promise.all"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["滴滴", "伴鱼", "高德", "自如", "虎扑", "58"],
        "date": "Fri, 19 Jun 2020 16:21:40 GMT",
        "favorite_num": 22,
        "qid": 20,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "#### 1）为什么会有Event Loop\n\n​    JavaScript的任务分为两种`同步`和`异步`，它们的处理方式也各自不同，**同步任务**是直接放在主线程上排队依次执行，**异步任务**会放在任务队列中，若有多个异步任务则需要在任务队列中排队等待，任务队列类似于缓冲区，任务下一步会被移到**调用栈**然后主线程执行调用栈的任务。\n\n> **调用栈**：调用栈是一个栈结构，函数调用会形成一个栈帧，帧中包含了当前执行函数的参数和局部变量等上下文信息，函数执行完后，它的执行上下文会从栈中弹出。\n\n​    JavaScript是`单线程`的，单线程是指 js引擎中解析和执行js代码的线程只有一个（主线程），每次只能做一件事情，然而`ajax`请求中，主线程在等待响应的过程中回去做其他事情，浏览器先在事件表注册ajax的回调函数，响应回来后回调函数被添加到任务队列中等待执行，不会造成线程阻塞，所以说js处理ajax请求的方式是异步的。\n\n​    综上所述，检查调用栈是否为空以及讲某个任务添加到调用栈中的个过程就是event loop，这就是JavaScript实现异步的核心。\n\n\n\n#### 2）浏览器中的 Event Loop\n\n##### Micro-Task 与 Macro-Task\n\n浏览器端事件循环中的异步队列有两种：macro（宏任务）队列和 micro（微任务）队列。\n\n常见的 macro-task：`setTimeout`、`setInterval`、`script（整体代码）`、` I/O 操作`、`UI 渲染`等。\n\n常见的 micro-task: `new Promise().then(回调)`、`MutationObserve `等。\n\n\n\n##### requestAnimationFrame\n\nrequestAnimationFrame也属于异步执行的方法，但该方法既不属于宏任务，也不属于微任务。按照MDN中的定义：\n\n> `window.requestAnimationFrame()` 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行\n\nrequestAnimationFrame是GUI渲染之前执行，但在`Micro-Task`之后，不过requestAnimationFrame不一定会在当前帧必须执行，由浏览器根据当前的策略自行决定在哪一帧执行。\n\n\n\n##### event loop过程\n\n![](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-20-1.jpg)\n\n1. 检查macrotask队列是否为空，非空则到2，为空则到3\n2. 执行macrotask中的一个任务\n3. 继续检查microtask队列是否为空，若有则到4，否则到5\n4. 取出microtask中的任务执行，执行完成返回到步骤3\n5. 执行视图更新\n\n> 当某个宏任务执行完后,会查看是否有微任务队列。如果有，先执行微任务队列中的所有任务，如果没有，会读取宏任务队列中排在最前的任务，执行宏任务的过程中，遇到微任务，依次加入微任务队列。栈空后，再次读取微任务队列里的任务，依次类推。\n\n\n\n#### 3）node中的 Event Loop\n\nNode 中的 Event Loop 和浏览器中的是完全不相同的东西。Node.js采用V8作为js的解析引擎，而I/O处理方面使用了自己设计的libuv，libuv是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的API，事件循环机制也是它里面的实现\n\n![](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-20-2.png)\n\n根据上图node的运行机制如下\n\n1. V8引擎解析JavaScript脚本。\n2. 解析后的代码，调用Node API。\n3. libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。\n4. V8引擎再将结果返回给用户。\n\n\n\n##### 六大阶段\n\n其中libuv引擎中的事件循环分为 6 个阶段，它们会按照顺序反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。\n\n![](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-20-3.png)\n\n1. `timers` 阶段：这个阶段执行timer（setTimeout、setInterval）的回调，并且是由 poll 阶段控制的。\n2. `I/O callbacks` 阶段：处理一些上一轮循环中的少数未执行的 I/O 回调\n3. `idle, prepare` 阶段：仅node内部使用\n4. `poll` 阶段：获取新的I/O事件, 适当的条件下node将阻塞在这里\n5. `check` 阶段：执行 setImmediate() 的回调\n6. `close callbacks` 阶段：执行 socket 的 close 事件回调\n\n\n\n#####  poll阶段\n\npoll 是一个至关重要的阶段，这一阶段中，系统会做两件事情\n\n1.回到 timer 阶段执行回调\n\n2.执行 I/O 回调\n\n并且在进入该阶段时如果没有设定了 timer 的话，会发生以下两件事情\n\n- 如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制\n- 如果 poll 队列为空时，会有两件事发生\n  - 如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调\n  - 如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去\n\n当然设定了 timer 的话且 poll 队列为空，则会判断是否有 timer 超时，如果有的话会回到 timer 阶段执行回调。\n\n\n\n##### Micro-Task 与 Macro-Task\n\nNode端事件循环中的异步队列也是这两种：macro（宏任务）队列和 micro（微任务）队列。\n\n- 常见的 macro-task 比如：`setTimeout`、`setInterval`、 `setImmediate`、`script（整体代码`）、` I/O 操作等`。\n- 常见的 micro-task 比如: `process.nextTick`、`new Promise().then(回调)`等。\n\n\n\n##### setTimeout 和 setImmediate\n\n二者非常相似，区别主要在于调用时机不同。\n\n- setImmediate 设计在poll阶段完成时执行，即check阶段；\n- setTimeout 设计在poll阶段为空闲时，且设定时间到达后执行，但它在timer阶段执行\n\n```javascript\nsetTimeout(function timeout () {\n  console.log('timeout');\n},0);\nsetImmediate(function immediate () {\n  console.log('immediate');\n});\n```\n\n1. 对于以上代码来说，setTimeout 可能执行在前，也可能执行在后。\n2. 首先 setTimeout(fn, 0) === setTimeout(fn, 1)，这是由源码决定的 进入事件循环也是需要成本的，如果在准备时候花费了大于 1ms 的时间，那么在 timer 阶段就会直接执行 setTimeout 回调\n3. 如果准备时间花费小于 1ms，那么就是 setImmediate 回调先执行了\n\n\n\n#####  process.nextTick\n\n这个函数其实是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行\n\n\n\n#### 4）Node与浏览器的 Event Loop 差异\n\n![](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-20-4.png)\n\n- Node端，microtask 在事件循环的各个阶段之间执行\n- 浏览器端，microtask 在事件循环的 macrotask 执行完之后执行\n",
          "answer": "",
          "biz_type": 1,
          "qid": 20,
          "subject": "",
          "title": "说一下事件循环机制(node、浏览器)"
        },
        "tech_tag": ["Node", "JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [
          "滴滴",
          "携程",
          "喜马拉雅",
          "微医",
          "蘑菇街",
          "酷家乐",
          "腾讯应用宝",
          "安居客"
        ],
        "date": "Fri, 19 Jun 2020 16:21:40 GMT",
        "favorite_num": 32,
        "qid": 11,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "### 答案\n\n#### 1）什么是闭包\n\n函数执行后返回结果是一个内部函数，并被外部变量所引用，如果内部函数持有被执行函数作用域的变量，即形成了闭包。\n\n可以在内部函数访问到外部函数作用域。使用闭包，一可以读取函数中的变量，二可以将函数中的变量存储在内存中，保护变量不被污染。而正因闭包会把函数中的变量值存储在内存中，会对内存有消耗，所以不能滥用闭包，否则会影响网页性能，造成内存泄漏。当不需要使用闭包时，要及时释放内存，可将内层函数对象的变量赋值为null。\n\n\n#### 2）闭包原理\n\n函数执行分成两个阶段(预编译阶段和执行阶段)。\n\n- 在预编译阶段，如果发现内部函数使用了外部函数的变量，则会在内存中创建一个“闭包”对象并保存对应变量值，如果已存在“闭包”，则只需要增加对应属性值即可。\n- 执行完后，函数执行上下文会被销毁，函数对“闭包”对象的引用也会被销毁，但其内部函数还持用该“闭包”的引用，所以内部函数可以继续使用“外部函数”中的变量\n\n利用了函数作用域链的特性，一个函数内部定义的函数会将包含外部函数的活动对象添加到它的作用域链中，函数执行完毕，其执行作用域链销毁，但因内部函数的作用域链仍然在引用这个活动对象，所以其活动对象不会被销毁，直到内部函数被烧毁后才被销毁。\n\n#### 3）优点\n\n1. 可以从内部函数访问外部函数的作用域中的变量，且访问到的变量长期驻扎在内存中，可供之后使用\n2. 避免变量污染全局\n3. 把变量存到独立的作用域，作为私有成员存在\n\n#### 4）缺点\n\n1. 对内存消耗有负面影响。因内部函数保存了对外部变量的引用，导致无法被垃圾回收，增大内存使用量，所以使用不当会导致内存泄漏\n2. 对处理速度具有负面影响。闭包的层级决定了引用的外部变量在查找时经过的作用域链长度\n3. 可能获取到意外的值(captured value)\n\n#### 4）应用场景\n\n**应用场景一：** 典型应用是模块封装，在各模块规范出现之前，都是用这样的方式防止变量污染全局。\n\n```js\nvar Yideng = (function () {\n    // 这样声明为模块私有变量，外界无法直接访问\n    var foo = 0;\n\n    function Yideng() {}\n    Yideng.prototype.bar = function bar() {\n        return foo;\n    };\n    return Yideng;\n}());\n```\n\n**应用场景二：** 在循环中创建闭包，防止取到意外的值。\n\n如下代码，无论哪个元素触发事件，都会弹出 3。因为函数执行后引用的 i 是同一个，而 i 在循环结束后就是 3\n\n```js\nfor (var i = 0; i < 3; i++) {\n    document.getElementById('id' + i).onfocus = function() {\n      alert(i);\n    };\n}\n//可用闭包解决\nfunction makeCallback(num) {\n  return function() {\n    alert(num);\n  };\n}\nfor (var i = 0; i < 3; i++) {\n    document.getElementById('id' + i).onfocus = makeCallback(i);\n}\n```\n",
          "answer": "",
          "biz_type": 1,
          "qid": 11,
          "subject": "",
          "title": "对闭包的看法，为什么要用闭包？说一下闭包原理以及应用场景"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["头条"],
        "date": "Fri, 19 Jun 2020 16:21:39 GMT",
        "favorite_num": 4,
        "qid": 1,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "```js\nconst mySetInterval = (fn, a, b) => {\n    let _interval = [a, a + b, a + 2 * b]\n    let _currentInterval = null\n    let _idx = 0\n\n    let _mySetInterval = _t => {\n        if(_idx < _interval.length) {\n            clearInterval(_currentInterval)\n            _currentInterval =  setInterval(() => {\n                fn()\n                _idx++\n                _mySetInterval(_interval[_idx])\n            }, _t)\n            return _currentInterval\n        } else {\n            _idx = 0\n            _mySetInterval(_interval[_idx])\n        }\n    }\n    _mySetInterval(_interval[_idx])\n    return _currentInterval\n}\n\nconst myClear = (_interval) => {\n    clearInterval(_interval)\n}\nlet interval = mySetInterval(() => {\n    console.timeEnd('定时器')\n    console.time('定时器')\n}, 1000, 1000)\n```",
          "answer": "",
          "biz_type": 1,
          "qid": 1,
          "subject": "",
          "title": "写一个 mySetInterVal(fn, a, b),每次间隔 a,a+b,a+2b 的时间，然后写一个 myClear，停止上面的 mySetInterVal"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["玄武科技"],
        "date": "Fri, 19 Jun 2020 16:20:44 GMT",
        "favorite_num": 4,
        "qid": 715,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "目前流行的js模块化规范有CommonJS、AMD、CMD以及ES6的模块系统。\n\n### 一、CommonJS\n\n**CommonJS的出发点:** JS没有完善的模块系统，标准库较少，缺少包管理工具。伴随着NodeJS的兴起，能让JS在任何地方运行，特别是服务端，也达到了具备开发大型项目的能力，所以CommonJS营运而生。\n\nNode.js是commonJS规范的主要实践者，它有四个重要的环境变量为模块化的实现提供支持：`module`、`exports`、`require`、`global`。实际使用时，用`module.exports`定义当前模块对外输出的接口（不推荐直接用`exports`），用`require`加载模块。\n\ncommonJS用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。\n\n- 暴露模块：`module.exports = value`或`exports.xxx = value`\n- 引入模块：`require(xxx)`\n\n#### 1.CommonJS规范\n\n- 一个文件就是一个模块，拥有单独的作用域\n- 普通方式定义的变量、函数、对象都属于该模块内\n- 通过require来加载模块\n- 通过exports和module.exports来暴露块中的内容\n\n#### 2.注意\n\n1. 当exports和module.exports同时存在时，module.exports会覆盖exports\n2. 当模块内全是exports时，就等同于module.exports\n3. exports就是module.exports的子集\n4. 所有代码都运行在模块作用域，不会污染全局作用域\n5. 模块可以多次加载，但只会在第一次加载时候运行，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果\n6. 模块加载顺讯，按照代码出现的顺序同步加载\n7. __dirname代表当前磨具爱文件所在的文件夹路径\n8. __filename代表当前模块文件所在的文件夹路径+文件名\n\n### 二、ES6模块化\n\nES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：`export`和`import`。`export`命令用于规定模块的对外接口，`import`命令用于输入其他模块提供的功能。\n\n其实ES6还提供了`export default`命令，为模块指定默认输出，对应的`import`语句不需要使用大括号。这也更趋近于AMD的引用写法。\n\nES6的模块不是对象，`import`命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。也正因为这个，使得静态分析成为可能。\n\n#### 1.export\n\nexport可以导出的是一个对象中包含的多个属性、方法。export default只能导出一个可以不具名的函数。我们可以通过import进行引用。同时，我们也可以直接使用require使用，原因是webpack起了server相关。\n\n#### 2.import\n\n1. import {fn} from './xxx/xxx' ( export 导出方式的 引用方式 )\n2. import fn from './xxx/xxx1' ( export default 导出方式的 引用方式 )\n\n### 三、AMD\n\nAsynchronous Module Definition，异步加载模块。它是一个在浏览器端模块化开发的规范，不是原生js的规范，使用AMD规范进行页面开发需要用到对应的函数库，RequireJS。\n\nAMD规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。\n\n使用require.js实现AMD规范的模块化：用`require.config()`指定引用路径等，用`define()`定义模块，用`require()`加载模块。\n\n```js\n//定义模块\ndefine('moduleName',['a','b'],function(ma,mb){\n    return someExportValue;\n})\n//引入模块\nrequire(['a','b'],function(ma,mb){\n  /*code*/\n})\n```\n\n#### 1.RequireJS主要解决的问题\n\n- 文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器\n- js加载的时候浏览器会停止页面渲染，加载文件愈多，页面相应事件就越长\n- 异步前置加载\n\n#### 2.语法\n\n\n`define(id,dependencies,factory)`\n\n- id 可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名（去掉拓展名）\n- dependencies 是一个当前模块用来的模块名称数组\n- factory 工厂方法，模块初始化要执行的函数或对象，如果为函数，它应该只被执行一次，如果是对象，此对象应该为模块的输出值。\n\n\n### 四、CMD\n\nCMD是另一种js模块化方案，它与AMD很类似，不同点在于：AMD 推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行。此规范其实是在sea.js推广过程中产生的。\n\n因为CMD推崇一个文件一个模块，所以经常就用文件名作为模块id； CMD推崇依赖就近，所以一般不在define的参数中写依赖，而是在factory中写。\n\n`define(id, deps, factory)`\n\nfactory有三个参数： `function(require, exports, module){}`\n\n1. require require 是 factory 函数的第一个参数，require 是一个方法，接受 模块标识 作为唯一参数，用来获取其他模块提供的接口；\n2. exports exports 是一个对象，用来向外提供模块接口；\n3. module module是一个对象，上面存储了与当前模块相关联的一些属性和方法。\n\n```js\n//定义没有依赖的模块\ndefine(function(require,exports,module){\n  exports.xxx = vaule;\n  module.exports = value;\n})\n//定义有依赖的模块\ndefine(function(require,exports,module){\n  //同步引入模块\n  var module1 = require(\"./module1.js\");\n  //异步引入模块\n  require.async(\"./module2.js\",function(m2){\n    /***/\n  })\n  //暴露接口\n  exports.xxx = value;\n})\n\n//引入模块\ndefine(function(require){\n  const m1 = require(\"./module1.js\");\n  m1.show();\n})\n```\n\n### 五、UMD通用模块规范\n\n一种整合了CommonJS和AMD规范的方法，希望能解决跨平台模块方案。\n\n**运行原理**\n\n- UMD先判断是否支持Node.js的模块（exports）是否存在，存在则使用Node.js模块模式。\n- 再判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。\n\n```js\n(function (window, factory) {\n    if (typeof exports === 'object') {  \n        module.exports = factory();\n    } else if (typeof define === 'function' && define.amd) {\n        define(factory);\n    } else {    \n        window.eventUtil = factory();\n    }\n})(this, function () {\n    //module ...\n});\n```\n\n### 六、总结\n\ncommonjs是同步加载的。主要是在nodejs 也就是服务端应用的模块化机制，通过 `module.export` 导出声明，通过 `require('')` 加载。每个文件都是一个模块。他有自己的作用域，文件内的变量，属性函数等不能被外界访问。node会将模块缓存，第二次加载会直接在缓存中获取。\n\nAMD是异步加载的。主要应用在浏览器环境下。requireJS是遵循AMD规范的模块化工具。他是通过 `define()` 定义声明，通过 `require('',function(){})` 加载。\n\nES6的模块化加载时通过 `export default` 导出,用import导入 可通过 `{}` 对导出的内容进行解构。\n\nES6的模块的运行机制与common不一样，js引擎对脚本静态分析的时候，遇到模块加载指令后会生成一个只读引用，等到脚本真正执行的时候才会通过引用去模块中获取值，在引用到执行的过程中 模块中的值发生了变化，导入的这里也会跟着变，ES6模块是动态引用，并不会缓存值，模块里总是绑定其所在的模块。",
          "answer": "",
          "biz_type": 1,
          "qid": 715,
          "subject": "",
          "title": "请列出目前主流的 JavaScript 模块化实现的技术有哪些？说出它们的区别？"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["爱范儿", "道一云"],
        "date": "Fri, 19 Jun 2020 16:20:44 GMT",
        "favorite_num": 8,
        "qid": 697,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "#### 代码实现\n\n```js\n// 直接实现\ndocument.onclick = function(e){\n    let e = e || window.event;//处理兼容，获取事件的对象\n    let o = e[\"target\"] || e[\"srcElement\"];//处理兼容，获取事件目标\n    alert(o.tagName.toLowerCase()); \n}\n\n// 优雅实现\nfunction elementName(evt) {\n  evt = evt || window.event;\n  var selected = evt.target || evt.srcElement;\n  var eleName =\n      selected && selected.tagName\n  ? selected.tagName.toLowerCase()\n  : \"no tagName\";\n  alert(eleName);\n}\n\nwindow.onload = function() {\n  var el = document.getElementsByTagName(\"body\");\n  el[0].onclick = elementName;\n};\n```",
          "answer": "",
          "biz_type": 1,
          "qid": 697,
          "subject": "",
          "title": "请实现鼠标点击页面中的任意标签，alert 该标签的名称(注意兼容性)"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["爱范儿"],
        "date": "Fri, 19 Jun 2020 16:20:44 GMT",
        "favorite_num": 8,
        "qid": 699,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "#### Object.create()\n\n- Object.create()方法使用指定的原型对象和其属性创建了一个新的对象。\n- Object.create(proto,[propertiesObject])\n- Object.create方法创建一个空对象，然后将空对象的__proto__ = proto，如果还有propertiesObject参数的话，就进行object.assign类似的操作，把属性赋上去。\n\n#### 代码实现\n\n**1）简单粗暴**\n\n```js\n// create 创建一个对象，使其 __proto__ 指向传入的原型\nfuction creat(obj){\n  // 创建一个空的构造函数\n  function F(){}\n  // 将构造函数的 prototype 指向传入的对象\n  F.prototype = obj\n  // 返回新构造函数的实例\n  retrun new F()\n}\n```\n\n**2）实现propertiesObject参数**\n\n```js\nObject.create = function (prototype, properties) {\n    if (typeof prototype !== \"object\") { \n        throw TypeError(); }\n    function Ctor() {}\n    Ctor.prototype = prototype;\n    var o = new Ctor();\n    if (prototype) { \n        o.constructor = Ctor; \n    }\n    if (properties !== undefined) {\n      if (properties !== Object(properties)) { \n          throw TypeError(); \n       }\n      Object.defineProperties(o, properties);\n    }\n    return o;\n};\n```",
          "answer": "",
          "biz_type": 1,
          "qid": 699,
          "subject": "",
          "title": "原生实现 ES5 的 Object.create()方法"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["爱范儿"],
        "date": "Fri, 19 Jun 2020 16:20:44 GMT",
        "favorite_num": 30,
        "qid": 703,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "#### 1.原生方式实现\n\n- **html**\n\n```html\n<body>\n    <button id=\"expire1\">过期设置(暴力法)</button>\n    <button id=\"expire2\">过期设置(innerHTMl)</button>\n    <ul id=\"wrap\"></ul>\n</body>\n```\n\n- **JavaScript**\n\n```js\n//生成大量dom \nlet start = new Date().getTime()\nlet $ul = document.getElementById(\"wrap\");\n\nlet el = document.createDocumentFragment()\nlet allKeys = []\nfor(var i = 0; i < 1000; i++){\n    let li = document.createElement('li');\n    li.dataset.key = i  //key\n    li.innerHTML = i\n    el.appendChild(li)\n    allKeys.push(i)\n}\n$ul.appendChild(el)\n\n\n// 生成过期项 模拟服务端生成的数据\nfunction getExpireKeys(){\n    let keys = []\n    while(keys.length < 100){\n    let randomKey = Math.floor(Math.random() * 1000)\n    if(keys.indexOf(randomKey) === -1){\n        keys.push(randomKey)\n    }else{\n        continue\n    }\n    }\n    return keys\n}\n\n// 暴力项 逐项遍历\ndocument.getElementById('expire1').onclick = function(){\n    let expireKeys = getExpireKeys()\n    let children = $ul.children;\n    let start = Date.now()\n    for (let i = 0; i < expireKeys.length; i++) {\n    const element = document.querySelector(`[data-key=\"${expireKeys[i]}\"]`);\n    element.innerHTML = element.innerHTML + '已过期'\n    }\n}\n\n//模板字符串 innerHtml替换\ndocument.getElementById('expire2').onclick = function(){\n    let expireKeys = getExpireKeys()\n    const item = []\n    for (let i = 0; i < allKeys.length; i++) {\n    item.push( `<li>${allKeys[i]} ${expireKeys.indexOf(allKeys[i]) !== -1 ? '已过期' : ''}</li>`)\n    }\n    $ul.innerHTML = item.join('')\n}\n```\n\n#### 2.Vue方式处理\n\n```js\n// template\n<button @click=setExpire>过期</button>\n<ul>\n  <li v-for=\"item in allKeys\" :key=\"item.value\">\n    {{item.value}}\n    {{item.expire ? '已过期' : ''}}\n  </li>\n</ul>\n\n// script\n<script>\nexport default {\n  data() {\n    return {\n      allKeys: [],  //所有项\n      expireKeys: []  //过期项\n    }\n  },\n  created(){\n    for(var i = 0; i < 1000; i++){\n      this.allKeys.push({\n        value: i,\n        expire: false\n      })\n    }\n  },\n  methods: {\n    setExpire(){\n      let keys = this.getExpireKeys()\n      for (let i = 0; i < this.allKeys.length; i++) {\n        if(keys.indexOf(this.allKeys[i].value) !== -1){\n          this.allKeys[i].expire = true\n        }\n      }\n    },\n    // 生成过期项 模拟服务端生成的数据\n    getExpireKeys(){\n      let keys = []\n      while(keys.length < 100){\n        let randomKey = Math.floor(Math.random() * 1000)\n        if(keys.indexOf(randomKey) === -1){\n          keys.push(randomKey)\n        }else{\n          continue\n        }\n      }\n      return keys\n    }\n  },\n}\n</script>\n```\n",
          "answer": "",
          "biz_type": 1,
          "qid": 703,
          "subject": "```js\n/* \n  a)在不使用vue、react的前提下写代码解决一下问题\n    一个List页面上，含有1000个条目的待办列表，现其中100项在同一时间达到了过期时间，需要在对应项的text-node里添加“已过期”文字。需要尽可能减少dom重绘次数以提升性能。\n  b)尝试使用vue或react解决上述问题\n*/\n```\n",
          "title": "按要求完成题目"
        },
        "tech_tag": ["JavaScript", "Vue", "React", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["爱范儿"],
        "date": "Fri, 19 Jun 2020 16:20:44 GMT",
        "favorite_num": 4,
        "qid": 704,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "### 组织JavaScript代码\n\n精心设计的代码更易于维护，优化和扩展，能使开发者更高效。这意味着更多的注意力和精力可以花在构建伟大的事情上，每个人都很愉快——用户，开发者和利益相关者。\n\n比较宽松的语言，特别是 JavaScript ，需要一些规矩才能写好\n\nJavaScript 环境非常宽松，随处扔些代码片段，就可能起作用。早点确立系统架构（然后遵守它！）对你的代码库提供制约，确保自始至终的一致性。\n\n有3个高级的，跟语言无关的点，对代码设计十分重要。\n\n####   1.系统架构\n\n代码库的基础设计。控制各种组件的规则，例如模块（models），视图（views）和控制器（controllers），以及之间的相互作用。\n\n#### 2.可维护性\n\n如何更好地改进和扩展代码？\n\n#### 3.复用性\n\n应用组件如何复用？每个组件的实例如何简便地个性定制？\n\n### 二、模块模式\n\n**模块模式** 是一个简单的结构基础，它可以让你的代码保持干净和条例清晰。一个“模块”就是个标准的包含方法和属性的对象字面量，简单是这个模式的最大亮点：甚至一些不熟悉传统的软件设计模式的人，一看就能立刻明白代码是如何工作的。\n\n用此模式的应用，每个组件有它独立的模块。例如，创建自动完成功能，你要写个模块用于文本区域，一个模块用于结果列表。两个模块相互工作，但是文本区域代码不会触及结果列表代码，反之亦然。\n\n**模块解耦** 是模块模式非常适于构建可靠的系统架构的原因。应用间的关系是明确定义的；任何关系到文本区域的事情被文本区域模块管理，并不是散落在代码库中——代码整洁。\n\n模块化组织的另一个好处是固有的可维护性。模块可以独立地改进和优化，不会影响应用的任何其它部分。\n\n看下下边的例子\n\n#### 1.基础 - 函数版：\n\n```js\nfunction a(){};\nfunction b(){};\n```\n\n#### 2.入门 - 字面量版：\n\n```js\nvar obj = {\n    init : function(){\n        this.a();\n        this.b();\n    },\n    a : function(){},\n    b : function(){}\n}\n// 在页面中调用obj.init();\n```\n\n#### 3.进阶 - 命名空间版：\n\n```js\nvar hogo = {\n    ns : function(){};\n}\n\nhogo.ns('hogo.wx', {\n    init : function(){\n        this.a();\n        this.b();\n    },\n    a : function(){},\n    b : function(){}\n});\nhogo.wx.init();\n```\n\n#### 4.提高 - 模块化版：\n\n```js\ndefine();\nrequire();\n```",
          "answer": "",
          "biz_type": 1,
          "qid": 704,
          "subject": "",
          "title": "你是如何组织 JavaScript 代码的？（可以从模块、组件、模式、编程思想等方面回答）"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["新东方"],
        "date": "Fri, 19 Jun 2020 16:20:44 GMT",
        "favorite_num": 9,
        "qid": 750,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "### 代码实现\n\n#### 1.实现方式一\n\n- 装饰器写法\n\n```js\nconst myDecorator = (fn, execute, obj=window) => {\n        let old = obj[fn]\n         obj[fn] = function() {\n            return execute(old.bind(obj))\n        }\n  }\n \n  function A() {\n         console.log('调用函数A')\n  }\n         \n  myDecorator('A', (fn) => {\n         fn()\n         console.log('hello world')\n  })\n  A();\n```\n\n#### 2.实现方式二\n\n- 添加原型方法\n\n```js\nFunction.prototype.before = function (beforeFN) {\n    var _self = this;\n    return function () {\n        beforeFN.apply(_self, arguments)\n        return _self.apply(this, arguments)\n    }\n}\n\nFunction.prototype.after = function (afterFN) {\n    var _self = this;\n    return function () {\n        var fn = _self.apply(this, arguments);\n        afterFN.apply(_self, arguments)\n        return fn\n    }\n}\n\nvar A = function () {\n    console.warn(\"调用了函数A\")\n}\n\nA = A.before(function () {\n    console.warn(\"前置钩子 HelloWorld\")\n}).after(function () {\n    console.warn(\"后置钩子 HelloWorld\")\n})\n\nA()\n```\n\n#### 3.实现方式三\n\n- 粗暴直接\n\n```js\nfunction A() {\n    console.log('调用了函数A');\n}\nconst nativeA = A;\nA = function () {\n    console.log('HelloWorld');\n    nativeA();\n}\nA()\n```\n\n",
          "answer": "",
          "biz_type": 1,
          "qid": 750,
          "subject": "```js\nfunction A() {\n  console.log(\"调用了函数A\");\n}\n```\n",
          "title": "有这样一个函数 A,要求在不改变原有函数 A 功能以及调用方式的情况下，使得每次调用该函数都能在控制台打印出“HelloWorld”"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["CVTE"],
        "date": "Fri, 19 Jun 2020 16:20:44 GMT",
        "favorite_num": 4,
        "qid": 691,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "### 什么是尾递归\n\n尾调用是函数式编程中一个很重要的概念，当一个函数执行时的最后一个步骤是返回另一个函数的调用，这就叫做尾调用。当一个函数尾调用自身，就叫做尾递归。\n\n**尾调用优化**：函数在调用的时候会在调用栈（call stack）中存有记录，每一条记录叫做一个调用帧（call frame），每调用一个函数，就向栈中push一条记录，函数执行结束后依次向外弹出，直到清空调用栈。\n\n> 尾调用优化只在严格模式下有效。\n\n### 尾递归应用\n\n尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。\n\n#### 1.阶乘函数\n\n```js\n'use strict';\nfunction factorial(n, total = 1) {\n  if (n === 1) return total;\n  return factorial(n - 1, n * total);\n}\n\nfactorial(5, 1);                // 120\nfactorial(10, 1);               // 3628800\nfactorial(500000, 1);           // 分情况\n```\n\n> 注意，虽然说这里启用了严格模式，但是经测试，在Chrome和Firefox下，还是会报栈溢出错误，并没有进行尾调用优化\n> \n> Safari浏览器进行了尾调用优化，factorial(500000, 1)结果为Infinity，因为结果超出了JS可表示的数字范围\n> \n> 如果在node v6版本下执行，需要加--harmony_tailcalls参数，node --harmony_tailcalls test.js\n> \n> node最新版本已经移除了--harmony_tailcalls功能\n\n#### 2.斐波那契数列\n\n```js\n/**\n *  @params {n : 序列号, pre: 上次序列和, current:本次序列和}\n */\nconst Fibonacci = (n, pre = 1, current = 1) => {\n    if (n <= 1) return current;\n    return Fibonacci(n - 1, pre, pre + current);\n}\n```\n\n\n\n",
          "answer": "",
          "biz_type": 1,
          "qid": 691,
          "subject": "",
          "title": "尾递归实现"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["玄武科技"],
        "date": "Fri, 19 Jun 2020 16:20:44 GMT",
        "favorite_num": 8,
        "qid": 719,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "### 一、概念理解\n\n#### 1.什么是事件代理\n\n事件委托或事件代理：根据《js高级程序设计》一书（前端红宝书）来说就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有时间。举一个栗子：dom需要事件处理程序，我们都会直接给它设置事件处理程序。but，如果有在ul中全部100个li需要添加事件处理程序，其具有相同的点击事件，那么可以根据for来进行遍历，也可以根据上层的ul来进行添加。在性能的角度来看，把ul建立事件会减少dom的交互次数，提高性能。\n\n#### 2.事件代理原理\n\n事件委托是利用事件的冒泡原理来实现的，就是事件从最深的节点开始，然后逐步向上传播事件。\n\n举个例子：页面上有这么一个节点树，div>ul>li>a;比如给最里面的a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a>li>ul>div，有这样一个机制，那么我们给最外面的div加点击事件，那么里面的ul，li，a做点击事件的时候，都会冒泡到最外层的div上，所以都会触发，这就是事件委托，委托它们父级代为执行事件。\n\n\n### 二、代码实现\n\n#### 1.比如实现ul中li的事件代理\n\n```js\nwindow.onload = function () {\n    var oBtn = document.getElementById(\"btn\");\n    var oUl = document.getElementById(\"ul1\");\n    var aLi = oUl.getElementsByTagName('li');\n    var num = 4;\n    //事件委托，添加的子元素也有事件 \n    oUl.onmouseover = function (ev) {\n      var ev = ev || window.event;\n      var target = ev.target || ev.srcElement;\n      if (target.nodeName.toLowerCase() == 'li') {\n        target.style.background = \"red\";\n      }\n    };\n    oUl.onmouseout = function (ev) {\n      var ev = ev || window.event;\n      var target = ev.target || ev.srcElement;\n      if (target.nodeName.toLowerCase() == 'li') {\n        target.style.background = \"#fff\";\n      }\n    };\n    //添加新节点 \n    oBtn.onclick = function () {\n      num++;\n      var oLi = document.createElement('li');\n      oLi.innerHTML = 111 * num;\n      oUl.appendChild(oLi);\n    };\n}\n}\n```\n\n\n#### 2.简单封装一个事件代理通用代码\n\n```js\n!function (root, doc) {\n  class Delegator {\n    constructor (selector) {\n      this.root = document.querySelector(selector);//父级dom\n      this.delegatorEvents = {};//代理元素及事件\n      //代理逻辑\n      this.delegator = e => {        \n        let currentNode = e.target;//目标节点\n        const targetEventList = this.delegatorEvents[e.type];\n        //如果当前目标节点等于事件当前所在的节点，不再向上冒泡\n        while (currentNode !== e.currentTarget) {\n          targetEventList.forEach(target => {\n            if (currentNode.matches(target.matcher)) {\n              //开始委托并把当前目标节点的event对象传过去\n              target.callback.call(currentNode, e);\n            }\n          })\n          currentNode = currentNode.parentNode;\n        }\n      }\n    }\n    /*\n     *绑定事件\n     *@param event 绑定事件类型\n     *@param selector 需要被代理的选择器\n     *@param fn 触发函数\n     * */\n    on (event, selector, fn) {\n     //相同事件只添加一次，如果存在，则再对应的代理事件里添加\n      if (!this.delegatorEvents[event]) {\n        this.delegatorEvents[event] = [{\n          matcher: selector,\n          callback: fn\n        }]\n        this.root.addEventListener(event, this.delegator);\n      }else{\n        this.delegatorEvents[event].push({\n          matcher: selector,\n          callback: fn\n        })\n      }\n      return this;\n    }\n    /*\n     *移除事件\n     */\n    destroy () {\n      Object.keys(this.delegatorEvents).forEach(eventName => {\n        this.root.removeEventListener(eventName, this.delegator)\n      });\n    }\n  }\n\n  root.Delegator = Delegator\n}(window, document)\n```",
          "answer": "",
          "biz_type": 1,
          "qid": 719,
          "subject": "",
          "title": "请用 JavaScript 代码实现事件代理"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["爱范儿"],
        "date": "Fri, 19 Jun 2020 16:20:44 GMT",
        "favorite_num": 4,
        "qid": 694,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "### 一、分析\n\n因为每个请求处理时长不一致，可能会导致先发送的请求后响应，即请求响应顺序和请求发送顺序不一致，从而导致数据显示不正确。\n\n即可以理解为连续触发多个请求，如何保证请求响应顺序和请求发送顺序一致。对于问题所在场景，用户只关心最后数据是否显示正确，即可以简化为：连续触发多个请求，如何保证最后响应的结果是最后发送的请求（不关注之前的请求是否发送或者响应成功）\n\n类似场景：input输入框即时搜索，表格快速切换页码\n\n### 二、解决方案\n\n防抖（过滤掉一些非必要的请求） + 取消上次未完成的请求（保证最后一次请求的响应顺序）\n\n取消请求方法：\n\n- `XMLHttpRequest` 使用 `abort` `api` 取消请求\n- `axios` 使用 `cancel token` 取消请求\n\n伪代码（以 setTimeout 模拟请求，clearTimeout 取消请求）\n\n```js\n/**\n * 函数防抖，一定时间内连续触发事件只执行一次\n * @param {*} func 需要防抖的函数\n * @param {*} delay 防抖延迟\n * @param {*} immediate 是否立即执行，为true表示连续触发时立即执行，即执行第一次，为false表示连续触发后delay ms后执行一次\n */\nlet debounce = function(func, delay = 100, immediate = false) {\n  let timeoutId, last, context, args, result\n\n  function later() {\n    const interval = Date.now() - last\n    if (interval < delay && interval >= 0) {\n      timeoutId = setTimeout(later, delay - interval)\n    } else {\n      timeoutId = null\n      if (!immediate) {\n        result = func.apply(context, args)\n        context = args = null\n      }\n    }\n  }\n\n  return function() {\n    context = this\n    args = arguments\n    last = Date.now()\n\n    if (immediate && !timeoutId) {\n      result = func.apply(context, args)\n      context = args = null // 解除引用\n    }\n    \n    if (!timeoutId) {\n      timeoutId = setTimeout(later, delay)\n    }\n\n    return result\n  }\n}\n\n\nlet flag = false             // 标志位，表示当前是否正在请求数据\nlet xhr = null\n\nlet request = (i) => {\n    if (flag) {\n        clearTimeout(xhr)\n        console.log(`取消第${i - 1}次请求`)\n    }\n    flag = true\n    console.log(`开始第${i}次请求`)\n    xhr = setTimeout(() => {\n        console.log(`请求${i}响应成功`)\n        flag = false\n    }, Math.random() * 200)\n}\n\nlet fetchData = debounce(request, 50)  // 防抖\n\n// 模拟连续触发的请求\nlet count = 1 \nlet getData = () => {\n  setTimeout(() => {\n    fetchData(count)\n    count++\n    if (count < 11) {\n        getData()\n    }\n  }, Math.random() * 200)\n}\ngetData()\n\n/* 某次测试输出：\n    开始第2次请求\n    请求2响应成功\n    开始第3次请求\n    取消第3次请求\n    开始第4次请求\n    请求4响应成功\n    开始第5次请求\n    请求5响应成功\n    开始第8次请求\n    取消第8次请求\n    开始第9次请求\n    请求9响应成功\n    开始第10次请求\n    请求10响应成功\n*/\n```\n",
          "answer": "",
          "biz_type": 1,
          "qid": 694,
          "subject": "",
          "title": "多个 tab 只对应一个内容框，点击每个 tab 都会请求接口并渲染到内容框，怎么确保频繁点击 tab 但能够确保数据正常显示？"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["爱范儿"],
        "date": "Fri, 19 Jun 2020 16:20:44 GMT",
        "favorite_num": 6,
        "qid": 693,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "### 一、优化简要版\n\n**1）懒加载:获取首屏数据,后边的数据进行滑动加载请求**\n\n1. 首先，不要将图片地址放到src属性中，而是放到其它属性(data-original)中。\n2. 页面加载完成后，根据scrollTop判断图片是否在用户的视野内，如果在，则将data-original属性中的值取出存放到src属性中。\n3. 在滚动事件中重复判断图片是否进入视野，如果进入，则将data-original属性中的值取出存放到src属性中\n\n**2）利用骨架屏提升用户体验**\n\n**3）PreloadJS预加载**\n\n使用PreloadJS库，PreloadJS提供了一种预加载内容的一致方式，以便在HTML应用程序中使用。预加载可以使用HTML标签以及XHR来完成。默认情况下，PreloadJS会尝试使用XHR加载内容，因为它提供了对进度和完成事件的更好支持，但是由于跨域问题，使用基于标记的加载可能更好。\n\n**4）除了添加前端loading和超时404页面外，接口部分可以添加接口缓存和接口的预加载**\n\n1. 使用workbox对数据进行缓存 缓存优先\n2. 使用orm对本地离线数据进行缓存 优先请求本地。\n3. 采用预加载 再进入到详情页阶段使用quicklink预加载详情页\n4. 使用nodejs作为中间层将详情页数据缓存至redis等\n上面的方法，可以根据业务需求选择组合使用。\n\n\n\n\n\n### 二、优化详细版\n\n#### 1.打开谷歌搜索为例\n\n![load和DOMContentLoad.png](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-693-devetool.png)\n\n\n- 蓝色的分界线左边代表浏览器的 DOMContentLoaded，当初始 HTML 文档已完全加载和解析而无需等待样式表，图像和子帧完成加载时的标识;\n- 红色分界线代表 load, 当整个页面及所有依赖资源如样式表和图片都已完成加载时\n\n所以我们可以大致分为在 \n\n- **TTFB 之前的优化**\n- **浏览器上面渲染的优化**\n\n#### 2.当网络过慢时在获取数据前的处理\n\n首先先上一张经典到不能再经典的图\n\n![timing-overview.png](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-693-performance.png)\n\n> 其中cnd在dns阶段, dom渲染在processing onload阶段\n\n上图从 promot for unload 到 onload 的过程这么多步骤, 在用户体验来说, 一个页面从加载到展示超过 4 秒, 就会有一种非常直观的卡顿现象, 其中 load 对应的位置是 onLoad 事件结束后, 才开始构建 dom 树, 但是用户不一定是关心当前页面是否是完成了资源的下载;\n往往是一个页面开始出现可见元素开始**FCP 首次内容绘制**或者是**FC 首次绘制** 此时用户视觉体验开始, 到**TTI(可交互时间)** , 可交互元素的出现, 意味着,用户交互体验开始, 这时候用户就可以愉快的浏览使用我们的页面啦;\n\n所以这个问题的主要痛点是需要缩短到达 **TTI** 和 **FCP** 的时间\n\n但是这里已知进入我们详情页面时, 接口数据返回速度是很慢的, **FCP** 和 **FC** , 以及加快到达 **TTI** , 就需要我们页面预处理了\n\n#### 3.页面数据缓存处理(缓存大法好)\n\n**第一次** 进入详情页面, 可以使用骨架图进行模拟 **FC** 展示, 并且骨架图, 可使用背景图且行内样式的方式对首次进入详情页面进行展示, 对于请求过慢的详情接口使用 **worker** 进程, 对详情的接口请求丢到另外一个工作线程进行请求, 页面渲染其他已返回数据的元素; 当很慢的数据回来后, 需要对页面根据商品 id 签名为 key 进行 webp 或者是缩略图商品图的 cnd 路径 localStorage 的缓存, 商品 id 的签名由放在 cookie 并设置成 httpOnly\n\n**非第一次** 进入详情页时, 前端可通过特定的接口请求回来对应的商品 id 签名的 cookieid, 读取 localStorage 的商品图片的缓存数据, 这样对于第一次骨架图的展示时间就可以缩短, 快速到达 **TTI** 与用户交互的时间, 再通过 worker 数据, 进行高清图片的切换\n\n#### 4.过期缓存数据的处理(后端控制为主, LRU 为辅)\n\n对于缓存图片地址的处理, 虽说缓存图片是放在 localStorage 中, 不会用大小限制, 但是太多也是不好的, 这里使用 LRU 算法对图片以及其他 localStorage 进行清除处理, 对于超过 7 天的数据进行清理\nlocalStorage 详情页的数据, 数据结构如下:\n\n```js\n\"读取后端的cookieID\": {\n  \"path\": \"对应cdn图片的地址\",\n  \"time\": \"缓存时间戳\",\n  \"size\": \"大小\"\n}\n```\n\n#### 5.数据缓存和过期缓存数据的处理主体流程\n\n![进入商品详情页,接口数据很慢时,对页面的优化](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-693-handle.png)\n\n#### 6.对于大请求量的请求(如详情页面中的猜你喜欢, 推荐商品等一些大数据量的静态资源)\n\n1. 由于这些不属于用户进入详情想第一时间获取的信息, 即不属于当前页面的目标主体, 所以这些可以使用 **Intersection Observer API** 进行主体元素的观察, 当当前主体元素被加载出来后, 在进行非主体元素的网络资源分配, 即网络空闲时再请求猜你喜欢, 推荐商品等资源, 处理请求优先级的问题\n2. 需要保证当前详情页的请求列表的请求数 不超过当前浏览器的请求一个 tcp 最大 http 请求数\n\n#### 7.当 worker 数据回来后, 出现 **大量图片** 替换对应元素的的 webp 或者缩略图出现的问题(静态资源过多)\n\n这里有两种情景\n\n1. 移动端, 对于移动端, 一般不会出现大量图片, 一般一个商品详情页, 不会超过 100 张图片资源; 这时候, 选择懒加载方案; 根据 GitHub 现有的很多方案, 当前滑动到可被观察的元素后才加载当前可视区域的图片资源, 同样使用的是 **Intersection Observer API** ; 比如 vue 的一个库 **vue-lazy** , 这个库就是对 Intersection_Observer_API 进行封装, 对可视区域的 img 便签进行 data-src 和 src 属性替换\n\n2. 第二个情况, pc 端, 可能会出现大量的 img 标签, 可能多达 300~400 张, 这时候, 使用懒加载, 用户体验就不太好了; 比如说: 当用户在查看商品说明介绍时, 这些商品说明和介绍有可能只是一张张图片, 当用户很快速的滑动时, 页面还没懒加载完, 用户就有可能看不到想看的信息; 鉴于会出现这种情况, 这里给出一个方案就是, img 出现一张 load 一张; 实现如下：\n\n```js\n// 这里针对非第一次进入详情页,\n//当前localStorage已经有了当前详情页商品图片的缩略图\nfor(let i = 0; i < worker.img.length; i++) {\n  // nodeList是对应img标签,\n  // 注意, 这里对应的nodeList一定要使用内联style把位置大小设置好, 避免大量的重绘重排\n  const img = nodeList[i]\n  img.src = worker.img['path'];\n  img.onerror = () => {\n    // 将替换失败或者加载失败的图片降级到缩略图, \n    // 即缓存到localStorage的缩略图或者webp图\n    // 兼容客户端处理webp失败的情况\n  }\n}\n```\n\n#### 8.页面重绘重排处理\n\n![页面渲染流程](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-693-paint.png)\n\n触发重排的操作主要是几何因素：\n\n1. 页面首次进入的渲染。\n2. 浏览器 resize\n3. 元素位置和尺寸发生改变的时候\n4. 可见元素的增删\n5. 内容发生改变\n6. 字体的 font 的改变。\n7. css 伪类激活。\n   .....\n  </br>\n  \n尽量减少上面这些产生重绘重排的操作\n\n比如说：\n\n这里产生很大的重绘重排主要发生在 worker 回来的数据替换页面中的图片 src 这一步\n\n```js\n// 该节点为img标签的父节点\nconst imgParent = docucment.getElementById('imgParent'); \n// 克隆当前需要替换img标签的父元素下所有的标签\nconst newImgParent = imgParent.cloneNode(true); \nconst imgParentParent = docucment.getElementById('imgParentParent');\nfor(let i = 0; i < newImgParent.children.length; i++) { \n// 批量获取完所有img标签后, 再进行重绘\n  newImgParent.children[i].src = worker.img[i].path;\n}\n// 通过img父节点的父节点, 来替换整个img父节点\n// 包括对应的所有子节点, 只进行一次重绘操作\nimgParentParent.replaceChild(newImgParent, imgParent); \n```\n\n#### 9.css代码处理\n\n**注意被阻塞的css资源**\n\n众所周知, css的加载会阻塞浏览器其他资源的加载, 直至CSSOM **CSS OBJECT MODEL** 构建完成, 然后再挂在DOM树上, 浏览器依次使用渲染树来布局和绘制网页。 \n\n很多人都下意识的知道, 将css文件一律放到head标签中是比较好的, 但是为什么将css放在head标签是最后了呢?\n\n我们用淘宝做例子\n\n![没有加载css的淘宝页面](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-693-taobao.png)\n比如这种没有css样式的页面称之为FOUC(内容样式短暂失效), 但是这种情况一般出现在ie系列以及前期的浏览器身上; 就是当cssom在domtree生成后, 依然还没完成加载出来, 先展示纯html代码的页面一会再出现正确的带css样式的页面;\n\n**减少不同页面的css代码加载**\n\n对于电商页面, 有些在头部的css代码有些是首页展示的有些是特定情况才展示的, 比如当我们需要减少一些css文件大小但是当前网站又需要多屏展示, 这时候, 很多人都会想到是媒体查询, 没错方向是对的, 但是怎样的媒体查询才对css文件保持足够的小呢, 可以使用link标签媒体查询,看下边的的例子：\n\n```html\n<link href=\"base.css\" rel=\"stylesheet\">\n<link href=\"other.css\" rel=\"stylesheet\" media=\"(min-width: 750px)\">\n```\n\n第一个css资源表示所有页面都会加载, 第二个css资源, 宽度在750px才会加载, 默认media=\"all\"\n\n在一些需求写css媒体查询的网站, 不要在css代码里面写, 最好写两套css代码, 通过link媒体查询去动态加载, 这样就能很好的减轻网站加载css文件的压力\n\n#### 10.静态js代码处理\n\n这种js代码, 是那些关于埋点, 本地日记, 以及动态修改css代码, 读取页面成型后的信息的一些js代码, 这种一律放在同域下的localStorage上面, 什么是同域下的localStorage\n\n这里还是以天猫为例\n\n![](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-693-tianmao.png)\n\n\n#### 11.容错处理\n\n1. 页面在获取到 worker 回来的数据后, 通过拷贝整个html片段, 再将worker的img路径在替换对应的 img 资源后再进行追加到对应的dom节点\n2. 缓存 css 文件和 js 文件到 localStorage 中, 若当前没有对应的 css 文件或者 js 文件, 或者被恶意修改过的 css 文件或者 js 文件(可使用签名进行判断), 删除再获取对应文件的更新\n\n#### 12.推荐方案理由\n\n1. 使用了 worker 线程请求详情数据, 不占用浏览器主线程; 进而减少主进程消耗在网络的时间\n2. 使用 localStorage 的缓存机制, 因为当 worker 回来的数据后, 读取 localStorage 是同步读取的, 基本不会有太大的等待时间, 并且读取 localStorage 时, 使用的是后端返回来的 cookieID 进行读取, 且本地的 cookID 是 httpOnly 避免了第三方获取到 cookieID 进行读取商品信息\n3. 使用 LRU 清除过多的缓存数据\n4. 首次进入页面时, 保证已知页面布局情况下的快速渲染以及配置骨架图, 加快到达 FCP 和 FP 的时间\n5. 就算 img 静态资源过大, 在第二次进入该页面的时候, 也可以做到低次数重绘重排, 加快到底 TTI 的时间\n\n#### 13.方案不足\n\n1. 在网络依然很慢的情况下, 首次进入详情页面, 如果长时间的骨架图和已知布局下, 用户的体验依然是不好的, 这里可以考虑 PWA 方案, 对最近一次成功请求的内容进行劫持, 并在无网情况下, 做出相应的提示和展示处理\n2. 需要 UI 那边提供三套静态 img 资源\n",
          "answer": "",
          "biz_type": 1,
          "qid": 693,
          "subject": "",
          "title": "商城的列表页跳转到商品的详情页，详情页数据接口很慢，前端可以怎么优化用户体验？"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["爱范儿"],
        "date": "Fri, 19 Jun 2020 16:20:44 GMT",
        "favorite_num": 4,
        "qid": 701,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "### 一、代码执行的错误捕获\n\n**1.try……catch**\n\n使用try... catch 包裹，影响代码可读性。无法处理异步中的错误无法处理语法错误\n\n**2.window.onerrorwindow.onerror**\n\n比`try catch`要强那么一丢丢。无论是异步还是非异步错误，onerror 都能捕获到运行时错误\n\n**缺点:** 监听不到资源加载的报错onerror,事件处理函数只能声明一次，不会重复执行多个回调：\n\n**3.window.addEventListener('error')**\n\n可以监听到资源加载报错，也可以注册多个事件处理函数。\n\n**4.window.addEventListener('unhandledrejection')**\n\n捕获Promise错误\n\n### 二、资源加载的错误捕获\n\n1. `imgObj.onerror()`\n2. `performance.getEntries()`，获取到成功加载的资源，对比可以间接的捕获错误\n3. `window.addEventListener('error', fn, true)`, 会捕获但是不冒泡，所以window.onerror 不会触发，捕获阶段可以触发\n\n### 三、错误上报\n\n一般使用image来上报，大厂都是采用利用image对象的方式上报错误的；\n\n使用图片发送get请求，上报信息，由于浏览器对图片有缓存，同样的请求，图片只会发送一次，避免重复上报。\n\n### 四、借助第三方库\n\n- sentry-javascript\n\n\n",
          "answer": "",
          "biz_type": 1,
          "qid": 701,
          "subject": "",
          "title": "如何记录前端再用户浏览器上发生的错误并汇报给服务器？"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["CVTE"],
        "date": "Fri, 19 Jun 2020 16:20:44 GMT",
        "favorite_num": 6,
        "qid": 689,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "### 一、什么是单点登录\n\n单点登录SSO(Single Sign On),是一个多系统共存的环境下，用户在一处登录后，就不用在其他系统中登录，也就是用户的一次登录得到其他所有系统的信任\n\n比如现有业务系统A、B、C以及SSO系统，第一次访问A系统时，发现没有登录，引导用户到SSO系统登录，根据用户的登录信息，生成唯一的一个凭据token，返回给用户。后期用户访问B、C系统的时候，携带上对应的凭证到SSO系统去校验，校验通过后，就可以单点登录；\n\n单点登录在大型网站中使用的非常频繁，例如，阿里旗下有淘宝、天猫、支付宝等网站，其背后的成百上千的子系统，用户操作一次或者交易可能涉及到很多子系统，每个子系统都需要验证，所以提出，用户登录一次就可以访问相互信任的应用系统\n\n单点登录有一个独立的认证中心，只有认证中心才能接受用户的用户名和密码等信息进行认证，其他系统不提供登录入口，只接受认证中心的间接授权。间接授权通过令牌实现，当用户提供的用户名和密码通过认证中心认证后，认证中心会创建授权令牌，在接下来的跳转过程中，授权令牌作为参数发送给各个子系统，子系统拿到令牌即得到了授权，然后创建局部会话。\n\n### 二、单点登录原理\n\n单点登录有同域和跨域两种场景\n\n#### 1）同域\n\n适用场景：都是企业自己的系统，所有系统都使用同一个一级域名通过不同的二级域名来区分。\n\n举个例子：公司有一个一级域名为 zlt.com ，我们有三个系统分别是：门户系统(sso.zlt.com)、应用1(app1.zlt.com)和应用2(app2.zlt.com)，需要实现系统之间的单点登录，实现架构如下\n\n核心原理：\n\n1. 门户系统设置的cookie的domain为一级域名也是zlt.com，这样就可以共享门户的cookie给所有的使用该域名xxx.alt.com的系统\n2. 使用Spring Session等技术让所有系统共享Session\n3. 这样只要门户系统登录之后无论跳转应用1或者应用2，都能通过门户Cookie中的sessionId读取到Session中的登录信息实现单点登录\n\n#### 2）跨域\n\n单点登录之间的系统域名不一样，例如第三方系统。由于域名不一样不能共享Cookie了，需要的一个独立的授权系统，即一个独立的认证中心(passport),子系统的登录均可以通过passport，子系统本身将不参与登录操作，当一个系统登录成功后，passprot将会颁发一个令牌给子系统，子系统可以拿着令牌去获取格子的保护资源，为了减少频繁认证，各个子系统在被passport授权以后，会建立一个局部会话，在一定时间内无需再次向passport发起认证\n\n**基本原理**\n\n1. 用户第一次访问应用系统的时候，因为没有登录，会被引导到**认证系统**中进行登录；\n2. 根据用户提供的登录信息，认证系统进行身份校验，如果通过，返回给用户一个认证凭据-**令牌**；\n3. 用户再次访问别的应用的时候，**带上令牌作为认证凭证**；\n4. 应用系统接收到请求后会把令牌送到认证服务器进行**校验**，如果通过，用户就可以在不用登录的情况下访问其他信任的业务服务器。\n\n**登录流程**\n\n![登录流程](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-689-sso.png)\n\n1. 用户访问系统1的受保护资源，系统1发现用户没有登录，跳转到sso认证中心，并将自己的地址作为参数\n2. sso认证中心发现用户未登录，将用户引导到登录页面\n3. 用户提交用户名、密码进行登录\n4. sso认证中心校验用户信息，创建用户与sso认证中心之间的会话，称之为全局会话，同时创建授权令牌\n5. sso 带着令牌跳转回最初的请求的地址(系统1)\n6. 系统1拿着令牌，去sso认证中心校验令牌是否有效\n7. sso认证中心校验令牌，返回有效，注册系统1(也就是返回一个cookie)\n8. 系统一使用该令牌创建与用户的会话，成为局部会话，返回受保护的资源\n9. 用户访问系统2受保护的资源\n10. 系统2发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数\n11. sso认证中心发现用户已登录，跳转回系统2的地址，并且附上令牌\n12. 系统2拿到令牌，去sso中心验证令牌是否有效，返回有效，注册系统2\n13. 系统2使用该令牌创建与用户的局部会话，返回受保护资源\n14. 用户登录成功之后，会与sso认证中心以及各个子系统建立会话，用户与sso认证中心建立的会话称之为全局会话，用户与各个子系统建立的会话称之为局部会话，局部会话建立之后，用户访问子系统受保护资源将不再通过sso认证中心\n\n**注销流程**\n\n![注销流程](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-689-out.png)\n\n1. 用户向系统提交注销操作\n2. 系统根据用户与系统1建立的会话，拿到令牌，向sso认证中心提交注销操作\n3. sso认证中心校验令牌有效，销毁全局会话，同时取出所有用此令牌注册的系统地址\n4. sso认证中心向所有注册系统发起注销请求，各注册系统销毁局部会话\n5. sso认证中心引导用户到登录页面",
          "answer": "",
          "biz_type": 1,
          "qid": 689,
          "subject": "",
          "title": "单点登录实现原理"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["玄武科技"],
        "date": "Fri, 19 Jun 2020 16:20:44 GMT",
        "favorite_num": 4,
        "qid": 710,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "### 一、为什么需要做优化\n\n页面性能的问题对用户体验的影响非常大，加载时间每多 1 秒，你就会流失 7%的用户，在正常页面的情况下，若页面加载时间超过 8 秒时间，那么你可能会损失 85%以上的用户。\n\n为了更好的用户体验更好的业务支持更好的代码质量我们需要对页面进行优化\n\n### 二、实现方案\n\n页面进行优化，其实有两种优化方式\n\n#### 1.软件优化\n\n- **html** 优化 布局优化，减少空格，不用 table 布局，尽量不用 iframe 标签\n- **css 优化** 可以用 css 实现的尽量不用 js 实现；css 代码压缩；css 合并；用字体图标代替图片； 开启 css 硬件加速：transform 动画由 GPU 控制，支持硬件加速，并不需要软件方面的渲染，使用 top 和 left 实现动画时浏览器发生的 repaint\n- **js 优化** 图片优化(预加载/懒加载/延时加载)；视频或音频不加载，当点击之后开始单独加载视频或音频； 在 js 中尽量减少闭包的使用（原因：闭包会产生不释放的栈内存） DOM 的操作 其实 css 压缩与 js 的压缩和混乱比 html 压缩收益要大得多，同时 css 代码和 js 代码比 html 代码多得多，通过 css 压缩和 js 压缩带来流量的减少，会非常明显。\n- **http 优化** 尽量减少需要发送的 http 请求；\n- **缓存方面** 使用浏览器的缓存机制，不需要每次登录或者怎么样都需要再去访问服务器；利用浏览器和服务器端的缓存技术（304 缓存），把一些不经常更新的静态资源文件做缓存处理\n\n#### 2.硬件优化\n\n- 设置负载均衡服务器 通过负载均衡服务器使得后台数据压力平衡；\n- 增加带宽 但是硬件的成本远远高于软件优化。\n\n\n\n\n",
          "answer": "",
          "biz_type": 1,
          "qid": 710,
          "subject": "",
          "title": "请描述下为什么页面需要做优化？并写出常用的页面优化实现方案？"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["玄武科技"],
        "date": "Fri, 19 Jun 2020 16:20:44 GMT",
        "favorite_num": 4,
        "qid": 714,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "### 一、Scope\n\n#### 1.Lexical scope 词法作用域\n\n作用域是什么呢？它指的是你的变量和函数运行到某个地方的代码处能否被访问到。\n\n为什么需要作用域呢？为什么要限制变量的访问性而非全部暴露到公共域下呢？\n\n这是计算机科学中最基本的概念和理念：隔离性（The Principle of Least Access）。为了职责明确，你只能刚好访问到你需要的所有东西，不多也不少。附带地，它带来了模块化、命名空间等好处，让你写出更易阅读、更易维护的代码。可以说，作用域是许多现代编程语言都从语言层面支持的一个特性。\n\n而词法作用域，指的是一个变量，你可以通过变量名引用之，而不发生引用错误。\n\n它本质上是 静态作用域 static scopes 。\n\n#### 2.有什么类型的作用域\n\n**1）全局作用域**\n\n不定义在任何函数以内的变量或函数都位于全局作用域下。当然，这个全局作用域其实也是有边界/上下文的，比如 NodeJS 中不同文件之间的全局变量不能互相访问，因为每个全局对象 global 的上下文仅限于一个文件；比如浏览器中 不同 tab 之间的全局变量也是不能互相访问的，因为每个标签的全局对象 window 的上下文也仅限于一个 tab 中\n\n**2）函数作用域**\n\n任何定义在函数内的变量或函数都处于函数作用域下，这些变量无法在函数以外被引用到\n\n**3）块作用域**\n\nES6之前是没有这个东西的，也就是说，定义在 { } 大括号对 及 for (i = 0; i < 10; i++) { ... } 循环结构中的变量统统都会跑到全局作用域下去。这就很违反直觉了。ES6 通过 let 和 const 关键字修复了这个问题，并且赋予了一般的块 block 以块作用域\n\n------\n\n在函数或块作用域中声明的变量或函数若发生嵌套，则又有了嵌套下的词法作用域规则。相对地，位于一个函数/块内部的变量或函数称位于内层作用域 inner scope；前者相对地称其位于外层的作用域 outer scope。\n\n内外之间的变量访问性规则为：\n\n**3）外层作用域**\n\n全局作用域是最外层的作用域。\n\n外层作用域下的变量及函数可以在内层作用域中被访问获取\n\n**4）内层作用域**\n\n可以访问到外层作用域的变量，可以访问自身的变量，但不能被外层作用域引用\n\n#### 3.作用域什么时候生成\n\n**1）全局作用域**\n\n没声明就使用的代码，默认全跑到全局作用域中。可以使用 use strict 模式禁止\n\n**2）函数作用域**\n\n函数声明开始时 function() { ... }，自动生成一个词法作用域\n\n**3）块作用域**\n\nES6 前，{ } 大括号对 及 for (i = 0; i < 10; i++) { ... } 循环结构 均不生成词法作用域。也就是说，块里面声明的变量全部都会跑到当前的全局作用域里去。这是前 JS 时代的一个坑。ES6 以后 let 和 const 关键字都修复了这个问题，它们会生成一个块作用域，或可称为 condition/loop lexical scope\n\n因此 ES6 时代后，可以这样理解：除了函数作用域和块作用域，其他的全是全局作用域。\n\n作用域对于编程模型的重要意义之一，即是其体现的模块概念。你只需要关注模块内与自己相关的变量和代码，而不需考虑代码库中其他任何代码。这样你可以专注在当前代码片段上，减少编写时大脑的思考负担，也减少了维护阅读时的理解负担。这样的编程模型很符合单一职责原则（SRP），大大提高了工作效率 。\n\n### 二、Closure\n\n#### 1.什么是闭包\n\n一个函数返回一个函数的引用，就形成了一个闭包。\n\n**闭包:** 当函数能记住并访问所在词法作用域，即使函数在词法作用域范围之外，此时就产生了闭包。\n\n从实现上讲，闭包是一条记录，它存储了一个函数与其环境的上下文信息。这个上下文主要记录了：函数的每个自由变量（在内层函数使用，但在外层函数处被定义的变量）与其被绑定的值或引用之间的关联,主要是用来实现信息封装。\n\n#### 2.闭包的作用\n\n闭包最实用的例子就是使局部作用域外能调用局部作用域内的变量。\n\n```js\nvar closure = function () {\n    var innerVar = 'inner'\n    return function () {\n        console.log(innerVar)\n    }\n}\n\nvar getInner = closure()\ngetInner() // 就去到了局部作用域内的变量声明 inner\n```\n\n当然这只是闭包的一种场景，并不是说一个函数返回一个函数才是闭包，换而言之，简单地使词法作用域的外层可以访问其中的变量，这便创建了一个闭包。\n\n### 三、Prototype\n\n原型:每一个函数内部都具有一个prototype属性。构造函数创造的实例对象实例内部有一个内部属性[[prototype]],作为一个指针，指向构造函数原型所指的对象.所有的实例共享原型对象上的属性和方法 \n\n原型是js中非常重要的概念，换句话说， 原型是js语言的一个特征。js中任何对象都有原型，函数对象有原型（只不过函数不充当构造函数时，原型不起作用），普通的js`object`也有原型，原型是一个`object`，它也有原型，这就构成了一个**原型链**，直到`Object.prototype`。`Object.prototype`的原型是`null`。\n\n读取对象的某个属性时，`JavaScript` 引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。如果直到最顶层的`Object.prototype`还是找不到，则返回`undefined`。如果对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做“覆盖”。\n\n### 四、封装\n\n封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。封装是面向对象的特征之一，是对象和类概念的主要特性。 \n\n通俗的讲就是，将用户不需要知道的数据和方法隐藏起来，外部无法直接访问。在Java中，可以用private， protected关键字进行修饰。在JS中可以用**闭包**实现。\n\n```js\nvar person = {\n  fullName : \"coolb\",\n};\n \nalert(person.fullName); // coolb\nperson.fullName = \"jay\";\nalert(person.fullName); // jay\n```\n\n这里person对象的fullName属性是暴露给用户的，你无法保证用户总是赋合法的名字。为了解决这一问题，我们可以用闭包。\n\n```js\nvar person = function () {\n \n  var fullName = \"coolb\";\n  var reg = new RegExp(/\\d+/);\n \n  return { \n    setFullName : function (newValue) {\n      if(reg.test(newValue)) {\n        console.log(\"Invalid Name\");\n      }\n      else {\n        fullName = newValue;\n      }\n    },\n    getFullName : function () {\n     return fullName; \n    }\n  }\n} \n \nvar p = person();\nconsole.log(p.getFullName());   // coolb\np.setFullName('jay');\nconsole.log(p.getFullName());  // jay\np.setFullName(42); // Invalid Name\np.fullName = 42;     // 这种方式并不影响内部fullName的值\nconsole.log(p.getFullName());  // jay\n```\n\n\n简单的说，一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。\n\n**1）创建一个类**\n\n在ES6之前创建一个类：首先声明一个函数保存在一个对象里，然后按照编程习惯这个代表类的变量名首字母大写，然后再这个函数的内部通过this（函数内部自带的一个变量，用于指向当前这个对象）变量，添加属性或者方法来实现对类属性或方法的添加给类添加属性的时候有两种方法，一种是直接用this指向进行属性的赋值，一种是通过prototype属性进行赋值，使用this进行属性添加的时候所有的实例化对象都会创建并且具有这个属性的实际内容但是使用prototype属性进行属性添加，其实所有的实例化对象本身是不包含该属性的，只是将该属性添加到该对象的原型属性上，但是由于js的原型链的原理，所有的原型对象也可以调用和使用该属性\n\n**2）属性与方法的封装**\n\n- 私有属性：对象的属性不能被访问者看到；只能在函数内部使用。好处就是安全，就类似闭包中的函数一样，减少污染\n- 公有属性（共有属性）：当我们定义一个对象后，使用对象的人在实例化之后可以访问到对象内部的属性；\n- 私有方法：对象的方法不能被访问者看到；只能在函数内部使用。好处就是安全，就类似闭包中的函数一样，减少污染\n- 构造方法： 通过方法修改实例中属性或者私有属性的方法\n- 实现方法： 由于Js中定义的变量都只会存在最近的函数作用域或者最近的全局作用域，所以可以通过函数包裹作用域，实现方法和属性的私有化\n\n### 五、继承\n\n#### 1.继承是什么\n\n顾名思义，一个对象上想拥有被继承对象的方法属性，继承过来就好了\n\n在`OOP`中，通过类的继承来实现代码的复用，通过实例化一个类可以创建许多对象，在JS中继承是通过原型实现的。\n\n```js\nlet user = function(name) {\n    this.name = name;\n    this.getName = function () {\n        console.log(this.name);\n    }\n};\n \n//为了避免下面比较name时，对值进行比较，这里故意传入了String对象\nlet user1 = new user(new String('KK'));\nlet user2 = new user(new String('KK'));\n \nconsole.log(user1.name === user2.name);    //输出false\nconsole.log(user1.getName === user2.getName); //输出false\n```\n\n在上述代码中，我们通过构造函数user，创建了两个对象。实际上是通过复制 构造函数user的原型对象 来创建user1和user2。原型对象中有个constructor指向了user函数，实际上还是通过这个构造函数来创建的对象。\n\n假如不用原型（更准确地说原型对象中没有用户定义的属性），那么这两个对象就无法共享任何属性，对于这个例子来说，getName的逻辑是一样的，不需要两份getName，所有的user对象其实可以共享这个getName方法。这个逻辑非常像java类中的静态函数，只不过静态函数只能够调用静态变量和静态方法。但是在JS的世界里，可以通过将getName定义在原型中，已达到所有对象共享这个函数。\n\n```js\nlet user = function(name) {\n    this.name = name;\n};\n \nuser.prototype.getName = function () {\n    console.log(this.name);\n}\n \nuser.prototype.color = new String('White');\n \nlet user1 = new user(new String('KK'));\nlet user2 = new user(new String('KK'));\n \nconsole.log(user1.name === user2.name);  //输出false\nconsole.log(user1.getName === user2.getName); //输出true\nconsole.log(user1.color === user2.color); //输出true\n```\n\n这里就一目了然了。在原型对象中定义的变量和方法能够被所有多个对象共享。原型的属性被对象共享，但是它不属于对象本身。\n\n```js\nuser1.hasOwnProperty('name');  //true;\nuser1.hasOwnProperty('getName');  //false;\n```\n\n这里要注意：原型对象的属性不是实例对象自身的属性。只要修改原型对象，变动就立刻会体现在**所有**实例对象上。反之，如果对象的属性被修改，原型的对象中相同的属性并不会修改。\n\n#### 2.继承的实现原理\n\n从构造函数实例化说起，当你再调用`new`的时候，js实际上执行的是\n\n```js\nvar o = new Object();\no.__proto__ = Foo.prototype;\nFoo.call(o);\n```\n\n然后，当你执行\n\n```js\no.someProp\n```\n\n它检查 o 是否具有 `someProp` 属性。如果没有，它会查找`Object.getPrototypeOf(o).someProp`，如果仍旧没有，它会继续查找 `Object.getPrototypeOf(Object.getPrototypeOf(o)).someProp`。\n\n**实现一个继承：B继承自A**\n\n```js\nfunction A(a){\n  this.varA = a;\n}\n\n// 以上函数 A 的定义中，既然 A.prototype.varA 总是会被 this.varA 遮蔽，\n// 那么将 varA 加入到原型（prototype）中的目的是什么？\nA.prototype = {\n  varA : null,\n/*\n既然它没有任何作用，干嘛不将 varA 从原型（prototype）去掉 ? \n也许作为一种在隐藏类中优化分配空间的考虑 \n如果varA并不是在每个实例中都被初始化，那这样做将是有效果的。\n*/\n  doSomething : function(){\n    // ...\n  }\n}\n\nfunction B(a, b){\n  A.call(this, a);\n  this.varB = b;\n}\nB.prototype = Object.create(A.prototype, {\n  varB : {\n    value: null, \n    enumerable: true, \n    configurable: true, \n    writable: true \n  },\n  doSomething : { \n    value: function(){ // override\n      A.prototype.doSomething.apply(this, arguments); \n      // call super\n      // ...\n    },\n    enumerable: true,\n    configurable: true, \n    writable: true\n  }\n});\nB.prototype.constructor = B;\n\nvar b = new B();\nb.doSomething();\n```\n\n**最重要的部分**\n\n- 类型被定义在 `.prototype` 中\n- 用 `Object.create()` 来继承\n\n\n`Object.create()`的实现原理或者说是对`ES5`之前版本的polyfill\n\n```js\nif (typeof Object.create !== \"function\") {\n    Object.create = function (proto, propertiesObject) {\n        if (typeof proto !== 'object' && typeof proto !== 'function') {\n            throw new TypeError('Object prototype may only be an Object: ' + proto);\n        } else if (proto === null) {\n            throw new Error(\"This browser's implementation of Object.create is a shim and doesn't support 'null' as the first argument.\");\n        }\n\n        if (typeof propertiesObject != 'undefined') throw new Error(\"This browser's implementation of Object.create is a shim and doesn't support a second argument.\");\n\n        function F() {}\n        F.prototype = proto;\n\n        return new F();\n    };\n}\n```\n\n#### 3.继承的方式\n\n**1）类继承**\n\n```js\nfunction SuperClass(){\n    this.SuperObj = {}\n}\nSuperClass.prototype.SuperMethod = function(){}\n\nfunction SubClass(){\n    \n}\nSubClass.prototype.SubMethod = function(){\n    \n}\nSubClass.prototype = new SuperClass()\n//将子类的prototype属性设置为父类的实例\n\n//实例化方法\nvar Sub = new SubClass()\n```\n\n**2）构造函数继承**\n\ncall方法可以改变函数的执行上下文，因此在子类中调用父类的构造函数，就相当于以子类的this调用了父类的构造函数，但是最后会返回到子类的创建的对象中，实现了子类调用父类构造函数的操作，叫做**构造函数继承**\n\n```js\nfunction SuperClass(){\n    this.SuperObj = {}\n}\nSuperClass.prototype.SuperMethod = function(){}          \n\nfunction SubClass(opt){\n    SuperClass.call(this,opt)\n    //继承父类\n}          \n\n//实例化方法\nvar Sub = new SubClass()\n```\n\n**3）组合继承**\n\n既不会实例属性影响类属性的引用特性，同时在子类构造函数中执行父类的构造函数能都传递参数，看起来两全其美近乎完美\n\n```js\nfunction SuperClass(){\n      this.SuperObj = {}\n  }\n  SuperClass.prototype.SuperMethod = function(){}\n  \n  function SubClass(opt){\n    SuperClass.call(this,opt)\n    //继承父类\n  }\n  \n  SubClass.prototype = new SuperClass()\n  //在构造函数继承中再次把原型属性赋值到子类的原型属性上\n  \n  //实例化方法\n  var Sub = new SubClass()\n```\n\n**4）原型式继承**\n\n```js\nfunction inheritObject(o){\n    function F(){}\n    F.prototype = o\n    return new F()\n}\n\n//测试用例\n\nvar book = {\n    name:'js book',\n    alikeBook:[\"css\",\"htmlbook\"]\n}\nvar newBook = inheritObject(book)\n//实现继承\n\nnewBook.name = 'new book'\n//修改子类属性\n```\n\n**5）寄生组合式继承**\n\n原理：直接将父类的原型复制到子类，但是同时将父类的原型中的构造函数改成子类的构造函数，变为一个子类的对象实现继承，一般和其他的构造函数式继承混合使用\n\n```js\nfunction inheritObject(o){\n    function F(){}\n    F.prototype = o\n    return new F()\n}\nfunction inheritPrototype(subClass,superClass){\n    var p = inheritObject(superClass.prototype)\n    //复制一份原型副本保存在变量中\n    p.constructor = subClass\n    //修正因为重写子类原型导致子类的construtor属性被修改\n    subClass.prototype = p;\n}\n```\n\n### 六、总结\n\n`Javascript`中的这些概念，`scope`、`closure`、`prototype`等对于语言的特征来说是基建，他们息息相关，没有哪个更重要，都是非常重要的概念，只有这些基础的东西搞明白了之后，才能去读懂一些框架的源码，甚至去开发一套框架开发一些牛x的开源库。",
          "answer": "",
          "biz_type": 1,
          "qid": 714,
          "subject": "",
          "title": "请描述下 JavaScript 中 Scope、Closure、Prototype 概念，并说明 JavaScript 封装、继承实现原理。"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["爱范儿"],
        "date": "Fri, 19 Jun 2020 16:20:44 GMT",
        "favorite_num": 9,
        "qid": 698,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 698,
          "subject": "",
          "title": "完成一个表达式，验证用户输入是否是电子邮箱"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["爱范儿"],
        "date": "Fri, 19 Jun 2020 16:20:44 GMT",
        "favorite_num": 5,
        "qid": 702,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 702,
          "subject": "",
          "title": "有哪几种方式可以解决跨域问题？(描述对应的原理)"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["网易"],
        "date": "Fri, 19 Jun 2020 16:20:44 GMT",
        "favorite_num": 9,
        "qid": 707,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 707,
          "subject": "```js\nvar str = \"您好，<%=name%>。欢迎来到<%=location%>\";\nfunction template(str) {\n  // your code\n}\nvar compiled = template(srt);\n// compiled的输出值为：“您好，张三。欢迎来到网易游戏”\ncompiled({ name: \"张三\", location: \"网易游戏\" });\n```\n",
          "title": "填充代码实现 template 方法"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["玄武科技"],
        "date": "Fri, 19 Jun 2020 16:20:44 GMT",
        "favorite_num": 4,
        "qid": 713,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 713,
          "subject": "",
          "title": "请列出至少 5 个 JavaScript 常用的内置对象，说明用途"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["亚美科技"],
        "date": "Fri, 19 Jun 2020 16:20:44 GMT",
        "favorite_num": 8,
        "qid": 720,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 720,
          "subject": "",
          "title": "实现格式化输出，比如输入 999999999，输出 999,999,999"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["亚美科技"],
        "date": "Fri, 19 Jun 2020 16:20:44 GMT",
        "favorite_num": 8,
        "qid": 721,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 721,
          "subject": "",
          "title": "使用 JavaScript 实现 cookie 的设置、读取、删除"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["亚美科技"],
        "date": "Fri, 19 Jun 2020 16:20:44 GMT",
        "favorite_num": 8,
        "qid": 722,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 722,
          "subject": "",
          "title": "请编写一个 JavaScript 函数 parseQueryString,它的用途是把 URL 参数解析为一个对象，url=\"http://iauto360.cn/index.php?key0=0&key1=1&key2=2\""
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["高思教育"],
        "date": "Fri, 19 Jun 2020 16:20:44 GMT",
        "favorite_num": 4,
        "qid": 725,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 725,
          "subject": "",
          "title": "如何实现 a,b 两个变量的交换"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["高思教育"],
        "date": "Fri, 19 Jun 2020 16:20:44 GMT",
        "favorite_num": 8,
        "qid": 728,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 728,
          "subject": "",
          "title": "给 JavaScript 的 String 原生对象添加一个名为 trim 的原型方法，用于截取字符串前后的空白字符"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["58"],
        "date": "Fri, 19 Jun 2020 16:20:44 GMT",
        "favorite_num": 4,
        "qid": 736,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 736,
          "subject": "",
          "title": "微任务和宏任务的区别"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["安居客"],
        "date": "Fri, 19 Jun 2020 16:20:44 GMT",
        "favorite_num": 5,
        "qid": 741,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 741,
          "subject": "",
          "title": "原生 JavaScript 实现图片懒加载的思路"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["安居客"],
        "date": "Fri, 19 Jun 2020 16:20:44 GMT",
        "favorite_num": 4,
        "qid": 742,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 742,
          "subject": "",
          "title": "回调函数和任务队列的区别"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["快手"],
        "date": "Fri, 19 Jun 2020 16:20:44 GMT",
        "favorite_num": 4,
        "qid": 748,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 748,
          "subject": "```js\n//counter.js\nlet counter = 10;\nexport default counter;\n\n//index.js\nimport myCounter from \"./counter\";\nmyCounter += 1;\nconsole.log(myCounter);\n```\n",
          "title": "写出下面代码的输出结果"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["新东方"],
        "date": "Fri, 19 Jun 2020 16:20:44 GMT",
        "favorite_num": 6,
        "qid": 751,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 751,
          "subject": "```js\nconsole.log(\"start\");\nsetTimeout(() => {\n  console.log(\"children2\");\n  Promise.resolve().then(() => {\n    console.log(\"children3\");\n  });\n}, 0);\nnew Promise(function (resolve, reject) {\n  console.log(\"children4\");\n  setTimeout(function () {\n    console.log(\"children5\");\n    resolve(\"children6\");\n  }, 0);\n}).then((res) => {\n  console.log(\"children7\");\n  setTimeout(() => {\n    console.log(res);\n  }, 0);\n});\n```\n",
          "title": "在浏览器执行以下代码，写出打印结果"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:44 GMT",
        "favorite_num": 4,
        "qid": 757,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 757,
          "subject": "```js\nalert(a);\na();\nvar a = 3;\nfunction a() {\n  alert(10);\n}\nalert(a);\na = 6;\na();\n```\n",
          "title": "请写出弹出值，并解释为什么？"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:44 GMT",
        "favorite_num": 4,
        "qid": 758,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 758,
          "subject": "```js\nfunction test(m) {\n  m = { v: 5 };\n}\nvar m = { k: 30 };\ntest(m);\nalert(m.v);\n```\n",
          "title": "写出输出值，并解释为什么"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:44 GMT",
        "favorite_num": 4,
        "qid": 759,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 759,
          "subject": "```js\nfunction yideng() {\n  console.log(1);\n}\n(function () {\n  if (false) {\n    function yideng() {\n      console.log(2);\n    }\n  }\n  console.log(typeof yideng);\n  yideng();\n})();\n```\n",
          "title": "请写出代码执⾏结果，并解释为什么"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:44 GMT",
        "favorite_num": 4,
        "qid": 760,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 760,
          "subject": "```js\nfunction fn() {\n  console.log(this.length);\n}\nvar person = {\n  length: 5,\n  method: function (fn) {\n    fn();\n  },\n};\nperson.method(fn, 1);\n```\n",
          "title": "请写出代码执⾏结果，并解释为什么"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:44 GMT",
        "favorite_num": 4,
        "qid": 767,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 767,
          "subject": "",
          "title": "原生实现addClass,用多种方法"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:44 GMT",
        "favorite_num": 4,
        "qid": 768,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 768,
          "subject": "",
          "title": "实现一个倒计时,setInterval实现的话，如何消除时间误差"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["头条"],
        "date": "Fri, 19 Jun 2020 16:20:44 GMT",
        "favorite_num": 4,
        "qid": 773,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 773,
          "subject": "",
          "title": "函数中的arguments是数组吗？若不是，如何将它转化为真正的数组？"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["头条"],
        "date": "Fri, 19 Jun 2020 16:20:44 GMT",
        "favorite_num": 4,
        "qid": 774,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 774,
          "subject": "```js\nif([] == false){console.log(1)};\nif({} == false) {console.log(2)};\nif([]){console.log(3)};\nif([1] == [1]){console.log(4)};\n```\n",
          "title": "请写出以下代码的打印结果"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["头条"],
        "date": "Fri, 19 Jun 2020 16:20:44 GMT",
        "favorite_num": 4,
        "qid": 775,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 775,
          "subject": "```js\nconst obj = {\n  name:\"jsCoder\",\n  skill:[\"es6\",\"react\",\"angular\"],\n  say:function(){\n    for(var i = 0,len = this.skill.length;i<len;i++){\n      setTimeout(function(){\n        console.log('No.' + i + this.name);\n        console.log(this.skill[i]);\n        console.log('----------------');\n      },0);\n      console.log(i);\n    }\n  }\n}\nobj.say();\n\n/* \n  期望得到下面的结果\n  1\n  2\n  3\n  No.1 jsCoder\n  es6\n  ----------------\n  No.2 jsCoder\n  react\n  ----------------\n  No.3 jsCoder\n  angular\n*/\n```\n",
          "title": "以最小的改动解决以下代码的错误(可以使用ES6)"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["头条"],
        "date": "Fri, 19 Jun 2020 16:20:44 GMT",
        "favorite_num": 4,
        "qid": 776,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 776,
          "subject": "```js\nfunction Animal(name,color){\n  this.name = name;\n  this.color = color;\n}\nAnimal.prototype.say = function(){\n  return `I'm a ${this.color}${this.name}`;\n}\nconst cat = Animal.bind(null,'cat');\nconst cat = new Cat('white');\nif(cat.say() === \"I'm white cat\" && cat instanceof Cat && cat instanceof Animal){\n  console.log('sunccess');\n}\n```\n",
          "title": "实现Function 原型的bind方法，使得以下程序最后能输出“success”"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["58"],
        "date": "Fri, 19 Jun 2020 16:20:44 GMT",
        "favorite_num": 5,
        "qid": 738,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 738,
          "subject": "",
          "title": "列举 3 种强制类型转换和 2 种隐式类型转换"
        },
        "tech_tag": ["工程化", "JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["爱范儿"],
        "date": "Fri, 19 Jun 2020 16:20:44 GMT",
        "favorite_num": 4,
        "qid": 692,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "\n### 实现方案\n\n当对Dom元素进行一系列操作时，对Dom进行访问和修改Dom引起的重绘和重排都比较消耗性能，所以关于操作Dom,应该从以下几点出发：\n\n#### 1.缓存Dom对象 \n\n首先不管在什么场景下。操作Dom一般首先会去访问Dom，尤其是像循环遍历这种时间复杂度可能会比较高的操作。那么可以在循环之前就将主节点，不必循环的Dom节点先获取到，那么在循环里就可以直接引用，而不必去重新查询。\n\n```js\nlet rootElem = document.querySelector('#app');\nlet childList = rootElem.child; // 假设全是dom节点\nfor(let i = 0;i<childList.len;j++){\n    /**\n    * 根据条件对应操作\n    */\n}\n```\n\n#### 2.文档片段\n\n利用`document.createDocumentFragment()`方法创建文档碎片节点，创建的是一个虚拟的节点对象。向这个节点添加dom节点，修改dom节点并不会影响到真实的dom结构。\n\n我们可以利用这一点先将我们需要修改的dom一并修改完，保存至文档碎片中，然后用文档碎片一次性的替换真是的dom节点。与虚拟dom类似，同样达到了不频繁修改dom而导致的重排跟重绘的过程。\n\n```js\nlet fragment = document.createDocumentFragment();\nconst operationDomHandle = (fragment) =>{\n    // 操作 \n}\noperationDomHandle(fragment);\n// 然后最后再替换  \nrootElem.replaceChild(fragment,oldDom);\n```\n\n这样就只会触发一次回流，效率会得到很大的提升。如果需要对元素进行复杂的操作（删减、添加子节点），那么我们应当先将元素从页面中移除，然后再对其进行操作，或者将其复制一个（cloneNode()），在内存中进行操作后再替换原来的节点。\n\n```js\nvar clone=old.cloneNode(true);\noperationDomHandle(clone);\nrootElem.replaceChild(clone,oldDom)\n```\n\n#### 3.用innerHtml 代替高频的appendChild\n\n#### 4.最优的layout方案\n\n批量读，一次性写。先对一个不在render tree上的节点进行操作，再把这个节点添加回render tree。这样只会触发一次DOM操作。 使用`requestAnimationFrame()`，把任何导致重绘的操作放入`requestAnimationFrame`\n\n#### 5.虚拟Dom \n\njs模拟DOM树并对DOM树操作的一种技术。virtual DOM是一个纯js对象（字符串对象），所以对他操作会高效。\n\n利用virtual dom，将dom抽象为虚拟dom，在dom发生变化的时候先对虚拟dom进行操作，通过dom diff算法将虚拟dom和原虚拟dom的结构做对比，最终批量的去修改真实的dom结构，尽可能的避免了频繁修改dom而导致的频繁的重排和重绘。\n\n",
          "answer": "",
          "biz_type": 1,
          "qid": 692,
          "subject": "",
          "title": "有 1000 个 dom，需要更新其中的 100 个，如何操作才能减少 dom 的操作？"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["海风教育"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 551,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "Promise 对象是 JavaScript 的异步操作解决方案，为异步操作提供统一接口。它起到代理作用（proxy），充当异步操作与回调函数之间的中介，使得异步操作具备同步操作的接口。Promise 可以让异步操作写起来，就像在写同步操作的流程，而不必一层层地嵌套回调函数。\n\nPromise解决了callback回调地狱的问题，async、await 是异步的终极解决方案。\n\n来看一下JavaScript中异步方案\n\n#### 1）回调函数（callback）\n\n```js\nsetTimeout(() => {\n    // callback 函数体\n}, 1000)\n```\n\n**缺点：** 回调地狱，不能用 try catch 捕获错误，不能 return\n\n回调地狱的根本问题在于：\n\n- 缺乏顺序性： 回调地狱导致的调试困难，和大脑的思维方式不符\n- 嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身，即（控制反转）\n- 嵌套函数过多的多话，很难处理错误\n\n```js\najax('XXX1', () => {\n    // callback 函数体\n    ajax('XXX2', () => {\n        // callback 函数体\n        ajax('XXX3', () => {\n            // callback 函数体\n        })\n    })\n})\n```\n\n**优点：** 解决了同步的问题（只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。）\n\n#### 2）Promise\n\nPromise就是为了解决callback的问题而产生的。Promise 实现了链式调用，也就是说每次 then 后返回的都是一个全新 Promise，如果我们在 then 中 return ，return 的结果会被 Promise.resolve() 包装\n\n**优点：** 解决了回调地狱的问题\n\n```js\najax('XXX1')\n  .then(res => {\n      // 操作逻辑\n      return ajax('XXX2')\n  }).then(res => {\n      // 操作逻辑\n      return ajax('XXX3')\n  }).then(res => {\n      // 操作逻辑\n  })\n```\n\n**缺点：** 无法取消 Promise ，错误需要通过回调函数来捕获\n\n#### 3）Generator\n\n**特点：** 可以控制函数的执行，可以配合 co 函数库使用\n\n```js\nfunction *fetch() {\n    yield ajax('XXX1', () => {})\n    yield ajax('XXX2', () => {})\n    yield ajax('XXX3', () => {})\n}\nlet it = fetch()\nlet result1 = it.next()\nlet result2 = it.next()\nlet result3 = it.next()\n```\n\n#### 4）Async/await\n\nasync、await 是异步的终极解决方案\n\n**优点：** 代码清晰，不用像 Promise 写一大堆 then 链，处理了回调地狱的问题\n\n**缺点：** await 将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用 await 会导致性能上的降低。\n\n```js\nasync function test() {\n  // 以下代码没有依赖性的话，完全可以使用 Promise.all 的方式\n  // 如果有依赖性的话，其实就是解决回调地狱的例子了\n  await fetch('XXX1')\n  await fetch('XXX2')\n  await fetch('XXX3')\n}\n```\n\n\n\n\n\n\n\n\n",
          "answer": "",
          "biz_type": 1,
          "qid": 551,
          "subject": "",
          "title": "Promise 有没有解决异步的问题"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["微医"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 498,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "#### promise构造函数是同步执行的，then方法是异步执行的\n\n看个代码示例\n\n```js\nnew Promise(resolve => {\n    console.log(1);\n    resolve(3);\n}).then(num => {\n    console.log(num)\n});\nconsole.log(2)\n\n// 输出 123\n```\n\n#### 具体分析下\n\n**语法**\n\n```js\nnew Promise( function(resolve, reject) {...} /* executor */  ) \n```\n\n- 构建 Promise 对象时，需要传入一个 executor 函数，主要业务流程都在 executor 函数中执行。\n- Promise构造函数执行时立即调用executor 函数， resolve 和 reject 两个函数作为参数传递给executor，resolve 和 reject 函数被调用时，分别将promise的状态改为fulfilled(完成)或rejected(失败)。一旦状态改变，就不会再变，任何时候都可以得到这个结果。\n- 在 executor 函数中调用 resolve 函数后，会触发 promise.then 设置的回调函数;而调用 reject 函数后，会触发 promise.catch 设置的回调函数。\n\n> 值得注意的是，Promise 是用来管理异步编程的，它本身不是异步的，new Promise的时候会立即把executor函数执行，只不过我们一般会在executor函数中处理一个异步操作。比如下面代码中，一开始是会先打印出2。\n\n```js\nlet p1 = new Promise(()=>{ \n    setTimeout(()=>{ \n      console.log(1) \n    },1000) \n    console.log(2) \n  }) \nconsole.log(3) // 2 3 1 \n```\n\nPromise 采用了回调函数延迟绑定技术，在执行 resolve 函数的时候，回调函数还没有绑定，那么只能推迟回调函数的执行。\n\n再看个例子\n\n```js\nlet p = new Promise((resolve,reject)=>{ \n  console.log(1); \n  resolve('yideng') \n  console.log(2) \n}) \n// then:设置成功或者失败后处理的方法 \np.then(result=>{ \n //p延迟绑定回调函数 \n  console.log('成功 '+result) \n},reason=>{ \n  console.log('失败 '+reason) \n}) \nconsole.log(3) \n// 1 \n// 2 \n// 3 \n// 成功 yideng\n```\n\nnew Promise的时候先执行executor函数，打印出 1、2，Promise在执行resolve时，触发微任务，还是继续往下执行同步任务， 执行p.then时，存储起来两个函数(此时这两个函数还没有执行),然后打印出3，此时同步任务执行完成，最后执行刚刚那个微任务，从而执行.then中成功的方法。\n\n\n\n",
          "answer": "",
          "biz_type": 1,
          "qid": 498,
          "subject": "",
          "title": "Promise 构造函数是同步还是异步执行，then 呢"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 8,
        "qid": 582,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "#### 1.原生js实现\n\n拖拽需要三大事件：\n\n- mousedown  鼠标摁下触发\n- mousemove  鼠标移动触发\n- mouseup    鼠标抬起触发\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>手动实现拖拽</title>\n</head>\n<style>\n  .move {\n    position: absolute;\n    width: 100px;\n    height: 100px;\n    background: gray\n  }\n</style>\n\n<body>\n  <div class=\"move-container\">\n    <div class=\"move\">\n    </div>\n  </div>\n  <script>\n    let elem = document.querySelector('.move');\n    let dragging; //拖拽状态\n    let trans, portrait; //鼠标按下时相对于选中元素的位移\n\n    document.addEventListener('mousedown', function (e) {\n      if (e.target == elem) {\n        dragging = true; //激活拖拽状态\n        let elemRect = elem.getBoundingClientRect(); //返回元素的大小及其相对于视口的位置\n        trans = e.clientX - elemRect.left; //鼠标按下时和选中元素的坐标偏移:x坐标\n        portrait = e.clientY - elemRect.top; //鼠标按下时和选中元素的坐标偏移:y坐标\n      }\n    });\n    document.addEventListener('mouseup', function (e) {\n      dragging = false;\n    });\n    document.addEventListener('mousemove', function (e) {\n      if (dragging) {\n        var moveX = e.clientX - trans,\n          moveY = e.clientY - portrait;\n\n        elem.style.left = moveX + 'px';\n        elem.style.top = moveY + 'px';\n\n      }\n    });\n  </script>\n</body>\n</html>\n```\n\n#### 2.HTML5原⽣ 拖拽draggable属性以及DataTranfers对象\n\n![流程图](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-582-process.png)\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>手动实现拖拽</title>\n</head>\n<style>\n  .main {\n    display: flex;\n    justify-content: space-around;\n  }\n\n  .left {\n    width: 300px;\n    height: 500px;\n    margin-right: 10px;\n    border: 1px solid red;\n    text-align: center;\n    box-sizing: border-box;\n    padding: 1pxx\n  }\n\n  .right {\n    width: 300px;\n    height: 500px;\n    border: 1px solid lightseagreen;\n    text-align: center;\n    box-sizing: border-box;\n    padding: 1px;\n  }\n\n  .txt {\n    border: 1px solid gray;\n    margin: 1px;\n    padding: 5px;\n    cursor: move;\n  }\n</style>\n\n<body>\n  <main class=\"main\">\n    <div class=\"left\" id=\"left\">\n      <div class=\"txt-show\">左边区域</div>\n      <div id='txt1' draggable=\"true\" class=\"dragable txt txt1\">可移动的文字一</div>\n      <div id='txt2' draggable=\"true\" class=\"dragable txt txt2\">可移动的文字二</div>\n      <div id='txt3' draggable=\"true\" class=\"dragable txt txt3\">可移动的文字三</div>\n      <div id='txt4' draggable=\"true\" class=\"dragable txt txt4\">可移动的文字四</div>\n      <div id='txt5' draggable=\"true\" class=\"dragable txt txt5\">可移动的文字五</div>\n    </div>\n    <div class=\"right\" id='right'>\n      <div class=\"txt-show\">右边区域</div>\n    </div>\n  </main>\n\n  <script>\n    let txtObj = document.getElementsByClassName('txt')\n    for (let i = 0; i < txtObj.length; i++) {\n      txtObj[i].ondragstart = handle_start\n      txtObj[i].ondrag = handle_drag\n      txtObj[i].ondragend = handle_end\n    }\n\n    function handle_start(e) {\n      e.dataTransfer.setData('Text', e.target.id)\n      console.log('handle_start-拖动开始')\n    }\n\n    function handle_drag(e) {\n      console.log('handle_drag-拖动中')\n    }\n\n    function handle_end(e) {\n      console.log('handle_end-拖动结束')\n    }\n    let target = document.getElementById('right')\n    target.ondragenter = handle_enter\n    target.ondragover = handle_over\n    target.ondragleave = handle_leave\n    target.ondrop = handle_drop\n\n    function handle_enter(e) {\n      e.preventDefault()\n      console.log('handle_enter-进入目的地')\n    }\n\n    function handle_over(e) {\n      e.preventDefault()\n      let returnObj = e.dataTransfer.getData('Text')\n      console.log(returnObj + '-handle_over-在目的地范围内')\n    }\n\n    function handle_leave(e) {\n      e.preventDefault()\n      let returnObj = e.dataTransfer.getData('Text')\n      console.log(returnObj)\n      console.log('handle_leave-没有放下就离开目的地')\n    }\n\n    function handle_drop(e) {\n      e.stopPropagation(); // 不再派发事件。解决Firefox浏览器，打开新窗口的问题。\n      e.preventDefault()\n      let returnObj = e.dataTransfer.getData('Text')\n      if (returnObj) {\n        e.target.appendChild(document.getElementById(returnObj))\n      }\n      console.log(returnObj + '-handle_drop-在目的地区释放')\n    }\n  </script>\n</body>\n\n</html>\n```",
          "answer": "",
          "biz_type": 1,
          "qid": 582,
          "subject": "",
          "title": "请手写实现一个拖拽"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 8,
        "qid": 568,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "### 实现方案\n\n#### 1.实现方式一\n\n```js\n//通过标签语句,跳出无限循环：\nloop1:\nwhile(1){\n switch ('yideng'){\n  case 'yideng': break loop1;\n }\n}\n```\n\n#### 2.实现方式二\n\n```js\ntry{\n    while (1) {\n       switch(\"yideng\"){\n           case \"yideng\" :\n           \t\tconsole.log(true);\n           \t\tthrow new Error(\"跳出循环\");\n        }  \n    }\n} catch(e){\n    console.log(e);\n}\n```\n\n#### 3.实现方式三\n\n```js\n//javascript goto实现 \nout:\nfor(let i =0;i<1;i++){\n\twhile (1) {\n    switch (\"yideng\") {\n      case \"yideng\":\n        console.log(\"yideng\");\n        continue out\n    }\n\t}\n}\n```\n\n#### 4.实现方式四\n\n```js\n//return\nfunction test(){\n  while (1) {\n    switch (\"yideng\") {\n      case \"yideng\":\n        console.log(\"yideng\");\n        return;\n    }\n  }\n}\ntest();\n```\n\n\n",
          "answer": "",
          "biz_type": 1,
          "qid": 568,
          "subject": "```js\nwhile (1) {\n  switch (\"yideng\") {\n    case \"yideng\":\n    //禁止直接写一句break\n  }\n}\n```\n",
          "title": "请修改代码能跳出死循环"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 9,
        "qid": 555,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "### 代码实现\n\n```js\nclass PersonGenerator {\n  taskQueue = [];\n  constructor(name) {\n    this.taskQueue.push(() => this.sayHi(name));\n    this.runTaskQueue();\n  }\n  nextTask = () => {\n    if (this.taskQueue.length > 0) {\n      const task = this.taskQueue.shift();\n      if (typeof task === \"function\") {\n        task();\n        this.nextTask();\n      }\n      if (typeof task === \"number\") {\n        console.log(`Sleep ${task} seconds \\n`);\n        setTimeout(() => this.nextTask(), task * 1000);\n      }\n    }\n  };\n\n  runTaskQueue = () => {\n    setTimeout(() => this.nextTask());\n  };\n\n  sayHi(name) {\n    console.log(`Hi! This is ${name}! \\n`);\n    return this;\n  }\n\n  sleep(seconds) {\n    this.taskQueue.push(seconds);\n    return this;\n  }\n\n  sleepFirst(seconds) {\n    this.taskQueue.splice(-1, 0, seconds);\n    return this;\n  }\n\n  eat(food) {\n    this.taskQueue.push(() => console.log(`Eat ${food}~ \\n`));\n    return this;\n  }\n}\n\nconst Person = name => new PersonGenerator(name);\n\nPerson(\"helloWorld\").sleepFirst(3).sleep(3).eat(\"little_cute\");\n```",
          "answer": "",
          "biz_type": 1,
          "qid": 555,
          "subject": "```js\nPerson(\"Li\");\n// 输出： Hi! This is Li!\n\nPerson(\"Dan\").sleep(10).eat(\"dinner\");\n// 输出：\n// Hi! This is Dan!\n// 等待10秒..\n// Wake up after 10\n// Eat dinner~\n\nPerson(\"Jerry\").eat(\"dinner\").eat(\"supper\");\n// 输出：\n// Hi This is Jerry!\n// Eat dinner~\n// Eat supper~\n\nPerson(\"Smith\").sleepFirst(5).eat(\"supper\");\n// 输出：\n// 等待5秒\n// Wake up after 5\n// Hi This is Smith!\n// Eat supper\n```\n",
          "title": "按照调用实例，实现下面的 Person 方法"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["阿里"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 8,
        "qid": 565,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "### 代码实现\n\n#### 1.实现方式一\n\n```js\n// es6 串行\nconst mergePromise = (ajaxArray) => {\n  return (async function () {\n      let ret = []\n      let idx = 0\n      let len = ajaxArray.length\n      while(idx < len) {\n          let data = await ajaxArray[idx]()\n          ret.push(data)\n          idx++\n      }\n      return ret\n  })()\n}\n\nmergePromise([ajax1, ajax2, ajax3]).then(data => {\n  console.log('done')\n  console.log(data)\n})\n```\n\n#### 2.实现方式二\n\n```js\n// 串行\nconst mergePromise = (ajaxArray) => {\n  return new Promise((resolve, reject) => {\n    let tem = []\n    let promise = ajaxArray.map(ajax => () => ajax().then(data => tem.push(data)))\n      .reduce((memo, cur) => {\n        return () => {\n          return memo().then(cur)\n        }\n      })\n    promise().then(() => {\n      resolve(tem)\n    })\n  })\n}\n\nmergePromise([ajax1, ajax2, ajax3]).then(data => {\n  console.log('done')\n  console.log(data)\n})\n```\n\n#### 3.实现方式三\n\n```js\nconst mergePromise = (ajaxArray) => {\n  //串行\n  return new Promise((resolve, reject) => {\n      let len = ajaxArray.length\n      let idx = 0\n      let tem = []\n      function next() {\n          if (idx === len) return resolve(tem)\n          ajaxArray[idx]().then((data) => {\n              tem.push(data)\n              idx++\n              next()\n          }).catch(reject)\n      }\n      next()\n  })\n}\n\nmergePromise([ajax1, ajax2, ajax3]).then(data => {\n  console.log('done')\n  console.log(data)\n})\n```\n\n#### 4.实现方式四\n\n```js\nfunction mergePromise(promiselist) {\n  var result = []\n  mergePromise.then = function (callback) {\n    function fn(i) {\n      // console.log(promiselist[i]())\n      promiselist[i]().then((data) => {\n        result.push(data)\n        if (i !== promiselist.length - 1) {\n          fn(++i)\n        }\n        if (result.length === promiselist.length) {\n          callback(result)\n        }\n      })\n    }\n    fn(0)\n  }\n  return mergePromise\n}\nmergePromise([ajax1, ajax2, ajax3]).then((data) => {\n  console.log('done')\n  console.log(data) // data 为[1,2,3]\n})\n// 执行结果为：1 2 3 done [1,2,3]\n```\n",
          "answer": "",
          "biz_type": 1,
          "qid": 565,
          "subject": "```js\nconst timeout = (ms) =>\n  new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve();\n    }, ms);\n  });\nconst ajax1 = () =>\n  timeout(2000).then(() => {\n    console.log(\"1\");\n    return 1;\n  });\nconst ajax2 = () =>\n  timeout(1000).then(() => {\n    console.log(\"2\");\n    return 2;\n  });\nconst ajax3 = () =>\n  timeout(2000).then(() => {\n    console.log(\"3\");\n    return 3;\n  });\nconst mergePromise = (ajaxArray) => {\n  // 1,2,3 done [1,2,3] 此处写代码 请写出ES6、ES3 2中解法\n};\nmergePromise([ajax1, ajax2, ajax3]).then((data) => {\n  console.log(\"done\");\n  console.log(data); // data 为[1,2,3]\n});\n// 执行结果为：1 2 3 done [1,2,3]\n```\n",
          "title": "按要求完成代码"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["微医"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 501,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "### RN混原生\n\nRN 混原生，工程中大部分是RN，调用部分原生模块。\n\nRN调用原生可以实现调用设备API，实现使用原生功能。\n\n比如使用RN实现一个原生的组件\n\n以iOS为例，实现一个普通模块，iOS新建一个类继承NSObject实现RCTBridgeModule协议，在类实现文件里添加RCT_EXPORT_MODULE()的宏，标记自己是个准备给js调用的模块，这里可以传模块名，默认为类名。然后通过RCT_EXPORT_METHOD()或RCT_REMAP_METHOD()暴露方法给到js调用，结果可以通过block回调，也可以是返回一个Promise。在js层通过NativeModules.模块名.方法名来调用。\n\n如果是实现一个原生UI模块，则新建类继承RCTViewManager实现RCTBridgeModule协议，类里比普通模块多实现-(UIView *)view方法，返回一个原生组件的UIView实例。ReactJS 层使用时先使用requireNativeComponent方法引进，就可以在js层愉快的使用原生组件了。\n\n### 原生混 RN\n\n原生混用RN，RN的js代码最后都是打包为jsbundle文件，所以其实就是如何使用这个文件来渲染出一个原生组件和处理逻辑。\n\n原生可以使用多个RCTRootView加载执行不同的jsbundle文件，这些RCTRootView可以被addSubView到别的view 或者被UIViewController持有，以达到原生混用RN的目的。\n\n\u200c原生混用RN可以实现多业务拆分，rn实现的不同业务代码打包多个jsbundle文件，再由原生调用，可以业务间的独立性。",
          "answer": "",
          "biz_type": 1,
          "qid": 501,
          "subject": "",
          "title": "loadsh 深拷贝实现原理"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["微医", "玄武科技", "快手"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 492,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 492,
          "subject": "",
          "title": "介绍 JS 全部数据类型，基本数据类型和引用数据类型的区别"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["微医"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 493,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 493,
          "subject": "",
          "title": "Array 是 Object 类型吗"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["微医", "寺库"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 494,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 494,
          "subject": "",
          "title": "说一下栈和堆的区别，垃圾回收时栈和堆的区别"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["微医"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 495,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 495,
          "subject": "",
          "title": "数组里面有 10 万个数据，取第一个元素和第 10 万个元素的时间相差多少"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["微医"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 496,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 496,
          "subject": "",
          "title": "Async/Await 怎么实现"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["微医"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 497,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 497,
          "subject": "",
          "title": "JavaScript 为什么要区分微任务和宏任务"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["微医"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 499,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 499,
          "subject": "",
          "title": "JavaScript 执行过程分为哪些阶段"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["微医"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 500,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 500,
          "subject": "",
          "title": "词法作用域和 this 的区别"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["微医"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 502,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 502,
          "subject": "",
          "title": "ES6 中 let 块作用域是怎么实现的"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["宝宝树"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 515,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 515,
          "subject": "",
          "title": "formData 和原生的 ajax 有什么区别"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["宝宝树"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 516,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 516,
          "subject": "",
          "title": "介绍下表单提交，和 formData 有什么关系"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["宝宝树"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 8,
        "qid": 519,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 519,
          "subject": "",
          "title": "promise 如何实现 then 处理，动手实现 then"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["宝宝树"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 521,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 521,
          "subject": "",
          "title": "如何对相对路径引用进行优化"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["海康威视"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 524,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 524,
          "subject": "",
          "title": "如何处理异常捕获"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["海康威视"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 525,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 525,
          "subject": "",
          "title": "项目如何管理模块"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["海康威视", "新东方"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 526,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 526,
          "subject": "",
          "title": "尽可能多的写出判断数组的方法"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["海康威视"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 527,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 527,
          "subject": "",
          "title": "介绍 localstorage 的 api"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["蘑菇街"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 529,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 529,
          "subject": "",
          "title": "使用原型最大的好处"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["酷家乐"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 531,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 531,
          "subject": "",
          "title": "单例、工厂、观察者项目中实际场景"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["酷家乐"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 532,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 532,
          "subject": "",
          "title": "添加原生事件不移除为什么会内存泄露，还有哪些地方会存在内存泄漏"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["酷家乐"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 533,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 533,
          "subject": "",
          "title": "setInterval 需要注意的点"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["酷家乐"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 534,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 534,
          "subject": "",
          "title": "定时器为什么是不精确的"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["酷家乐"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 535,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 535,
          "subject": "",
          "title": "setTimeout(1)和 setTimeout(2)之间的区别"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["酷家乐"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 536,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 536,
          "subject": "",
          "title": "介绍宏任务和微任务"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["酷家乐"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 539,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 539,
          "subject": "",
          "title": "介绍 class 和 ES5 的类以及区别"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["酷家乐"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 540,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 540,
          "subject": "",
          "title": "介绍 defineProperty 方法，什么时候需要用到"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["酷家乐"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 5,
        "qid": 541,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 541,
          "subject": "",
          "title": "for..in 和 object.keys 的区别"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["酷家乐"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 542,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 542,
          "subject": "",
          "title": "使用闭包特权函数的使用场景"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["海风教育"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 550,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 550,
          "subject": "",
          "title": "JavaScript 是什么范式语言"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["海风教育"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 552,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 552,
          "subject": "",
          "title": "Promise 和 setTimeout 的区别"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 556,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 556,
          "subject": "```js\nvar yideng = {\n  bar: function () {\n    return this.baz;\n  },\n  baz: 1,\n};\n(function () {\n  console.log(typeof arguments[0]());\n})(yideng.bar);\n```\n",
          "title": "请写出正确的执行结果"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 557,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 557,
          "subject": "```js\nfunction test() {\n  console.log(\"out\");\n}\n(function () {\n  if (false) {\n    function test() {\n      console.log(\"in\");\n    }\n    test();\n  }\n})();\n```\n",
          "title": "请写出正确的执行结果"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 558,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 558,
          "subject": "```js\nvar x = [typeof x, typeof y][1];\ntypeof x;\n```\n",
          "title": "请写出正确的执行结果"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 559,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 559,
          "subject": "```js\n(function (x) {\n  delete x;\n  return x;\n})(1);\n```\n",
          "title": "请写出正确的执行结果"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 560,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 560,
          "subject": "```js\nvar x = 1;\nif (function f() {}) {\n  x += typeof f;\n}\nx;\n```\n",
          "title": "请写出正确的执行结果"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 561,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 561,
          "subject": "```js\nfunction f() {\n  return f;\n}\nnew f() instanceof f;\n```\n",
          "title": "请写出正确的执行结果"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 562,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 562,
          "subject": "```js\nObject.prototype.a = \"a\";\nFunction.prototype.a = \"a1\";\nfunction Person() {}\nvar yideng = new Person();\nconsole.log(yideng.a);\n```\n",
          "title": "请写出代码正确执行结果，并解释原因"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 563,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 563,
          "subject": "```js\nvar yideng = [0];\nif (yideng) {\n  console.log(yideng == true);\n} else {\n  console.log(\"yideng\");\n}\n```\n",
          "title": "请写出正确的执行结果"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 564,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 564,
          "subject": "```js\nfunction yideng() {\n  return;\n  {\n    a: 1;\n  }\n}\nvar result = yideng();\nconsole.log(result.a);\n```\n",
          "title": "请写出正确的执行结果"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 566,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 566,
          "subject": "```html\n<script>\n  //使用未定义的变量yideng\n  yideng;\n  console.log(1);\n</script>\n<script>\n  console.log(2);\n</script>\n```\n",
          "title": "请写出正确的执行结果"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 567,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 567,
          "subject": "```js\nvar yideng = Array(3);\nyideng[0] = 2;\nvar result = yideng.map(function (elem) {\n  return \"1\";\n});\nconsole.log(result);\n```\n",
          "title": "请写出正确的执行结果"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 8,
        "qid": 569,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 569,
          "subject": "```js\nwhile (1) {\n  console.log(Math.random());\n}\n```\n",
          "title": "修改代码不造成死循环"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 570,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 570,
          "subject": "```js\n[1 < 2 < 3, 3 < 2 < 1];\n```\n",
          "title": "请写出代码正确执行结果"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 571,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 571,
          "subject": "```js\n2 == [[[2]]];\n```\n",
          "title": "请写出代码正确执行结果"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 572,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 572,
          "subject": "```js\nconsole.log(\"✈️\".length);\n// 1.计算以上字节每位✈️的起码点\n// 2.描述这些字节的起码点代表什么\n```\n",
          "title": "计算以上字节每位 ✈️ 的起码点，并描述这些字节的起码点代表什么"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 573,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 573,
          "subject": "```js\nvar yidenga = Function.length,\n  yidengb = new Function().length;\nconsole.log(yidenga === yidengb);\n```\n",
          "title": "请写出代码正确执行结果，并解释原因"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 574,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 574,
          "subject": "```js\nvar length = 10;\nfunction fn() {\n  console.log(this.length);\n}\nvar yideng = {\n  length: 5,\n  method: function (fn) {\n    fn();\n    arguments[0]();\n  },\n};\nyideng.method(fn, 1);\n```\n",
          "title": "请写出代码正确执行结果"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 575,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 575,
          "subject": "```js\nvar yi = new Date(\"2018-08-20\"),\n  deng = new Date(2018, 08, 20);\n[yi.getDay() === deng.getDay(), yi.getMonth() === deng.getMonth()];\n```\n",
          "title": "请写出代码正确执行结果，并解释原因"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 576,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 576,
          "subject": "```js\nfor (\n  let i = (setTimeout(() => console.log(\"a->\", i)), 0);\n  setTimeout(() => console.log(\"b->\", i)), i < 2;\n  i++\n) {\n  i++;\n}\n```\n",
          "title": "请写出代码正确执行结果"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 577,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 577,
          "subject": "```js\n[typeof null, null instanceof Object];\n```\n",
          "title": "请写出代码正确执行结果，并解释原因"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 578,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 578,
          "subject": "```html\n<textarea maxlength=\"10\" id=\"yideng\"></textarea>\n<script>\n  document.getElementById(\"yideng\").value = \"a\".repeat(10) + \"b\";\n</script>\n```\n",
          "title": "请问当前 textarea 文本框展示的内容是什么？"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 579,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 579,
          "subject": "```js\nfunction sidEffecting(ary) {\n  arr[0] = arr[2];\n}\nfunction yideng(a, b, c = 3) {\n  c = 10;\n  sidEffecting(arguments);\n  return a + b + c;\n}\nyideng(1, 1, 1);\n```\n",
          "title": "请写出代码正确执行结果"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 580,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 580,
          "subject": "```js\nyideng();\nvar flag = true;\nif (flag) {\n  function yideng() {\n    console.log(\"yideng1\");\n  }\n} else {\n  function yideng() {\n    console.log(\"yideng2\");\n  }\n}\n```\n",
          "title": "请写出代码正确执行结果"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 581,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 581,
          "subject": "```js\nvar min = Math.min(),\n  max = Math.max();\nconsole.log(min < max);\n```\n",
          "title": "请写出代码正确执行结果，并解释为什么"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 8,
        "qid": 583,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 583,
          "subject": "",
          "title": "请手动实现一个浅拷贝"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 8,
        "qid": 584,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 584,
          "subject": "",
          "title": "介绍 instanceof 原理，并手动实现"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 8,
        "qid": 585,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 585,
          "subject": "",
          "title": "请实现一个 JSON.stringfy"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 8,
        "qid": 586,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 586,
          "subject": "",
          "title": "请实现一个 JSON.parse"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["会小二"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 593,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 593,
          "subject": "```js\nconsole.log(\"hello\" + (1 < 2) ? \"word\" : \"me\");\n```\n",
          "title": "请写出代码正确执行结果，并解释原因？"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["会小二"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 594,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 594,
          "subject": "```js\nvar a = (b = 1);\n(function () {\n  var a = (b = 2);\n})();\nconsole.log(a, b);\n```\n",
          "title": "请写出代码正确执行结果，并解释原因？"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["会小二"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 595,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 595,
          "subject": "```js\nif ([] instanceof Object) {\n  console.log(typeof null);\n} else {\n  console.log(typeof undefined);\n}\n```\n",
          "title": "请写出代码正确执行结果，并解释原因？"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["会小二"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 596,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 596,
          "subject": "```js\nvar obj = {};\nobj.name = \"first\";\nvar peo = obj;\npeo.name = \"second\";\nconsole.log(obj.name);\n```\n",
          "title": "请写出代码正确执行结果，并解释原因？"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["会小二"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 597,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 597,
          "subject": "```js\nfunction say(word) {\n  let word = \"hello\";\n  console.log(word);\n}\nsay(\"hello Lili\");\n```\n",
          "title": "请写出代码正确执行结果，并解释原因？"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["会小二"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 602,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 602,
          "subject": "```js\nfunction fun(n, o) {\n  console.log(o);\n  return {\n    fun: function (m) {\n      return fun(m, n);\n    },\n  };\n}\nvar b = fun(0).fun(1).fun(2).fun(3);\n```\n",
          "title": "请写出代码的正确执行结果，并解释原因？"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["会小二"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 8,
        "qid": 609,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 609,
          "subject": "",
          "title": "JavaScript 中如何模拟实现方法的重载"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["会小二", "安居客"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 610,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 610,
          "subject": "",
          "title": "请解释 JSONP 的工作原理"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["会小二"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 8,
        "qid": 611,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 611,
          "subject": "",
          "title": "用 html、css、js 模拟实现一个下拉框，使得下拉框在各个浏览器下的样式和行为完全一致，说出你的设计方案，并且重点说明功能设计时要考虑的因素。"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["会小二"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 8,
        "qid": 613,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 613,
          "subject": "```js\n/* \n  1.从start至end,每隔100毫秒console.log一个数字，每次数字增幅为1\n  2.返回的对象中需要包含一个cancel方法，用于停止定时操作\n  3.第一个数字需要立即输出\n*/\n```\n",
          "title": "实现一个打点计时器"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["会小二"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 8,
        "qid": 615,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 615,
          "subject": "",
          "title": "JavaScript 写一个单例模式，可以具体到某一个场景"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["会小二", "安居客"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 616,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 616,
          "subject": "",
          "title": "JavaScript 基本数据类型都有哪些？用 typeOf 判断分别显示什么？"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["会小二"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 617,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 617,
          "subject": "",
          "title": "怎么判断引用类型数据，兼容判断原始类型数据呢？"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["酷狗"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 624,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 624,
          "subject": "",
          "title": "概述异步编程模型"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 8,
        "qid": 625,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 625,
          "subject": "",
          "title": "在一个 ul 里有 10 个 li,实现点击对应的 li,输出对应的下标"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 8,
        "qid": 626,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 626,
          "subject": "",
          "title": "分别对以下数组进行去重，1:[1,'1',2,'2',3]，2:[1,[1,2,3['1','2','3'],4],5,6]"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 627,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 627,
          "subject": "",
          "title": "简述 JavaScript 中的函数的几种调用方式"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 8,
        "qid": 628,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 628,
          "subject": "",
          "title": "编写一个 Person 类，并创建两个不同的 Person 对象"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["腾讯应用宝"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 5,
        "qid": 633,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 633,
          "subject": "",
          "title": "手写实现 call"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 5,
        "qid": 634,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 634,
          "subject": "",
          "title": "手写实现 apply"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 635,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 635,
          "subject": "",
          "title": "一个 dom 必须要操作几百次，该如何解决，如何优化？"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 638,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 638,
          "subject": "",
          "title": "页面埋点怎么实现"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 639,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 639,
          "subject": "",
          "title": "除了 jsonp、postmessage 后端控制，怎么实现跨页面通讯"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 9,
        "qid": 643,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 643,
          "subject": "",
          "title": "说一下 let、const 的实现，动手实现一下"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 648,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 648,
          "subject": "",
          "title": "addEventListener 再 removeListener 会不会造成内存泄漏"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 649,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 649,
          "subject": "",
          "title": "scrollview 如何进行又能优化(例如 page=100 时，往上滚动)"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 650,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 650,
          "subject": "",
          "title": "原生 JavaScript 获取 ul 中的第二个 li 里边的 p 标签的内容"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["快手"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 651,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 651,
          "subject": "",
          "title": "说下 offsetWith 和 clientWidth、offsetHeight 和 clientHeight 的区别，说说 offsetTop，offsetLeft，scrollWidth、scrollHeight 属性都是干啥的"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["快手"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 8,
        "qid": 656,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 656,
          "subject": "",
          "title": "写一个函数打乱一个数组，传入一个数组，返回一个打乱的新数组"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["快手"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 657,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 657,
          "subject": "",
          "title": "数组截取插入 splice，push 返回值，数组的栈方法、队列方法、排序方法、操作方法、迭代方法说一下"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["快手"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 658,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 658,
          "subject": "",
          "title": "判断一个变量的类型，写个方法用 Object.prototype.toString 判断传入数据的类型"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["快手"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 659,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 659,
          "subject": "",
          "title": "判断一个变量的类型，写个方法用 Object.prototype.toString 判断传入数据的类型？Object.prototype.toString.call(Symbol) 返回什么？"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["快手"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 660,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 660,
          "subject": "",
          "title": "对作用域和闭包的理解，解释下 let 和 const 的块级作用域"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["心娱"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 661,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 661,
          "subject": "```js\nsetTimeout(function () {\n  console.log(1);\n}, 0);\nnew Promise(function executor(resolve) {\n  console.log(2);\n  for (var i = 0; i < 10000; i++) {\n    i == 9999 && resolve();\n  }\n  console.log(3);\n}).then(function () {\n  console.log(4);\n});\nconsole.log(5);\n```\n",
          "title": "以下代码输出什么？"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["快手"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 662,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 662,
          "subject": "",
          "title": "switch case，case 具体是怎么比较的，哪些情况下会走到 default"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["快手"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 663,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 663,
          "subject": "",
          "title": "说下 typeof()各种类型的返回值？instanceof 呢？"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["快手"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 664,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 664,
          "subject": "",
          "title": "if([] == 0), [1,2] == \"1,2\", if([]), [] == 0 具体是怎么对比的"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["快手"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 665,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 665,
          "subject": "",
          "title": "如何加快页面渲染速度，都有哪些方式"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["滴滴", "58"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 666,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 666,
          "subject": "",
          "title": "genertor 的实现原理"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["头条"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 673,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 673,
          "subject": "",
          "title": "判断是否是数组的方法"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["头条", "亚美科技"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 9,
        "qid": 677,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 677,
          "subject": "",
          "title": "手写 EventEmitter 实现"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["老虎"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 679,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 679,
          "subject": "```js\nvar s = \"laohu\";\ns[0] = 1;\nconsole.log(s); //laohu\nvar s = \"laohu\";\ns += 2020;\nconsole.log(s); // laohu2020\n// 上面两行为什么这么输出\n```\n",
          "title": "给出的两行代码为什么这么输出"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["酷狗"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 680,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 680,
          "subject": "",
          "title": "动画性能如何检测"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["酷狗", "沪江", "58"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 682,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 682,
          "subject": "",
          "title": "平时都用到了哪些设计模式"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["酷狗"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 684,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 684,
          "subject": "",
          "title": "对 service worker 的理解"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["酷家乐"],
        "date": "Fri, 19 Jun 2020 16:20:43 GMT",
        "favorite_num": 4,
        "qid": 537,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "\n- 构造函数里面是同步执行的，无法取消\n- then里面是异步的，属于微任务；\n\n看个例子\n\n```js\nnew Promise(function (resolve, reject) {\n    // 这里面属于宏任务，是同步执行的\n    console.log('macrotask');\n    resolve('result');\n}).then(function (value) {\n    // `then`中的回调函数属于微任务，在`resolve`执行后被推到微任务队列等待执行\n    console.log('microtask');\n    console.log(value === 'result'); // true\n});\n```\n\n\n",
          "answer": "",
          "biz_type": 1,
          "qid": 537,
          "subject": "",
          "title": "promise 里面和 then 里面执行有什么区别"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 314,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "- **封装：** 把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏\n- **继承：** 使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展\n- **多态：** 一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口",
          "answer": "",
          "biz_type": 1,
          "qid": 314,
          "subject": "",
          "title": "面向对象的三要素是啥？都是啥意思？"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["兑吧", "海风教育"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 487,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "### Koa2\n\nKoa2是一个基于Node实现的Web框架，特点是优雅、简洁、健壮、体积小、表现力强。它所有的功能通过插件的形式来实现。\n\nkoa2 是通过封装原生的node http模块。koa的 Context 把 Node 的 Request 对象和 Response 对象封装到单个对象中，并且暴露给中间件等回调函数.\n\n最主要的核心是 **中间件机制洋葱模型**\n\n![洋葱模型](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-487-middleware.png)\n\n通过use()注册多个中间件放入数组中，然后从外层开始往内执行，遇到next()后进入下一个中间件，当所有中间件执行完后，开始返回，依次执行中间件中未执行的部分.整体流程就是递归处理。\n\n```js\nfunction compose(middleware) {\n    // console.log(middleware)\n    // [ [AsyncFunction: fn1], [AsyncFunction: fn2], [AsyncFunction: fn3] ]\n    return () => {\n      // 先执行第一个函数\n      return dispatch(0)\n  \n      function dispatch(i) {\n        let fn = middleware[i]\n        // 如何不存在直接返回 Promise\n        if (!fn) {\n          return Promise.resolve()\n        }\n        // step1: 返回一个 Promise，因此单纯变成一个 Promise 且 立即执行\n        // step2: 往当前中间件传入一个next()方法，当这个中间件有执行 next 的时候才执行下一个中间件\n        return Promise.resolve(fn(function next() {\n          // 执行下一个中间件\n          return dispatch(i + 1)\n        }))\n      }\n    }\n  }\n```\n\n核心代码是 `return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));` 递归遍历，直到遍历完所有的中间件next，生成一个多层嵌套的promise函数。\n\nkoa的中间件处理可以当做是洋葱模型。中间件数组中中间件的执行是通过递归的方式来执行，调用dispatch函数，从第一个开始执行，当有next方法时创建一个promise，等到下一个中间件执行结果后再执行next后端代码。当第二个中间件也有next方法时，依然会创建一个新的promise等待下一个中间件的执行结果，这也就是中间件next的执行原理\n\n`app.use()` 将中间件push到中间件数组中，然后在listen方法中通过调用compose方法进行集中处理。",
          "answer": "",
          "biz_type": 1,
          "qid": 487,
          "subject": "",
          "title": "介绍 koa2，原理是什么？"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["沪江", "寺库"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 449,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "### JavaScript中的垃圾回收\n\nV8（javascript引擎）的新老空间内存分配与大小限制\n\n#### 一、新老空间\n\n凡事都有一把双刃剑，在垃圾回收的演变过程中人们发现，没有一种特定的垃圾回收机制是可以完美的解决问题，因此V8采用了新生代与老生代结合的垃圾回收方式，将内存分为新生代和老生代。 新生代频繁进行GC，空间小，采用的是空间换时间的scavenge算法，所以又划分为两块semispace，From和To。 老生代大部分保存的是存活时间较长的或者较大的对象。采用的是mark-sweep（主）&mark-compact（辅）算法。\n\nV8限制了js对象可以使用的内存空间，不止是因为最初V8是作为浏览器引擎而设计的。还有其垃圾回收机制的影响因素。V8使用stop-the-world（全停顿）, generational, accurate的垃圾回收器。在执行回收之时会暂时中断程序的执行，而且只处理对象堆栈。当内存达到一定的体积时，进行一次垃圾回收的时间将会很长，从而影响其相应而造成浏览器假死的状况。因此，在V8中限制老生代64位为1.4GB，32位为0.7GB，新生代64位为32M，32位为16M。 当然，如果需要更大的内存空间，在node中可以进行更改。\n\n#### 二、对象晋升\n\n新生成的对象放入新生代内存中，那哪些对象会被放入老生代中呢？大部分放入老生代的对象是由新生代晋升而来。对象的晋升的方式：\n\n当新生代的To semispace内存占满25%时，此时再从From semispace拷贝对象将不会再放入To空间中以防影响后续的新对象分配，而将其直接复制到老生代空间中。\n\n在进行一次垃圾回收后，第二次GC时，发现已经经历过一次GC的对象在从From空间复制时直接复制到老生代。\n\n在新对象分配时大部分对象被分配到新生代的From semispace，但当这个对象的体积过大，超过1MB的内存页时，直接分配到老生代中的large Object Space。\n\n#### 三、新生代的GC机制与优缺点\n\n**回收机制**\n\n新生代采用Scavenge算法，在scavenge算法的实现过程中，则主要采用了cheney算法。即使用复制方式来实现垃圾回收。它将内存一分为二，每一个空间都是一个semispace。\n\n处于使用状态的是From空间，闲置的是To空间。当分配对象时，先是分配到From空间，垃圾回收时会检查From空间中存活的对象，将其复制到To空间，回收其他的对象。完成复制后会进行紧缩，From和To空间的调换。如此循环往复。\n\n**优势**\n\n由其执行的算法及过程我们可以了解到，在新生代的垃圾回收过程中，总是由一半的semispace是空余的。scavenge只复制存活的对象，在新生代的内存中，存活的对象相对较少，所以使用这个算法恰到好处。\n\n#### 四、老生代的GC机制与优缺点\n\n**回收机制**\n\n由于的scavenge算法只复制存活的对象，如果在老生代中也使用此算法的话就会造成复制很多对象，效率低，并且造成很大的内存空间浪费。 老生代中采用的则是mark-sweep（标记清除）和mark-compact（标记整理）结合的方式。而为什么使用两者结合呢？这就要讲到两者的优点与缺点。\n\n**mark-sweep（标记清除）**\n\n1）优点\n\n- 标记清除需要标记堆内存中的所有对象，标记出在使用的对象，清除那些没有被标记的对象。在老生代内存中与新生代相反，不使用的对象只占很小一部分，所以清除不用的对象效率高。\n- mark-sweep不会将内存空间分为两半，所以，不会浪费一半空间。\n\n2）缺点\n\n但标记清除会造成一个问题，就是在清除过后会导致内存不连续，造成内存碎片，如果此时需要储存一个很大的内存而空间又不够的时候就会造成没有必要的反复垃圾回收。\n\n**mark-compact（标记整理）**\n\n1）优点\n\n此时标记整理就可以出场了，在标记清除的过程中，标记整理会将存活的对象和需要清除的对象移动到两端。然后将其中一段需要清除的消灭掉，可以解决标记清除造成的内存碎片问题。\n\n2）缺点\n\n但是在紧缩内存的过程中需要移动对象，效率比较低。所以V8在清理时主要会使用Mark-sweep,在空间不足以对新生代中晋升过来的对象进行分配时才会使用Mark-compact。\n\n#### 五、垃圾回收机制的优化\n\n增量标记(在老空间里引入了此方式)\n\nscavenge算法,mark-sweep及mark-compact都会导致stop-the-world（全停顿）。而全停顿很容易带来明显的程序迟滞，标记阶段很容易就会超过100ms，因此V8引入了增量标记，将标记阶段分为若干小步骤，每个步骤控制在5ms内，每运行一段时间标记动作，就让JavaScript程序执行一会儿，如此交替，明显地提高了程序流畅性，一定程度上避免了长时间卡顿。\n\n\n\n\n",
          "answer": "",
          "biz_type": 1,
          "qid": 449,
          "subject": "",
          "title": "JavaScript 里垃圾回收机制是什么，常用的是哪种，怎么处理的"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 307,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 307,
          "subject": "",
          "title": "addEventListener 的第三个参数的作用"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["网易"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 309,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 309,
          "subject": "",
          "title": "获取 id 为 netease 节点下所有的 checkbox 子元素(不用框架，注意兼容)"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["腾讯应用宝", "安居客"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 310,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 310,
          "subject": "",
          "title": "使用原型链如何实现继承"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 311,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 311,
          "subject": "",
          "title": "如何获取一个对象的深度"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 9,
        "qid": 312,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 312,
          "subject": "",
          "title": "reduce 函数的功能，如何实现的，动手实现一下"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 313,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 313,
          "subject": "",
          "title": "说一下 splice 和 slice 的功能用法"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 315,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 315,
          "subject": "",
          "title": "函数中的 this 有几种"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 316,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 316,
          "subject": "",
          "title": "如何同时获取 html 中的 h1,h2,h3,h4,h5,h6 中的内容"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 317,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 317,
          "subject": "",
          "title": "JavaScript 的执行流程"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 318,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 318,
          "subject": "",
          "title": "Promise.resolve(obj)，obj 有几种可能"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 319,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 319,
          "subject": "```js\nnew Promise((resolve, reject) => {\n  reject(\"1\");\n})\n  .catch((e) => {\n    console.log(1);\n  })\n  .then((res) => {\n    console.log(2);\n  });\n```\n",
          "title": "写出代码执行结果"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 320,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 320,
          "subject": "",
          "title": "nextTick 是在本次循环执行，还是在下次，setTimeout(() => {}, 0)呢？"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 329,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 329,
          "subject": "",
          "title": "使用正则去掉 Dom 中的内联样式"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 330,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 330,
          "subject": "",
          "title": "写一个匹配 ip 地址的正则"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 331,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 331,
          "subject": "",
          "title": "写一个匹配 Html 标签的正则"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 336,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 336,
          "subject": "",
          "title": "IOC 是啥，应用场景是啥？"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 338,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 338,
          "subject": "```js\nfunction a(obj) {\n  obj.a = 2;\n  obj = { a: 3 };\n  return obj;\n}\nconst obj = { a: 1 };\na(obj);\nconsole.log(obj);\n```\n",
          "title": "写出代码执行的打印结果"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 339,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 339,
          "subject": "```js\nd1,,,\nd2,,,\nd3,,,\n\n把上边的字符串输出1，2，3的和 //6\n```\n",
          "title": "实现函数"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["阿里"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 361,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 361,
          "subject": "",
          "title": "怎么实现 this 对象的深拷贝"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["宝宝树"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 362,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 362,
          "subject": "",
          "title": "使用 canvas 绘图时如何组织成通用组件"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["网易"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 363,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 363,
          "subject": "",
          "title": "表单可以跨域吗"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["网易"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 364,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 364,
          "subject": "",
          "title": "搜索请求如何处理？搜索请求中文如何请求？"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["网易", "海风教育"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 365,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 365,
          "subject": "",
          "title": "介绍观察者模式"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["网易"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 366,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 366,
          "subject": "",
          "title": "介绍中介者模式"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["网易", "有赞", "微医"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 367,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 367,
          "subject": "",
          "title": "观察者和订阅-发布的区别，各自用在哪里"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["网易"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 368,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 368,
          "subject": "",
          "title": "通过什么做到并发请求"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["网易"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 370,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 370,
          "subject": "",
          "title": "介绍 service worker"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["网易", "沪江"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 374,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 374,
          "subject": "",
          "title": "介绍事件代理以及优缺点，主要解决什么问题"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["网易", "蘑菇街"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 376,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 376,
          "subject": "",
          "title": "介绍下 this 的各种情况"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["网易"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 378,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 378,
          "subject": "",
          "title": "使用路由时出现问题如何解决"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["滴滴", "挖财", "宝宝树", "海康威视"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 386,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 386,
          "subject": "",
          "title": "JavaScript 异步解决方案的发展历程以及优缺点"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["滴滴"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 399,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 399,
          "subject": "",
          "title": "介绍 AST（Abstract Syntax Tree）抽象语法树"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["头条"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 403,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 403,
          "subject": "",
          "title": "对 async、await 的理解，内部原理是怎样的？"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["头条", "安居客"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 406,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 406,
          "subject": "",
          "title": "== 和 ===的区别，什么情况下用相等=="
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["头条", "挖财", "饿了么", "心娱"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 407,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 407,
          "subject": "",
          "title": "bind、call、apply 的区别"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["头条"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 408,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 408,
          "subject": "",
          "title": "介绍下原型链"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["有赞"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 414,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 414,
          "subject": "",
          "title": "介绍暂时性死区"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["有赞"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 415,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 415,
          "subject": "",
          "title": "ES6 中的 map 和原生的对象有什么区别"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["有赞"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 419,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 419,
          "subject": "",
          "title": "对纯函数的理解"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["有赞"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 420,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 420,
          "subject": "",
          "title": "介绍 JSX"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["有赞"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 425,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 425,
          "subject": "",
          "title": "如何设计一个 localStorage，保证数据的实效性"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["有赞", "网易", "乘法云"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 5,
        "qid": 427,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 427,
          "subject": "",
          "title": "实现 sum 方法，使 sum(x)(y),sum(x,y)返回的结果相同"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["有赞"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 428,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 428,
          "subject": "",
          "title": "两个对象如何比较"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["挖财"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 429,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 429,
          "subject": "",
          "title": "说一下变量的作用域链"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["挖财"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 430,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 430,
          "subject": "",
          "title": "介绍 dom 树对比"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["挖财"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 431,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 431,
          "subject": "",
          "title": "如何设计状态树"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["沪江"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 441,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 441,
          "subject": "",
          "title": "Ajax 发生跨域要设置什么（前端）"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["沪江"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 442,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 442,
          "subject": "",
          "title": "加上 CORS 之后从发起到请求正式成功的过程"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["沪江"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 444,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 444,
          "subject": "",
          "title": "Async 里面有多个 await 请求，可以怎么优化"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["沪江", "酷狗"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 448,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 448,
          "subject": "",
          "title": "JavaScript 变量类型分为几种，区别是什么"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["饿了么"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 456,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 456,
          "subject": "",
          "title": "ES5 和 ES6 有什么区别"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["饿了么"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 457,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 457,
          "subject": "",
          "title": "取数组的最大值（ES5、ES6）"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["饿了么"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 458,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 458,
          "subject": "",
          "title": "some、every、find、filter、map、forEach 有什么区别"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["饿了么"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 461,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 461,
          "subject": "",
          "title": "页面上生成一万个 button，并且绑定事件，如何做（JS 原生操作 DOM）？循环绑定时的 index 是多少，为什么，怎么解决？"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["饿了么"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 462,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 462,
          "subject": "",
          "title": "页面上有一个 input，还有一个 p 标签，改变 input 后 p 标签就跟着变化，如何处理？监听 input 的哪个事件，在什么时候触发？"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["携程", "海风教育"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 5,
        "qid": 464,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 464,
          "subject": "",
          "title": "Promise 和 async/await，和 Callback 有什么区别"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["喜马拉雅"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 470,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 470,
          "subject": "",
          "title": "项目中对于用户体验做过什么优化"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["喜马拉雅"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 472,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 472,
          "subject": "",
          "title": "前后端通信使用什么方案"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["喜马拉雅"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 473,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 473,
          "subject": "",
          "title": "RESTful 常用的 Method"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["兑吧"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 8,
        "qid": 478,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 478,
          "subject": "",
          "title": "new 的实现原理，动手实现一个 new"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["兑吧", "网易", "心娱"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 479,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 479,
          "subject": "",
          "title": "如何实现 H5 手机端的适配"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["兑吧"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 483,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 483,
          "subject": "",
          "title": "如何去除 url 中的#号"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["兑吧"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 485,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 485,
          "subject": "",
          "title": "base64 为什么能提升性能，缺点"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["兑吧"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 486,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 486,
          "subject": "",
          "title": "介绍 webp 这个图片文件格式"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["兑吧"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 488,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 488,
          "subject": "",
          "title": "异步请求，低版本 fetch 如何低版本适配"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["兑吧"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 489,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 489,
          "subject": "",
          "title": "ajax 如何处理跨域？CORSr 如何设置？"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["兑吧"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 490,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 490,
          "subject": "",
          "title": "jsonp 为什么不支持 post 方法"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["兑吧"],
        "date": "Fri, 19 Jun 2020 16:20:42 GMT",
        "favorite_num": 4,
        "qid": 491,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 491,
          "subject": "",
          "title": "介绍 Immuable"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["完美世界"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 146,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "#### base64编码\n\n**术语版概念解释**\n\nBase64是一种编码方式。选用大小写字母、0-9、+ 和 / 的64个可打印字符来表示二进制数据。将二进制数据每三个字节一组，一共是 3*8=24 bit，划为 4组， 每组 6个bit。如果要编码的二进制不是 3 的倍数，会用 `x\\00` 在末尾补足，然后在编码的末尾加上 1-2 个 `=`号，表示补了多少字节，解码的时候会去掉。将3 字节的二进制数据编码为 4 字节的文本，是可以让数据在邮件正文、网页等直接显示。\n\n**通俗概念解释**\n\nBase64是传输8Bit字节码的编码方式，Base64可以将ASCII字符串或者是二进制编码成只包含A—Z，a—z，0—9，+，/ 这64个字符（ 26个大写字母，26个小写字母，10个数字，1个+，一个 / 刚好64个字符组成）；这64个字符用6个bit位就可以全部表示出来，一个字节有8个bit 位，那么还剩下两个bit位，这两个bit位用0来补充。转换完空出的结果就用就用“=”来补位，总之要保证最后编码出来得字节数是4的倍数。\n\n**注意**\n\n因为标准的 Base64 会有 `+`和`\\`在 URL 中不能直接做参数，于是出现了一种 \"url safe\"的 Base64，将 `+` 和 `\\` 转换为 `-` 和 `_`。因为 `=` 用在 URL 和 Cookie 会有歧义，所以很多 Base64 会把 `=` 去掉。由于 Base64 的长度永远是 4 的倍数，所以只要加上 `=` 把长度变为 4 的倍数，就可以解码。",
          "answer": "",
          "biz_type": 1,
          "qid": 146,
          "subject": "",
          "title": "说一下 base64 的编码方式"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["网易"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 152,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 152,
          "subject": "",
          "title": "改变 this 指向的方式都有哪些？"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["网易"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 156,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 156,
          "subject": "",
          "title": "说一下`module.exports`和`exports`的区别，`export`和`export default`的区别"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["网易"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 158,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 158,
          "subject": "",
          "title": "number 为什么会出现精度损失，怎样避免"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["微软"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 8,
        "qid": 164,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 164,
          "subject": "",
          "title": "实现一个函数将中文数字转成数字"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["微软"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 8,
        "qid": 165,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 165,
          "subject": "",
          "title": "节流"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["易车"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 169,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 169,
          "subject": "",
          "title": "如何实现 5 秒自动刷新一次页面(具体都有什么方法 reload 之类的)"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["易车", "脉脉", "虎扑", "喜马拉雅", "百分点", "海风教育", "58"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 170,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 170,
          "subject": "",
          "title": "都了解哪些 ES6、ES7 的新特性，箭头函数可以被 new 吗"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["易车", "脉脉", "微医", "海康威视"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 171,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 171,
          "subject": "",
          "title": "说一下 JavaScript 继承都有哪些方法"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["新东方"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 8,
        "qid": 174,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 174,
          "subject": "```js\nfunction A(name) {\n  this.name = name;\n}\nA.prototype.getName = function () {\n  console.log(this.name);\n};\n```\n",
          "title": "已知函数 A，要求构造⼀个函数 B 继承 A"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["新东方"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 175,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 175,
          "subject": "```js\nvar arry = [];\nvar obj = {};\n// arry,obj 转成字符串的结果是什么？\n```\n",
          "title": "数组和对象转换为字符串结果"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["新东方"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 176,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 176,
          "subject": "```js\nvar a = {\n  name: \"A\",\n  fn() {\n    console.log(this.name);\n  },\n};\na.fn();\na.fn.call({ name: \"B\" });\nvar fn1 = a.fn;\nfn1();\n// 写出打印结果\n```\n",
          "title": "请写出以下代码的打印结果"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["新东方"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 177,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 177,
          "subject": "```js\nlet int = 1;\nsetTimeout(function () {\n  console.log(int);\n  int = 2;\n  new Promise((resolve, reject) => {\n    resolve();\n  }).then(function () {\n    console.log(int);\n    int = 7;\n  });\n  console.log(int);\n});\nint = 3;\nconsole.log(int);\nnew Promise((resolve, reject) => {\n  console.log(int);\n  return resolve((int = 4));\n}).then(function (res) {\n  console.log(int);\n  int = 5;\n  setTimeout(function () {\n    console.log(int);\n    int = 8;\n  });\n  return false;\n});\nconsole.log(int);\n// 写出打印结果\n```\n",
          "title": "请写出以下代码的打印结果"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["新东方"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 8,
        "qid": 178,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 178,
          "subject": "```js\n/*\n\t已知对象A = {name: 'sfd', getName: function(){console.log(this.name)}},\n\t现要求⽤不同⽅式对A进⾏改造实现A.name发⽣变化时⽴即执⾏A.getName\n*/\n```\n",
          "title": "要求⽤不同⽅式对 A 进⾏改造实现 A.name 发⽣变化时⽴即执⾏ A.getName"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["新东方"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 8,
        "qid": 179,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 179,
          "subject": "```js\nvar arrys = [];\nfor (var i = 0; i < 10; i++) {\n  arrys.push(function () {\n    return i;\n  });\n}\narrys.forEach(function (fn) {\n  console.log(fn());\n}); //本⾏不能修改\n```\n",
          "title": "修改以下代码，使得最后⼀⾏代码能够输出数字 0-9（最好能给多种答案）"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["头条"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 8,
        "qid": 182,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 182,
          "subject": "",
          "title": "请给出识别 Email 的正则表达式"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["头条"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 183,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 183,
          "subject": "",
          "title": "设计 AutoComplete 组件(又叫搜索组件、自动补全组件等)时，需要考虑什么问题？"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["头条"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 8,
        "qid": 184,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 184,
          "subject": "```js\nclass TreeNode{\n  value:number\n  left?:TreeNode\n  right?:TreeNode\n}\nfunction getPathSum(root){\n  // your code\n}\n// 例子，一层二叉树如下定义，路径包括1 —> 2 ,1 -> 3\nconst node = new TreeNode();\nnode.value = 1;\nnode.left = new TreeNode();\nnode.left.value = 2;\nnode.right = new TreeNode();\nnode.right.value = 3;\ngetPathSum(node); // return 7 = (1+2) + (1+3)\n```\n",
          "title": "实现函数接受任意二叉树，求二叉树所有根到叶子路径组成的数字之和"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["滴滴"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 187,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 187,
          "subject": "```js\nfunction a(obj) {\n  obj.a = 2;\n  obj = { a: 3 };\n  return obj;\n}\nconst obj = { a: 1 };\na(obj);\nconsole.log(obj);\n```\n",
          "title": "请写出一下代码的打印结果"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["滴滴"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 8,
        "qid": 188,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 188,
          "subject": "",
          "title": "Promise 链式调用如何实现"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["滴滴", "高德"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 189,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 189,
          "subject": "",
          "title": "说一下对`BigInt`的理解，在什么场景下会使用"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["滴滴"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 190,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 190,
          "subject": "",
          "title": "null 是不是一个对象，如果是，如何判断一个对象是 null，不使用 JavaScript 提供的 api 如何进行判断"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["滴滴", "高德"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 192,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 192,
          "subject": "",
          "title": "说一下对于堆栈的理解"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["高德"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 194,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 194,
          "subject": "",
          "title": "`[] == ![]`为什么"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["高德"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 8,
        "qid": 197,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 197,
          "subject": "",
          "title": "如何把真实 dom 转变为虚拟 dom，代码实现一下"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["高德"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 198,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 198,
          "subject": "",
          "title": "说一下错误监控的实现，错误监控的正确使用方式，日志如何分等级"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["快手"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 204,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 204,
          "subject": "```js\nvar a = { x: 1 };\nvar b = a;\na.x = a = { n: 1 };\nconsole.log(a); // ?\nconsole.log(b); // ?\n```\n",
          "title": "请写出以下代码执行结果"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["快手"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 205,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 205,
          "subject": "```js\nFunction.prototype.a = () = >{alert(1)}\nObject.prototype.b = () = >{alert(2)}\nfunction A(){};\nconst a = new A();\na.a();\na.b();\n// 写出执行结果\n```\n",
          "title": "请写出以下代码执行结果"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["快手"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 206,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 206,
          "subject": "```js\nlet a = 0;\nconsole.log(a);\nconsole.log(b);\nlet b = 0;\nconsole.log(c);\nfunction c() {}\n// 写出执行结果\n```\n",
          "title": "请写出以下代码执行结果"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["快手"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 207,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 207,
          "subject": "```js\nvar x = 10;\nfunction a(y) {\n  var x = 20;\n  return b(y);\n}\nfunction b(y) {\n  return x + y;\n}\na(20);\n// 写出执行结果\n```\n",
          "title": "请写出以下代码执行结果"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["快手"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 208,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 208,
          "subject": "```js\nconsole.log(1);\nsetTimeout(() => {\n  console.log(2);\n});\nprocess.nextTick(() => {\n  console.log(3);\n});\nsetImmediate(() => {\n  console.log(4);\n});\nnew Promise((resolve) => {\n  console.log(5);\n  resolve();\n  console.log(6);\n}).then(() => {\n  console.log(7);\n});\nPromise.resolve().then(() => {\n  console.log(8);\n  process.nextTick(() => {\n    console.log(9);\n  });\n});\n// 写出执行结果\n```\n",
          "title": "请写出以下代码执行结果"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["快手"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 209,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 209,
          "subject": "```js\n[1, 2, 3, 4, 5].map(parselnt);\n// 写出执行结果\n```\n",
          "title": "请写出以下代码执行结果"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["快手"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 210,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 210,
          "subject": "```js\ntypeof typeof typeof [];\n// 写出执行结果\n```\n",
          "title": "请写出以下代码执行结果"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["快手"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 212,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 212,
          "subject": "",
          "title": "说一下什么是死锁"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["快手"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 8,
        "qid": 213,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 213,
          "subject": "```js\nfunction add() {\n  // your code\n}\nfunction one() {\n  // your code\n}\nfunction two() {\n  // your code\n}\nconsole.log(add(one(two()))); //3\nconsole.log(add(two(one()))); //3\n```\n",
          "title": "实现以下代码"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["快手"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 8,
        "qid": 214,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 214,
          "subject": "",
          "title": "请实现一个 cacheRequest 方法，保证发出多次同一个 ajax 请求时都能拿到数据，而实际上只发出一次请求"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["快手"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 8,
        "qid": 215,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 215,
          "subject": "",
          "title": "实现一个函数柯里化"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["脉脉", "兑吧", "快手"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 229,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 229,
          "subject": "",
          "title": "说一下对原型链的理解，画一个经典的原型链图示"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["脉脉"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 231,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 231,
          "subject": "",
          "title": "说一下 ajax/axios/fetch 的区别"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["脉脉"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 8,
        "qid": 232,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 232,
          "subject": "",
          "title": "用 Promise 封装一个 ajax"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["自如"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 236,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 236,
          "subject": "",
          "title": "描述 DOM 事件捕获的具体流程"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["自如"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 8,
        "qid": 239,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 239,
          "subject": "",
          "title": "请实现`$on,$emit`"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["自如", "腾讯应用宝", "快手"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 8,
        "qid": 240,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 240,
          "subject": "",
          "title": "实现 bind 方法，不能使用 call、apply、bind"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["自如"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 8,
        "qid": 241,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 241,
          "subject": "",
          "title": "手写实现 sleep 函数"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["自如"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 244,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 244,
          "subject": "",
          "title": "请写出原生 js 如何设置元素高度"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["自如"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 8,
        "qid": 250,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 250,
          "subject": "",
          "title": "用原生 js 实现自定义事件"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 8,
        "qid": 251,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 251,
          "subject": "",
          "title": "换行字符串格式化"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 8,
        "qid": 253,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 253,
          "subject": "",
          "title": "输入一个日期 返回几秒前、几小时前、几天前、几月前"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 8,
        "qid": 254,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 254,
          "subject": "",
          "title": "将 153812.7 转化为 153,812.7"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["掌门一对一"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 260,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 260,
          "subject": "",
          "title": "数组有哪些方法 讲讲区别跟使用场景"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["掌门一对一"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 262,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 262,
          "subject": "",
          "title": "讲一下函数式编程"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["网易", "虎扑", "沪江"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 263,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 263,
          "subject": "",
          "title": "promise 跟 async await 的区别，使用场景 \u2028"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["虎扑"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 264,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 264,
          "subject": "",
          "title": "async、await 如何进行错误捕获"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["虎扑"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 271,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 271,
          "subject": "",
          "title": "weak-Set、weak-Map 和 Set、Map 区别"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 276,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 276,
          "subject": "",
          "title": "valueOf 与 toString 的区别"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["菜鸟网络"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 279,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 279,
          "subject": "",
          "title": "怎么判断是一个空对象"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 280,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 280,
          "subject": "```js\nsetTimeout(() => {\n  console.log(0);\n}, 0);\nnew Promise((res) => setTimeout(res, 0)).then(() => {\n  console.log(1);\n  setTimeout(() => {\n    console.log(2);\n  }, 0);\n  new Promise((r = r())).then(() => {\n    console.log(3);\n  });\n});\nsetTimeout(() => {\n  console.log(4);\n}, 0);\nnew Promise((res) => res()).then(() => {\n  console.log(5);\n});\n```\n",
          "title": "请写出下面代码的执行结果"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 281,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 281,
          "subject": "```js\nfunction Foo() {\n  getName = function () {\n    alert(1);\n  };\n  return this;\n}\ngetName();\nFoo.getName = function () {\n  alert(2);\n};\nFoo.prototype.getName = function () {\n  alert(3);\n};\ngetName = function () {\n  alert(4);\n};\n\n// 请写出下面的输出结果\ngetName90;\nFoo.getName();\nnew Foo().getName();\n```\n",
          "title": "请写出下面代码的执行结果"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 283,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 283,
          "subject": "",
          "title": "请只用数组方法和 Math.random()在一条语句的情况下，实现生成给定位数的随机数组，例如生成 10 位随机数组[1.1,102.1,2,3,8,4,90,123,11,123],数组内数字随机生成。"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 8,
        "qid": 284,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 284,
          "subject": "```js\nlet setter = function (conten, key, value) {\n  // your code\n};\nlet n = {\n  a: {\n    b: {\n      c: { d: 1 },\n      bx: { y: 1 },\n    },\n    ax: { y: 1 },\n  },\n};\n// 修改值\nsetter(n, \"a.b.c.d\", 3);\nconsole.log(n.a.b.c.d); //3\nsetter(n, \"a.b.bx\", 1);\nconsole.log(n.b.bx); //1\n```\n",
          "title": "实现一个 setter 方法"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["腾讯应用宝"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 287,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 287,
          "subject": "",
          "title": "setTimeout 与 setInterval 区别"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["挖财"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 289,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 289,
          "subject": "",
          "title": "项目中如何应用数据结构"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["寺库"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 293,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 293,
          "subject": "",
          "title": "闭包的核心是什么"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["心娱", "安居客"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 295,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 295,
          "subject": "```js\nvar fullname = \"Test1\";\nvar obj = {\n  fullname: \"Test2\",\n  prop: {\n    fullname: \"Test3\",\n    getFullname: function () {\n      return this.fullname;\n    },\n  },\n};\nconsole.log(obj.prop.getFullname());\nvar test = obj.prop.getFullname;\nconsole.log(test());\n```\n",
          "title": "写出代码输出结果"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 8,
        "qid": 296,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 296,
          "subject": "",
          "title": "实现一个功能，发送请求 5s 时间后，如果没有数据返回，中断请求,提示错误"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 297,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 297,
          "subject": "",
          "title": "什么是作用域链"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["腾讯应用宝", "安居客"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 298,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 298,
          "subject": "",
          "title": "介绍事件冒泡、事件代理、事件捕获，以及它们的关系"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 299,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 299,
          "subject": "",
          "title": "for..of 和 for...in 是否可以直接遍历对象，为什么"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 300,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 300,
          "subject": "",
          "title": "在 map 中和 for 中调用异步函数的区别"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 301,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 301,
          "subject": "",
          "title": "gennerator yield 的作用"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["微医"],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 302,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 302,
          "subject": "",
          "title": "promise 的状态有哪些"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 303,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 303,
          "subject": "",
          "title": "在 ES6 中有哪些解决异步的方法"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 304,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 304,
          "subject": "",
          "title": "es6 类继承中 super 的作用"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:41 GMT",
        "favorite_num": 4,
        "qid": 305,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 305,
          "subject": "",
          "title": "cros 的简单请求和复杂请求的区别"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["边锋"],
        "date": "Fri, 19 Jun 2020 16:20:40 GMT",
        "favorite_num": 5,
        "qid": 107,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "可以理解为在做一件事时是：“该让谁来做”。那个谁就是对象，他要怎么做是他自己的事，最后就是一群对象合力把事情做好。相比较于面向过程的“步骤化”分析问题，面向对象则是“功能化”分析问题，其优点体现在：\n\n- 将数据和方法封装在一起，以接口的方式提供给调用者，调用者无需关注问题的解决过程；\n- 对象之间通过继承，减少代码的冗余，提高程序的复用性；\n- 通过重载/重写方法来拓展对象的功能；\n\n以上的优点来源于面向对象的三大特征：封装、继承和多态。",
          "answer": "",
          "biz_type": 1,
          "qid": 107,
          "subject": "",
          "title": "说一下对面向对象的理解，面向对象有什么好处"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["快手"],
        "date": "Fri, 19 Jun 2020 16:20:40 GMT",
        "favorite_num": 4,
        "qid": 75,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "**大致思路**\n\n飞机按照图形中心展开一个坐标序列对应小方块，然后检测的是对应子弹在小方块的覆盖，小方块按照之前说的划分区域可以是`1*1 2*2`的,具体看想要的精度是多少",
          "answer": "",
          "biz_type": 1,
          "qid": 75,
          "subject": "",
          "title": "1000*1000 的画布，上面有飞机、子弹，如何划分区域能够更有效的做碰撞检测，类似划分区域大小与碰撞检测效率的算法，说一下大致的思路"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:40 GMT",
        "favorite_num": 8,
        "qid": 94,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "**1）思路**\n\n1 fetch 请求介绍\n2 并发，并发，某个完成后可以继续发请求\n3 所有请求结束后 callback\n4 注意容错（①参数错误，参数不正确、接口地址不正确、最大数不正确、回调函数不正确；②接口错误）\n5 边界值\n6 不能在 while 中使用 fetch，因为 while 是同步，它永远不会等待异步的 fetch 结果回来\n7 使用 for 循环 + 递归的方法\n\n**2）代码实现**\n\n```js\n/**\n *\n * @param { Array } urls  请求地址数组\n * @param { Number } max 最大并发请求数\n * @param { Function } callback  回调地址\n */\nfunction parallelFetch(urls, max, callback) {\n  // 如果当前环境不支持 fetch , 则提示程序无法正常运行\n  if (!window.fetch || \"function\" !== typeof window.fetch) {\n    throw Error(\"当前环境不支持 fetch 请求，程序终止\");\n  }\n\n  // 如果参数有误，则提示输入正确的参数\n  if (!urls || urls.length <= 0) {\n    throw Error(\"urls is empty: 请传入正确的请求地址\");\n  }\n\n  const _urlsLength = urls.length; // 请求地址数组的长度\n  const _max = max || 1; // 保证最大并发值的有效性\n  let _currentIndex = 0; // 当前请求地址的索引\n  let _maxFetch = max <= _urlsLength ? max : _urlsLength; // 当前可以正常请求的数量，保证最大并发数的安全性\n  let _finishedFetch = 0; // 当前完成请求的数量，用于判断何时调用回调\n  \n  console.log(`开始并发请求，接口总数为 ${_urlsLength} ，最大并发数为 ${_maxFetch}`);\n  // 根据最大并发数进行循环发送，之后通过状态做递归请求\n  for (let i = 0; i < _maxFetch; i++) {\n    fetchFunc();\n  }\n  // 请求方法\n  function fetchFunc() {\n    // 如果所有请求数都完成，则执行回调方法\n    if (_finishedFetch === _urlsLength) {\n        console.log(`当前一共 ${_urlsLength} 个请求，已完成 ${_finishedFetch} 个`)\n      if (\"function\" === typeof callback) return callback();\n      return false;\n    }\n    // 如果当前请求的索引大于等于请求地址数组的长度，则不继续请求\n    if (_currentIndex >= _urlsLength) {\n      _maxFetch = 0;\n    }\n\n    //如果可请求的数量大于0，表示可以继续发起请求\n    if (_maxFetch > 0) {\n      console.log( `当前正发起第 ${_currentIndex + 1 } 次请求，当前一共 ${_urlsLength} 个请求，已完成 ${_finishedFetch} 个，请求地址为：${urls[_currentIndex]}`);\n      // 发起 fetch 请求\n      fetch(urls[_currentIndex])\n        .then((res) => {\n          // TODO 业务逻辑，正常的逻辑，异常的逻辑\n          // 当前请求结束，正常请求的数量 +1\n          _maxFetch += 1;\n          _finishedFetch += 1;\n          fetchFunc();\n        })\n        .catch((err) => {\n          // TODO 异常处理，处理异常逻辑\n          // 当前请求结束，正常请求的数量 +1\n          _maxFetch += 1;\n          _finishedFetch += 1;\n          fetchFunc();\n        });\n      // 每次请求，当前请求地址的索引  +1\n      _currentIndex += 1;\n      // 每次请求，可以正常请求的数量 -1\n      _maxFetch -= 1;\n    }\n  }\n}\n\nlet urls = [];\nfor (let i = 0; i < 100; i++) {\n  urls.push(`https://jsonplaceholder.typicode.com/todos/${i}`);\n}\nconst max = 10;\nconst callback = () => {\n  console.log(\"我请求完了\");\n};\n\nparallelFetch(urls, max, callback);\n```",
          "answer": "",
          "biz_type": 1,
          "qid": 94,
          "subject": "```js\n/*\n\t可以批量请求数据，所有的 URL 地址在 urls 参数中，\n        同时可以通过 max 参数控制请求的并发度，当所有请\n        求结束之后，需要执行 callback 回调函数。发请求的\n        函数可以直接使用 fetch 即可\n*/\n```\n",
          "title": "请实现如下的函数"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["快手"],
        "date": "Fri, 19 Jun 2020 16:20:40 GMT",
        "favorite_num": 4,
        "qid": 68,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "#### 判断数组方式\n\n- `[] instanceof Array`\n- `Object.prototype.toString.call([]) === '[object Array]'`\n- `Array.prototype.isPrototypeOf([])`\n- `[].constructor === Array`\n- `Array.isArray([])`\n\n#### 如何处理类数组对象\n\n**1）JavaScript 类数组对象的定义**\n\n- 可以通过索引访问元素，并且拥有 length 属性；\n- 没有数组的其他方法，例如 `push` ， `forEach` ， `indexOf` 等。\n\n```js\nvar foo = {\n    0: 'JS',\n    1: 'Node',\n    2: 'TS',\n    length: 3\n}\n```\n\n**2）转换方式**\n\n```js\n// 方式一\nArray.prototype.slice.call(arguments);\nArray.prototype.slice.apply(arguments)\n[].slice.call(arguments)\n\n// 方式二\nArray.from(arguments);\n\n// 方式三\n// 这种方式要求 数据结构 必须有 遍历器接口\n[...arguments] \n\n// 方式四\n[].concat.apply([],arguments)\n\n// 方式五：手动实现\nfunction toArray(s){\n  var arr = [];  \n  for(var i = 0,len = s.length; i < len; i++){   \n    arr[i] = s[i];   \n  }  \n  return arr;  \n}\n```\n\n**3）转换后注意几点**\n\n- 数组长度由类数组的length属性决定\n- 索引不连续，会自动补位undefined\n- 仅考虑0和正整数索引；\n- slice会产生稀疏数组，内容是empty而不是undefined\n- 类数组push注意，push操作的是索引值为length的位置\n\n\n",
          "answer": "",
          "biz_type": 1,
          "qid": 68,
          "subject": "",
          "title": "怎样判断一个对象是否是数组，如何处理类数组对象"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["快手"],
        "date": "Fri, 19 Jun 2020 16:20:40 GMT",
        "favorite_num": 4,
        "qid": 110,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "#### 代码实现\n\n大体思路\n\n- 生成随机数\n- 从随机数中得到16进制的颜色值，颜色值长度是6位或者3位（要么取3位要么取6位）\n\n**1）实现方式一**\n\n- for循环遍历\n\n```js\nfunction getColor(){\n    var colorElements = \"0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f\";\n    var colorArray = colorElements.split(\",\");\n    var color =\"#\";\n    for(var i =0;i<6;i++){\n        color+=colorArray[Math.floor(Math.random()*16)];\n    }\n    return color;\n}\n```\n\n**2）实现方式二**\n\n- while循环\n\n```js\nconst getColor = () => {\n    var hexNums = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\"];\n    let i = 0;\n    let color = '#';\n    while (i < 6) {\n        color += hexNums[parseInt(Math.random() * 16)];\n        i++;\n    }\n    return color\n}\n```\n\n**3）实现方式三**\n\n `padEnd()` 方法会用一个字符串填充当前字符串（如果需要的话则重复填充），返回填充后达到指定长度的字符串。从当前字符串的末尾（右侧）开始填充。\n\n```js\nfunction randomColor(){\n\treturn '#'+Math.floor(Math.random() * 0xffffff).toString(16).padEnd(6, '0');\n}\n```\n\n**4）实现方式四**\n\n- substr方法\n\n```js\nconst randomColor = () => color = '#' + Math.random().toString(16).substr(-6);\n```",
          "answer": "",
          "biz_type": 1,
          "qid": 110,
          "subject": "",
          "title": "实现输出一个十六进制的随机颜色(#af0128a)"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["快手"],
        "date": "Fri, 19 Jun 2020 16:20:40 GMT",
        "favorite_num": 4,
        "qid": 112,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "#### 代码实现\n\n- **考点：** 对字符串的操作以及多种实现方法\n- **思路：** 利用String和Array的属性和方法或正则来分割、替换、重组字符串，利用toUpperCase()或charCodeAt()+fromCharCode()实现大写转换\n\n**1）实现方式一**\n\n```js\n// 第一种  map\nfunction firstUp1(str) {\n    return str.split(\"-\").map(function (key) {\n        return key[0].toUpperCase() + key.slice(1);\n    }).join(\"\");\n}\nconsole.log(firstUp1(string))\n```\n\n**2）实现方式二**\n\n```js\n// 第二种 正则\nfunction firstUp2(str) {\n    return str.replace(/-[a-z]/g, function (match) {\n        return match.replace(\"-\", \"\").toUpperCase()\n    })\n}\nconsole.log(firstUp2(string))\n```\n\n**3）综合版**\n\n```js\n// 转化成大写\nfunction myToUpperCase() {\n    // 1.String自带方法\n    return this.toUpperCase()\n\n    // 2.toLocaleUpperCase一般情况下跟toUpperCase返回的结果一样\n    // return this.toLocaleUpperCase()\n\n    // 3.根据ASCII之间的规律用charCodeAt()+fromCharCode()来转换大小写\n    // if (!/[a-z]/.test(this)) return this\n    // return String.fromCharCode(this.charCodeAt() - 32)\n}\n\nString.prototype.myToUpperCase = myToUpperCase\n\n// 分割、替换、重组字符串\nfunction transform(str, separator) {\n    // 1.常规String和Array的api\n    return str\n        .split(separator)\n        .map(word => word.charAt(0).myToUpperCase() + word.slice(1))\n        .join(\"\")\n\n    // 2.常规String和Array的api\n    // return str.split(separator).reduce((pre, word) => {\n    //     return pre + word.substr(0, 1).myToUpperCase() + word.substring(1)\n    // }, \"\")\n\n    // 3.使用正则\n    // return (separator + str)\n    //     .replace(new RegExp(separator+'(.)', \"g\"), (_,c) => c.myToUpperCase())\n}\nconsole.log(transform(\"kuai-shou-front-end\", \"-\"))\n```\n\n",
          "answer": "",
          "biz_type": 1,
          "qid": 112,
          "subject": "",
          "title": "手写代码实现`kuai-shou-front-end=>KuaiShouFrontEnd`"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["伴鱼", "腾讯应用宝"],
        "date": "Fri, 19 Jun 2020 16:20:40 GMT",
        "favorite_num": 4,
        "qid": 89,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "#### 什么是按需加载\n\n和异步加载script的目的一样(异步加载script的方法),按需加载/代码切割也可以解决首屏加载的速度。\n\n**设么时候需要按需加载**\n\n如果是大文件,使用按需加载就十分合适。比如一个近1M的全国城市省市县的json文件,在我首屏加载的时候并不需要引入,而是当用户点击选项的时候才加载。如果不点击,则不会加载。就可以缩短首屏http请求的数量以及时间。\n\n如果是小文件,可以不必太在意按需加载。过多的http请求会导致性能问题。\n\n#### 实现按需加载的方法\n\n**1）ES2020 动态导入**\n\n```js\nimport('./dynamic-module').then((module) => {\n    // do something\n})\n// 也支持await关键字\nconst module = await import('./dynamic-module')\n```\n\n**2）vue 中通过 router 配置**\n\nvue 中通过 router 配置, 实现组件的按需加载, 在一些单个组件文件较大的时候, 采用按需加载能够减少build.js的体积, 优化加载速度(如果组件的体积较小, 那么采用按需加载会增加额外的http请求, 反倒增加了加载时间)\n\n```js\n//app.js\n\nimport Vue from 'vue'\nimport App from './App.vue'\nimport VueRouter from 'vue-router'\nVue.use(VueRouter)\n\n//AMD规范的异步载入\nconst ComA = resolve => require(['./components/A.vue' ], resolve);\nconst ComB = resolve => require(['./components/B.vue' ], resolve);\nconst ComC = resolve => require(['./components/C.vue' ], resolve);\n\n//CMD风格的异步加载\nconst ComA = resolve => require.ensure([], () => resolve(require('./components/A.vue')));\nconst ComB = resolve => require.ensure([], () => resolve(require('./components/B.vue')));\nconst ComC = resolve => require.ensure([], () => resolve(require('./components/C.vue')));\n\nconst router = new VueRouter({\n  routes: [\n    {\n      name: 'component-A',\n      path: '/a',\n      component: ComA\n    },\n    {\n      name: 'component-B',\n      path: '/b',\n      component: ComB\n    },\n    {\n      name: 'component-C',\n      path: '/c',\n      component: ComC\n    }\n  ]\n})\n\nnew Vue({\n  el: '#app',\n  router: router,\n  render: h => h(App)\n})\n```\n\nvue-cli配置或webpack配置\n\n```js\n//webpack.config.js\noutput: {\n    path: path.resolve(__dirname, './dist'),\n    publicPath: '/dist/',\n    filename: 'build.js',\n    //添加chundkFilename\n    chunkFilename: '[name].[chunkhash:5].chunk.js'\n}\n```\n\n**3）Webpack打包模块工具实现**\n\n在大型项目中, build.js可能过大, 导致页面加载时间过长。这个时候就需要code splitting, code splitting就是将文件分割成块(chunk), 我们可以定义一些分割点(split point), 根据这些分割点对文件进行分块, 并实现按需加载.\n\n\n\n",
          "answer": "",
          "biz_type": 1,
          "qid": 89,
          "subject": "",
          "title": "如何实现按需加载"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["边锋"],
        "date": "Fri, 19 Jun 2020 16:20:40 GMT",
        "favorite_num": 4,
        "qid": 109,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "#### uml图\n\n![uml图示](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-109-uml.png)\n\n#### 代码实现\n\n```js\n// 停车场类\nclass ParkingLot{\n    constructor(n) {\n        // 停车位\n        this.parkSites = []\n        // 剩余停车位个数\n        this.leftSites = n\n        this.board = new DisplayBoard()\n        // 初始化停车位\n        for (let i = 1; i <= n; i++) {\n            this.parkSites.push(new ParkingSpace(i))\n        }\n        console.log('停车场初始化完毕')\n        this.showLeftSites()\n    }\n\n    // 进停车场停车\n    inPark(car) {\n        if (this.leftSites === 0) {\n            console.log('停车位已满')\n            return\n        }\n        if (car.site) {\n            console.log(car.carId + '车辆已经在停车场了')\n            return\n        }\n        let len = this.parkSites.length\n        for (let i = 0; i < len; i++) {\n            const site = this.parkSites[i]\n            // 如果停车位是空的\n            if(site.car === null) {\n                site.car = car\n                car.site = site\n                this.leftSites--\n                console.log(car.carId + '车辆停入' + site.id + '号停车位')\n                this.showLeftSites()\n                return\n            }\n        }\n    }\n\n    // 出停车场\n    outPark (car) {\n        if (car.site === null) {\n            console.log(car.carId + '本来就没在停车场')\n            return;\n        }\n        let len = this.parkSites.length\n        for (let i = 0; i < len; i++) {\n            const site = this.parkSites[i]\n            // 如果停车位是空的\n            if(site.car.carId === car.carId) {\n                site.car = null\n                car.site = null\n                this.leftSites++\n                console.log(car.carId + '车辆已从' + site.id + '号停车位，出停车场')\n                this.showLeftSites()\n                return\n            }\n        }\n    }\n\n    // 显示剩余的停车位数量\n    showLeftSites() {\n        this.board.showLeftSapce(this.leftSites)\n    }\n\n}\n\n\n// 停车位\nclass ParkingSpace {\n    constructor(id) {\n        // 停车位编号\n        this.id = id\n        // 停入的车辆\n        this.car = null\n    }\n}\n\n// 车 类\nclass Car{\n    constructor(carId) {\n        // 车牌号\n        this.carId = carId\n        // 停入的车位\n        this.site = null\n    }\n    // 进入停车场\n    inPark (park) {\n        park.inPark(this)\n    }\n    outPark(park) {\n        park.outPark(this)\n    }\n}\n\n// 展示牌类\nclass DisplayBoard {\n    constructor() {\n    }\n    // 展示剩余停车位\n    showLeftSapce(n) {\n        console.log (`当前剩余${n}个停车位` )\n    }\n}\n\n\nconst park = new ParkingLot(3)\n\nconst car1 = new Car('京A1XXX')\nconst car2 = new Car('京A2XXX')\nconst car3 = new Car('京A3XXX')\nconst car4 = new Car('京A4XXX')\ncar1.inPark(park)\ncar1.inPark(park)\ncar1.outPark(park)\ncar1.outPark(park)\ncar1.inPark(park)\n\ncar2.inPark(park)\ncar3.inPark(park)\ncar4.inPark(park)\n\ncar2.outPark(park)\ncar4.inPark(park)\n\nconsole.log(park.parkSites)\n```",
          "answer": "",
          "biz_type": 1,
          "qid": 109,
          "subject": "```js\n/*\n *题目要求\n *使用面相对象设计一个停车场管理系统，该停车场包含：\n *\t1.停车位，用于停放车辆；\n *\t2.停车位提示牌，用于展示剩余停车位；\n *可以丰富该系统的元素，给出类，类属性，类接口。\n */\n```\n",
          "title": "类设计：使用面相对象设计一个停车场管理系统"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["伴鱼", "喜马拉雅"],
        "date": "Fri, 19 Jun 2020 16:20:40 GMT",
        "favorite_num": 4,
        "qid": 80,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "#### Promise\n\nPromise 对象是 JavaScript 的异步操作解决方案，为异步操作提供统一接口。它起到代理作用（proxy），充当异步操作与回调函数之间的中介，使得异步操作具备同步操作的接口。Promise 可以让异步操作写起来，就像在写同步操作的流程，而不必一层层地嵌套回调函数。\n\n\n#### Promise对象状态\n\nPromise 对象通过自身的状态，来控制异步操作。Promise 实例具有三种状态。\n\n- 异步操作未完成（pending）\n- 异步操作成功（fulfilled）\n- 异步操作失败（rejected）\n\n上面三种状态里面，fulfilled和rejected合在一起称为resolved（已定型）。\n\n这三种的状态的变化途径只有两种。\n\n- 从“未完成”到“成功”\n- 从“未完成”到“失败”\n\n一旦状态发生变化，就凝固了，不会再有新的状态变化。这也是 Promise 这个名字的由来，它的英语意思是“承诺”，一旦承诺成效，就不得再改变了。这也意味着，Promise 实例的状态变化只可能发生一次。\n\n因此，Promise 的最终结果只有两种：\n\n- 异步操作成功，Promise 实例传回一个值（value），状态变为fulfilled\n- 异步操作失败，Promise 实例抛出一个错误（error），状态变为rejected\n\n#### 错误捕获\n\n通过catch捕获到reject之后，在catch后面还可以继续顺序执行then方法，但是只执行then的第一个回调(resolve回调)\n\n```js\nPromise.reject(2)\n    .catch(r => {\n        // 捕获到错误，执行\n        console.log('catch1');\n    })\n    // 错误已经被捕获，后边的`then`都顺序执行，且只执行`then`的第一个回调（resolve的回调）\n    .then(v => {\n        console.log('then1');\n    }, r => {\n        console.log('catch2');\n    })\n    .catch(r => {\n        // 前边没有未捕获的错误，不执行\n        console.log('catch3');\n    })\n    .then(v => {\n        console.log('then2');\n    }, r => {\n        console.log('catch4');\n    });\n```\n结果会打印：catch1、then1、then2",
          "answer": "",
          "biz_type": 1,
          "qid": 80,
          "subject": "",
          "title": "说一说 promise，有几个状态，通过 catch 捕获到 reject 之后，在 catch 后面还能继续执行 then 方法嘛，如果能执行执行的是第几个回调函数"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["快手"],
        "date": "Fri, 19 Jun 2020 16:20:40 GMT",
        "favorite_num": 4,
        "qid": 77,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "#### ios下fixed失效问题\n\n**原因**\n\n软键盘唤起后，页面的 fixed 元素将失效（ios认为用户更希望的是元素随着滚动而移动，也就是变成了 absolute 定位），既然变成了absolute，所以当页面超过一屏且滚动时，失效的 fixed 元素就会跟随滚动了。\n\n不仅限于 type=text 的输入框，凡是软键盘（比如时间日期选择、select 选择等等）被唤起，都会遇到同样地问题。\n\n**解决**\n\n1）既然会变成absolute，索性直接使用absolute\n\nbottom直接以body作为父元素来进行绝对定位，不过这种网上都不推荐，想来有更多的问题等待修正，前人的经验还是要借鉴的。\n\n2）不让页面滚动，而是让主体部分自己滚动\n\n如果fixed的失效，但是页面并没有超过一屏的长度，那么无论absolut或者fixed也没什么差别。顺着这个思路，完全可以让main直接滚着玩就行了。将吸底的元素和主题作为两大容器，主体部分，设置绝对定位，固定在屏幕中间，超出部分就自行滚动，吸底元素就可以自己玩了\n\n```html\n<body>\n    <div class='warper'>\n        <div class='top'></div>\n        <div class='main'></div>\n    <div>\n    <div class=\"fix-bottom\"></div>\n</body>\n```\n\n```css\n.cont-warper{\n    position: absolute;\n    width: 100%;\n    left: 0;\n    right: 0;\n    top: 0;\n    bottom: 0;\n    overflow-y: scroll;\n    /* 解决ios滑动不流畅问题 */\n    -webkit-overflow-scrolling: touch;\n}\n\n.fix-bottom{\n  position:fixed;\n  bottom:0;\n  width: 100%;\n}\n```\n\n这样就能避免上面那个问题了。但是ios下，对于吸底元素而言在屏幕下半部分唤起键盘的时候，会被遮住部分东西，\n\n对于这种情况，我们只好加个监听事件，当唤起键盘的时候，设置scrollTop值\n\n```js\n/**\n * 唤起键盘，滚动\n */\nscrollContent() {\n    this.interval = setInterval(() => {\n        this.scrollToEnd();\n    }, 500)\n}\nscrollToEnd() {\n    document.body.scrollTop = document.body.scrollHeight;\n}\nclearSrcoll() {\n    clearInterval(this.interval);\n}\n```\n\n#### 微信打开网页键盘弹起后页面上滑，导致弹框里的按钮响应区域错位\n\n和上边为题类似，处理方式也是设置scrollTop\n\n**问题**\n\n键盘弹起页面上滑，键盘收起页面不会回到原位置，导致弹框(css设置position为fixed会有问题，absolute不会有问题)后按钮响应区域错位。\n\n**解决**\n\n```js\n//滚动到顶部\nwindow.scrollTo(0, 0);\n//滚动到底部\nwindow.scrollTo(0, document.documentElement.clientHeight);\n```\n\n```js\n//解决键盘弹出bug\n// 判断是否是ios\nif(_.isIOS()){\nwindow.addEventListener('focusout', function(){\n    //软键盘收起的事件处理\n    setTimeout(()=>{\n        window.scrollTo(0 ,document.documentElement.scrollTop || document.body.scrollTop);\n    })\n  });\n}\n```\n\n",
          "answer": "",
          "biz_type": 1,
          "qid": 77,
          "subject": "",
          "title": "iPhone 里面 Safari 上如果一个输入框 fixed 绝对定位在底部，当软键盘弹出的时候会有什么问题，如何解决"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["伴鱼", "腾讯应用宝"],
        "date": "Fri, 19 Jun 2020 16:20:40 GMT",
        "favorite_num": 4,
        "qid": 90,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "#### import原理(实际上就是ES6 module的原理)\n\n1. 简单来说就是闭包的运用\n2. 为了创建Module的内部作用域，会调用一个包装函数\n3. 包装函数的返回值也就是Module向外公开的API，也就是所有export出去的变量\n4. import也就是拿到module导出变量的引用\n\n#### 与require的不同\n\n- CommonJS模块输出的是一个值的拷贝，ES6模块输出的是值的引用\n- CommonJS模块是运行时加载，ES6模块是编译时输出接口\n\nCommonJS是运行时加载对应模块，一旦输出一个值，即使模块内部对其做出改变，也不会影响输出值，如：\n\n```js\n// a.js\nvar a = 1;\nfunction changeA(val) {\n    a = val;\n}\nmodule.exports = {\n    a: a,\n    changeA: changeA,\n}\n\n// b.js\nvar modA = require('./a.js');\nconsole.log('before', modA.a); // 输出1\nmodA.changeA(2);\nconsole.log('after', modA.a); // 还是1\n```\n\n而ES6模块则不同，import导入是在JS引擎对脚步静态分析时确定，获取到的是一个只读引用。等脚本增长运行时，会根据这个引用去对应模块中取值。所以引用对应的值改变时，其导入的值也会变化",
          "answer": "",
          "biz_type": 1,
          "qid": 90,
          "subject": "",
          "title": "讲一下 import 的原理，与 require 有什么不同"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["快手"],
        "date": "Fri, 19 Jun 2020 16:20:40 GMT",
        "favorite_num": 4,
        "qid": 76,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "### 软键盘在Android和IOS苹果上面的表现\n\n#### IOS 软键盘弹起表现\n\n在 IOS 上，输入框（input、textarea 或 富文本）获取焦点，键盘弹起，页面（webview）并没有被压缩，或者说高度（height）没有改变，只是页面（webview）整体往上滚了，且最大滚动高度（scrollTop）为软键盘高度。\n\n#### Android 软键盘弹起表现\n\n在 Android 上，输入框获取焦点，键盘弹起，但是页面（webview）高度会发生改变，一般来说，高度为可视区高度（原高度减去软键盘高度），除了因为页面内容被撑开可以产生滚动，webview 本身不能滚动。\n\n#### IOS 软键盘收起表现\n\n触发软键盘上的“收起”按钮键盘或者输入框以外的页面区域时，输入框失去焦点，软键盘收起。\n\n#### Android 软键盘收起表现\n\n触发软键盘上的“收起”按钮键盘或者输入框以外的页面区域时，输入框失去焦点，软键盘收起。\n\n### 解决两端弹出和收起表现不一致方案\n\n- 在 IOS 上，监听输入框的 focus 事件来获知软键盘弹起，监听输入框的 blur 事件获知软键盘收起。\n- 在 Android 上，监听 webview 高度会变化，高度变小获知软键盘弹起，否则软键盘收起。\n\n```js\n// 判断设备类型\nvar judgeDeviceType = function () {\n  var ua = window.navigator.userAgent.toLocaleLowerCase();\n  var isIOS = /iphone|ipad|ipod/.test(ua);\n  var isAndroid = /android/.test(ua);\n\n  return {\n    isIOS: isIOS,\n    isAndroid: isAndroid\n  }\n}()\n\n// 监听输入框的软键盘弹起和收起事件\nfunction listenKeybord($input) {\n  if (judgeDeviceType.isIOS) {\n    // IOS 键盘弹起：IOS 和 Android 输入框获取焦点键盘弹起\n    $input.addEventListener('focus', function () {\n      console.log('IOS 键盘弹起啦！');\n      // IOS 键盘弹起后操作\n    }, false)\n\n    // IOS 键盘收起：IOS 点击输入框以外区域或点击收起按钮，输入框都会失去焦点，键盘会收起，\n    $input.addEventListener('blur', () => {\n      console.log('IOS 键盘收起啦！');\n      // IOS 键盘收起后操作\n    })\n  }\n\n  // Andriod 键盘收起：Andriod 键盘弹起或收起页面高度会发生变化，以此为依据获知键盘收起\n  if (judgeDeviceType.isAndroid) {\n    var originHeight = document.documentElement.clientHeight || document.body.clientHeight;\n\n    window.addEventListener('resize', function () {\n      var resizeHeight = document.documentElement.clientHeight || document.body.clientHeight;\n      if (originHeight < resizeHeight) {\n        console.log('Android 键盘收起啦！');\n        // Android 键盘收起后操作\n      } else {\n        console.log('Android 键盘弹起啦！');\n        // Android 键盘弹起后操作\n      }\n\n      originHeight = resizeHeight;\n    }, false)\n  }\n}\n\nvar $inputs = document.querySelectorAll('.input');\n\nfor (var i = 0; i < $inputs.length; i++) {\n  listenKeybord($inputs[i]);\n}\n```",
          "answer": "",
          "biz_type": 1,
          "qid": 76,
          "subject": "",
          "title": "移动设备安卓与 iOS 的软键盘弹出的处理方式有什么不同"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["网易", "洋葱学院"],
        "date": "Fri, 19 Jun 2020 16:20:40 GMT",
        "favorite_num": 4,
        "qid": 37,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "### 答案\n\n断点续传的原理在于前端/服务端需要记住已上传的切片，这样下次上传就可以跳过之前已上传的部分，有两种方案实现记忆的功能\n\n1. 前端使用 localStorage 记录已上传的切片 hash\n2. 服务端保存已上传的切片 hash，前端每次上传前向服务端获取已上传的切片\n\n第一种是前端的解决方案，第二种是服务端，而前端方案有一个缺陷，如果换了个浏览器就失去了记忆的效果。\n\n![大文件上传](http://img-static.yidengxuetang.com/wxapp/issue-img/fileupload.png)\n\n#### 一、前端\n\n**1）.前端框架使用Vue+Element UI**\n\n```js\nimport Vue from 'vue'\nimport App from './App.vue'\nimport ElementUI from 'element-ui';\nimport 'element-ui/lib/theme-chalk/index.css';\n\nVue.use(ElementUI);\n\nVue.config.productionTip = false\nnew Vue({\n  render: h => h(App)\n}).$mount('#app')\n\n```\n\n**2）.上传组件**\n\n1. 上传、恢复、暂停暂停按钮\n2. hash计算进度\n3. 上传文件总进度\n\n```js\n<template>\n  <div id=\"app\">\n    <div>\n      <input\n        type=\"file\"\n        :disabled=\"status !== Status.wait\"\n        @change=\"handleFileChange\"\n      />\n      <el-button @click=\"handleUpload\" :disabled=\"uploadDisabled\"\n        >上传</el-button\n      >\n      <el-button @click=\"handleResume\" v-if=\"status === Status.pause\"\n        >恢复</el-button\n      >\n      <el-button\n        v-else\n        :disabled=\"status !== Status.uploading || !container.hash\"\n        @click=\"handlePause\"\n        >暂停</el-button\n      >\n    </div>\n    <div>\n      <div>计算文件 hash</div>\n      <el-progress :percentage=\"hashPercentage\"></el-progress>\n      <div>总进度</div>\n      <el-progress :percentage=\"fakeUploadPercentage\"></el-progress>\n    </div>\n    <el-table :data=\"data\">\n      <el-table-column\n        prop=\"hash\"\n        label=\"切片hash\"\n        align=\"center\"\n      ></el-table-column>\n      <el-table-column label=\"大小(KB)\" align=\"center\" width=\"120\">\n        <template v-slot=\"{ row }\">\n          {{ row.size | transformByte }}\n        </template>\n      </el-table-column>\n      <el-table-column label=\"进度\" align=\"center\">\n        <template v-slot=\"{ row }\">\n          <el-progress\n            :percentage=\"row.percentage\"\n            color=\"#909399\"\n          ></el-progress>\n        </template>\n      </el-table-column>\n    </el-table>\n  </div>\n</template>\n```\n\n**3）文件上传和断点续传逻辑**\n\n1. 核心是`Blob.prototype.slice` 方法，将源文件切成多个切片\n2. 根据切片内容生成hash，此处用到的是spark-md5.js，因为解析切片内容比较耗时，所以开辟了WebWorker线程来处理hash的生成，在处理切片hash的时候，还与主线程进行通信返回进度。\n3. 向服务器发请求，检验文件切片是否上传,返回是否需要继续上传和已上传列表（断点续传核心）。\n4. 利用http 的可并发性，同时上传多个切片，减少上传时间\n5. 切片上传完成，给服务器发送合并切片请求\n\n- 常量和基础属性\n\n```js\n\n //单个切片大小\nconst SIZE = 10*1024*1024;//10MB\n//状态常量\nconst Status = {\n  wait: \"wait\",\n  pause: \"pause\",\n  uploading: \"uploading\"\n};\nexport default {\n   name: \"App\",\n   filters: {\n    transformByte(val) {\n      return Number((val / 1024).toFixed(0));\n    }\n  },\n    data() {\n    return {\n      Status,\n      container: { //保存文件信息\n        file: null,\n        hash: \"\",//所有切片hash\n        worker: null\n      },\n      hashPercentage:0,//hash进度百分比\n      data: [],//保存所有切片信息\n      requestList: [],//请求列表\n      status: Status.wait,//状态，默认为等待\n      fakeUploadPercentage: 0//文件上传总进度\n    };\n  },\n}\n\n```\n\n- 计算属性、watch\n\n```js\ncomputed: {\n  //上传按钮不可用\n    uploadDisabled() {\n      return (\n        !this.container.file ||\n        [Status.pause, Status.uploading].includes(this.status)\n      );\n    },\n      //下载进度百分比\n    uploadPercentage() {\n      if (!this.container.file || !this.data.length) return 0;\n      const loaded = this.data\n        .map(item => item.size * item.percentage)\n        .reduce((acc, cur) => acc + cur);\n      return parseInt((loaded / this.container.file.size).toFixed(2));\n    }\n  },\n  watch: {\n    //下载进度百分比\n    uploadPercentage(now) {\n      if (now > this.fakeUploadPercentage) {\n        this.fakeUploadPercentage = now;\n      }\n    }\n  },\n```\n\n- methods：三个按钮上面的方法定义\n\n```js\nmethods: {\n  //中止处理函数\n    handlePause() {\n      this.status = Status.pause;\n      this.resetData();\n    },\n    resetData() {\n      //中止请求列表中的所有请求\n      this.requestList.forEach(xhr => {\n        if (xhr) {\n          xhr.abort();\n        }\n      });\n      this.requestList = [];\n      if (this.container.worker) {\n        this.container.worker.onmessage = null;\n      }\n    },\n     //恢复处理函数\n    async handleResume() {\n      this.status = Status.uploading;\n      //获取已经上传的文件名和hash\n      const { uploadedList } = await this.verifyUpload(\n        this.container.file.name,\n        this.container.hash\n      );\n      await this.uploadChunks(unloadedList);\n    },\n    //file input change事件触发\n    handleFileChange(e){\n      const [file] = e.target.files;\n      if(!file) return;\n      this.resetData();\n      Object.assign(this.$data,this.$options.data());\n      this.container.file = file;\n    }\n}\n```\n\n- 核心：文件上传逻辑  **切片=>hash=>校验=>批量上传**\n\n```js\nasync handleUpload(){\n      if(!this.container.file) return;\n      this.status = Status.uploading;\n      //生成文件切片\n      const fileChunkList = this.createFileChunk(this.container.file);\n      //根据切片列表计算切片hash\n      this.container.hash = await this.calculateHash(fileChunkList);\n      //检验文件切片是否上传,返回是否需要上传和已上传列表\n      const { shouldUpload,uploadedList } = await this.verifyUpload(\n        this.container.file.name,\n        this.container.hash\n      );\n      //没有需要上传的文件切片\n      if(!shouldUpload){\n        this.$message.sucess('秒传：上传成功');\n        this.status = Status.wait;\n        return;\n      }\n      //根据文件列表生成每个切片的信息对象\n      this.data = fileChunkList.map(({file},index)=>({\n        fileHash : this.container.hash,\n        index,\n        hash: this.container.hash + '-'+index,\n        chunk:file,\n        size:file.size,\n        percentage:uploadedList.includes(index)?100:0\n      }));\n      //上传文件切片\n      await this.uploadChunks(uploadedList);\n    },\n```\n\n- 文件核心逻辑实现：生成文件切片：file.slice()\n\n```js\n// 生成文件切片 file.slice\ncreateFileChunk(file, size = SIZE) {\n  const fileChunkList = [];\n  let cur = 0;\n  while (cur < file.size) {\n    fileChunkList.push({ file: file.slice(cur, cur + size) });\n    cur += size;\n  }\n  return fileChunkList;\n},\n```\n\n- 生成文件切片hash: webworker\n\n```js\n// 生成文件 hash（web-worker）\ncalculateHash(fileChunkList) {\n  return new Promise(resolve => {\n    this.container.worker = new Worker(\"/hash.js\");\n    //与worker通信\n    this.container.worker.postMessage({ fileChunkList });\n    this.container.worker.onmessage = e => {\n      const { percentage, hash } = e.data;\n      this.hashPercentage = percentage;\n      //返回总文件生成hash进度的百分比，如果切片hash全部生成，返回所有切片hash组成的对象\n      if (hash) {\n        resolve(hash);\n      }\n    };\n  });\n},\n```\n\n- hash.js：边计算边与主线程进行通信，返回hash计算进度\n\n```js\nself.importScripts(\"/spark-md5.min.js\"); // 导入脚本\n\n// 生成文件 hash\nself.onmessage = e => {\n  const { fileChunkList } = e.data;\n  const spark = new self.SparkMD5.ArrayBuffer();\n  let percentage = 0;\n  let count = 0;\n  const loadNext = index => {\n    const reader = new FileReader();//异步读取文件，在webworker中使用\n    reader.readAsArrayBuffer(fileChunkList[index].file);//读取文件完成后，属性result保存着二进制数据对象\n    //文件读取完成后触发\n    reader.onload = e => {\n      //递归计数器\n      count++;\n      spark.append(e.target.result);//append ArrayBuffer数据\n      if (count === fileChunkList.length) {\n        self.postMessage({\n          percentage: 100,\n          hash: spark.end()//完成hash\n        });\n        self.close();//关闭 Worker 线程。\n      } else {\n        percentage += 100 / fileChunkList.length;\n        self.postMessage({\n          percentage\n        });\n        loadNext(count);//递归继续\n      }\n    };\n  };\n  loadNext(0);\n};\n```\n\n- 断点续传核心：**文件切片完成之后，向服务器发请求检验文件切片是否已经上传**\n\n```js\n async verifyUpload(filename,fileHash){\n      const { data } = await this.request({\n        url:'http://localhost:3000/verify',//验证接口\n        headers:{\n          'content-type':'application/json'\n        },\n        data:JSON.stringify({\n          filename,\n          fileHash\n        })\n      })\n      //返回数据\n      return JSON.parse(data);\n    },\n```\n\n- 上传文件切片：**过滤已经上传的文件+Promise.all并发请求**\n\n```js\n//上传文件切片，同时过滤已经上传的切片\n    async uploadChunks(uploadedList = []){\n      const requestList = this.data\n        .filter(({hash})=>!uploadedList.includes(hash)) //过滤已经上传的chunks\n        .map(({chunk,hash,index})=>{\n          const formData = new FormData();\n          formData.append('chunk',chunk);\n          formData.append('hash',hash);\n          formData.append(\"filename\", this.container.file.name);\n          formData.append(\"fileHash\", this.container.hash);\n          return { formData,index }\n        })//创建表单数据\n        .map(async ({formData,index})=>\n          this.request({\n            url:'http://localhost:3000',\n            data:formData,\n            onProgress : this.createProgressHandler(this.data[index]),\n            requestList:this.requestList//将xhr push到请求列表\n          })\n        )//创建请求列表\n        //并发上传\n        await Promise.all(requestList);\n        //已经上传切片数量+本次上传切片数量==所有切片数量时 \n        //切片上传完成，给服务器发送合并切片请求\n        if(uploadedList.length + requestList.length === this.data.length){\n          await this.mergeRequest();\n        } \n    }\n```\n\n- 合并切片：服务端发送请求\n\n```js\n// 通知服务端合并切片\n    async mergeRequest() {\n      await this.request({\n        url: \"http://localhost:3000/merge\",\n        headers: {\n          \"content-type\": \"application/json\"\n        },\n        data: JSON.stringify({\n          size: SIZE,\n          fileHash: this.container.hash,\n          filename: this.container.file.name\n        })\n      });\n      this.$message.success(\"上传成功\");\n      this.status = Status.wait;\n    },\n```\n\n- **用原生xhr进行封装http请求**\n\n```js\n// xhr\n    request({\n      url,\n      method = \"post\",\n      data,\n      headers = {},\n      onProgress = e => e,\n      requestList\n    }) {\n      return new Promise(resolve => {\n        const xhr = new XMLHttpRequest();\n        xhr.upload.onprogress = onProgress;\n        xhr.open(method, url);\n        Object.keys(headers).forEach(key =>\n          xhr.setRequestHeader(key, headers[key])\n        );\n        xhr.send(data);\n        xhr.onload = e => {\n          // 将请求成功的 xhr 从列表中删除\n          if (requestList) {\n            const xhrIndex = requestList.findIndex(item => item === xhr);\n            requestList.splice(xhrIndex, 1);\n          }\n          resolve({\n            data: e.target.response\n          });\n        };\n        // 暴露当前 xhr 给外部\n        requestList?.push(xhr);\n      });\n    }\n```\n\n#### 二、服务端\n\n**1）开启服务：未使用node框架，原生利用http模块**\n\n```js\nconst Controller = require(\"./controller\");\nconst http = require(\"http\");\nconst server = http.createServer();\n\nconst controller = new Controller();\n\nserver.on(\"request\", async (req, res) => {\n  //设置响应头，允许跨域\n  res.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n  res.setHeader(\"Access-Control-Allow-Headers\", \"*\");\n  if (req.method === \"OPTIONS\") {\n    res.status = 200;\n    res.end();\n    return;\n  }\n  //切片验证\n  if (req.url === \"/verify\") {\n    console.log(req);\n    await controller.handleVerifyUpload(req, res);\n    return;\n  }\n//切片合并\n  if (req.url === \"/merge\") {\n    await controller.handleMerge(req, res);\n    return;\n  }\n//切片提交\n  if (req.url === \"/\") {\n    await controller.handleFormData(req, res);\n  }\n});\n\nserver.listen(3000, () => console.log(\"正在监听 3000 端口\"));\n```\n\n**2）controller.js**\n\n合并切片的方式：**使用stream pipe方式，节省内存，边读边写入，占用内存更小，效率更高**\n\n```js\nconst multiparty = require(\"multiparty\");//解析文件上传\nconst path = require(\"path\");\nconst fse = require(\"fs-extra\");//fs模块拓展\n\nconst extractExt = filename =>\nfilename&&filename.slice(filename.lastIndexOf(\".\"), filename.length); // 提取后缀名\nconst UPLOAD_DIR = path.resolve(__dirname, \"..\", \"target\"); // 大文件存储目录\n\n//使用stream pipe方式，合并切片\nconst pipeStream = (path, writeStream) =>\n  new Promise(resolve => {\n    const readStream = fse.createReadStream(path);\n    readStream.on(\"end\", () => {\n      fse.unlinkSync(path);\n      resolve();\n    });\n    readStream.pipe(writeStream);\n  });\n\n// 合并切片\nconst mergeFileChunk = async (filePath, fileHash, size) => {\n  const chunkDir = path.resolve(UPLOAD_DIR, fileHash);\n  const chunkPaths = await fse.readdir(chunkDir);\n  // 根据切片下标进行排序\n  // 否则直接读取目录的获得的顺序可能会错乱\n  chunkPaths.sort((a, b) => a.split(\"-\")[1] - b.split(\"-\")[1]);\n  await Promise.all(\n    chunkPaths.map((chunkPath, index) =>\n      pipeStream(\n        path.resolve(chunkDir, chunkPath),\n        // 指定位置创建可写流\n        fse.createWriteStream(filePath, {\n          start: index * size,\n          end: (index + 1) * size\n        })\n      )\n    )\n  );\n  fse.rmdirSync(chunkDir); // 合并后删除保存切片的目录\n};\n\nconst resolvePost = req =>\n  new Promise(resolve => {\n    let chunk = \"\";\n    req.on(\"data\", data => {\n      chunk += data;\n    });\n    req.on(\"end\", () => {\n      resolve(JSON.parse(chunk));\n    });\n  });\n\n// 返回已经上传切片名\nconst createUploadedList = async fileHash =>\n  fse.existsSync(path.resolve(UPLOAD_DIR, fileHash))\n    ? await fse.readdir(path.resolve(UPLOAD_DIR, fileHash))\n    : [];\n\nmodule.exports = class {\n  // 合并切片\n  async handleMerge(req, res) {\n    const data = await resolvePost(req);\n    const { fileHash, filename, size } = data;\n    const ext = extractExt(filename);\n    const filePath = path.resolve(UPLOAD_DIR, `${fileHash}${ext}`);\n    await mergeFileChunk(filePath, fileHash, size);\n    res.end(\n      JSON.stringify({\n        code: 0,\n        message: \"file merged success\"\n      })\n    );\n  }\n  // 处理切片\n  async handleFormData(req, res) {\n    const multipart = new multiparty.Form();\n    multipart.parse(req, async (err, fields, files) => {\n      if (err) {\n        console.error(err);\n        res.status = 500;\n        res.end(\"process file chunk failed\");\n        return;\n      }\n      const [chunk] = files.chunk;\n      const [hash] = fields.hash;\n      const [fileHash] = fields.fileHash;\n      const [filename] = fields.filename;\n      const filePath = path.resolve(\n        UPLOAD_DIR,\n        `${fileHash}${extractExt(filename)}`\n      );\n      const chunkDir = path.resolve(UPLOAD_DIR, fileHash);\n\n      // 文件存在直接返回\n      if (fse.existsSync(filePath)) {\n        res.end(\"file exist\");\n        return;\n      }\n\n      // 切片目录不存在，创建切片目录\n      if (!fse.existsSync(chunkDir)) {\n        await fse.mkdirs(chunkDir);\n      }\n      await fse.move(chunk.path, path.resolve(chunkDir, hash));\n      res.end(\"received file chunk\");\n    });\n  }\n  // 验证是否已上传/返回已上传切片下标\n  async handleVerifyUpload(req, res) {\n    const data = await resolvePost(req);\n    console.log(data);\n    const { fileHash, filename } = data;\n    const ext = extractExt(filename);\n    const filePath = path.resolve(UPLOAD_DIR, `${fileHash}${ext}`);\n    if (fse.existsSync(filePath)) {\n      res.end(\n        JSON.stringify({\n          shouldUpload: false\n        })\n      );\n    } else {\n      res.end(\n        JSON.stringify({\n          shouldUpload: true,\n          uploadedList: await createUploadedList(fileHash)\n        })\n      );\n    }\n  }\n};\n```\n",
          "answer": "",
          "biz_type": 1,
          "qid": 37,
          "subject": "",
          "title": "文件上传如何做断点续传"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [],
        "date": "Fri, 19 Jun 2020 16:20:40 GMT",
        "favorite_num": 4,
        "qid": 41,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "### 答案\n\n```js\nfunction checkHtml (data) {\n  let tag = ['a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base', 'bdi', 'bdo', 'blockquote', 'body', 'button', 'canvas', 'caption', 'cite', 'code', 'col', 'colgroup', 'datalist', 'dd', 'del', 'dfn', 'dialog', 'div', 'dl', 'dt', 'em', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'head', 'header', 'hgroup', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'i', 'iframe', 'ins', 'label', 'legend', 'li', 'map', 'mark', 'menu', 'meter', 'nav', 'noscript', 'object', 'ol', 'outgroup', 'option', 'output', 'p', 'pre', 'html', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'script', 'section', 'select', 'small', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'u', 'ul', 'var', 'video', 'wbr']\n  //清除标签中内容、换行符\n  data = data.replace(/.*?(<.*>).*/g, '$1').replace(/[\\r\\n]/g, '').replace(/\\s+.*?>/g, '>')\n  //排除无内容元素\n  data = data.replace(/<(img|br|hr|input|link|meta|area|base|col|command|embed|keygen|param|source|track|wbr).*?>/g, '')\n  //清除非标签元素，替换标签为()的形式，例如：<div>替换为(、</div>替换为)\n  data = data.replace(/>.*?</g, '><').replace(/<[^\\/].*?>/g, '(').replace(/<\\/.*?[^<]>/g, ')')\n  //判断()是否为偶数\n  if (data.length % 2 != 0) {\n    return false\n  }\n  //循环删除()直至没有()或者为空\n  while (data.length) {\n    let temp = data\n    let i = 0\n    while (i < tag.length) {\n      let key = '<' + tag[i] + '></' + tag[i] + '>'\n      data = data.replace(new RegExp(key, 'g'), '')\n      i++\n    }\n    if (data == temp) {\n      return false\n    }\n  }\n  return true\n}\n\ncheckHtml(\"<div></div>\") // true\ncheckHtml(\"<div>\") // false\ncheckHtml(\"<br>\") // true\ncheckHtml(\"</img>\") // false\ncheckHtml(\"<img/>\") // true\ncheckHtml(\"<img>\") // true\n```\n",
          "answer": "",
          "biz_type": 1,
          "qid": 41,
          "subject": "",
          "title": "实现一个方法判断 html 中的标签是否闭合"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["酷家乐"],
        "date": "Fri, 19 Jun 2020 16:20:40 GMT",
        "favorite_num": 4,
        "qid": 46,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "### 答案\n\n1. 箭头函数没有自己的 this,只能通过作用域链来向上查找离自己最近的那个函数的 this\n2. 箭头函数不能作为 constructor，因此不能通过 new 来调用，所以他并没有`new.target`这个属性\n3. 箭头函数没有 argument 属性 ,可以通过 rest 可以获取\n4. 箭头函数不能直接使用 call 和 apply，bind 来改变 this\n5. 箭头函数不能使用 yield,不能用来做为 generator 函数\n6. 箭头函数语法比普通函数更加简洁\n\n> ES6 为 new 命令引入了一个 new.target 属性，该属性一般用在构造函数之中，返回 new 命令作用于的那个构造函数。如果构造函数不是通过 new 命令或 Reflect.construct()调用的，new.target 会返回 undefined，因此这个属性可以用来确定构造函数是怎么调用的）。包括 super 也不存在以及原型 prototype=>因为在执行 new 的时候需要将函数的原型赋值给实例对象的原型属性。\n",
          "answer": "",
          "biz_type": 1,
          "qid": 46,
          "subject": "",
          "title": "箭头函数和普通函数的区别"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["滴滴", "快手", "携程"],
        "date": "Fri, 19 Jun 2020 16:20:40 GMT",
        "favorite_num": 4,
        "qid": 31,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "### 答案\n\n**1）方式一**\n\n```js\nfunction flatten(arr){\n const stack = [...arr];\n const res = [];\n while (stack.length) {\n  const next = stack.pop();\n  if(Array.isArray(next)){\n   stack.push(...next);\n  }else{\n   res.push(next);\n  }\n }\n return res.reverse();\n}\n```\n\n**2）方式二**\n\n```js\n//flatten(arr,[depth]),depth指定展开嵌套数组的深度,默认为1\nfunction flatten(arr, depth = 1){\n if(depth > 0){\n  return arr.reduce((acc, val) => acc.concat(Array.isArray(val) ? flattenArray(val, depth - 1) : val), []);\n } else {\n  return arr.slice();\n }\n}\n```\n\n**3）方式三**\n\n```js\n// 未排除null项\nvar arr = [1, 2, [3, 4, 5, [6, 7, 8, [9, , 0]]]]\nArray.prototype.flat = function (deep = 1) {\n    const source = this\n    return deep > 0 ?\n        source.reduce(\n            (res, val) => val === null ? \"\" : res.concat(\n                Array.isArray(val) ? val.flat(deep - 1) : val)\n            , [])\n        : source.slice();\n\n}\nconsole.log(arr.flat(3))\n```\n\n**4）方式四**\n\n```js\n// 使用forEach 自动过滤空项\nvar arr = [1, 2, [3, 4, 5, [6, 7, 8, [9, , 0]]]]\nArray.prototype.flat = function (deep = 1) {\n    let result = []\n    function ergodic(array, deep) {\n        array.forEach(element => {\n            Array.isArray(element) && deep > 0 ? ergodic(element, deep - 1) : result.push(element)\n        });\n    }\n    ergodic(this, deep)\n    return result\n}\nconsole.log(arr.flat(3))\n```\n",
          "answer": "",
          "biz_type": 1,
          "qid": 31,
          "subject": "",
          "title": "手写实现 Array.flat()"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["顺丰", "新东方", "高德", "虎扑", "微医", "百分点", "酷狗", "新东方"],
        "date": "Fri, 19 Jun 2020 16:20:40 GMT",
        "favorite_num": 4,
        "qid": 40,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "### 答案\n\n#### 1.浅拷贝\n\n对于字符串类型，浅拷贝是对值的复制，对于对象来说，浅拷贝是对对象地址的复制, 举个例子，A,B两个对象，A=B，改变A的属性，B也相对会发生改变。因为A,B指向同一个地址。\n\n#### 2.深拷贝\n\n深拷贝开辟一个新的栈，两个对象对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性\n\n#### 3.代码实现深拷贝\n\n**1）方式一-JSON.parse(JSON.stringfy(source))**\n\n利用现代浏览器支持的JSON对象做一次中转，实现深度克隆\n\n优点：简单便捷\n\n缺点：\n\n- undefined、函数、symble值，在序列化过程中会被忽略\n- 不能处理 BigInt 类型的数据和循环引用，会报错\n- Map, Set, RegExp 类型的数据，会引用丢失，变成空值\n- Date 类型的数据会被当做字符串处理\n- NaN 和 Infinity 格式的数值及 null 都会被当做 null。\n- 其他类型的对象，包括 Map/Set/WeakMap/WeakSet，仅会序列化可枚举的属性\n\n```js\nfunction deepClone(obj) {\n  var _tmp,result;\n  _tmp = JSON.stringify(obj);\n  result = JSON.parse(_tmp);\n  return result;\n}\n```\n\n**2）方式二-确定参数类型为object**\n\n确定参数类型为object （这里仅指object literal、Array literal）后，复制源对象的键/值到目标对象，否则直接返回源对象。\n\n```js\nfunction deepClone(obj){\n    var result = typeof obj.splice === 'function'?[]:{},\n    key;\n    if (obj && typeof obj === 'object'){\n        for (key in obj ){\n            if (obj[key] && typeof obj[key] === 'object'){\n                result[key] = deepClone(obj[key]);//如果对象的属性值为object的时候，递归调用deepClone，即再把某个值对象复制一份到新的对象的对应值中\n            }else{\n                result[key] = obj[key];//如果对象的属性值不为object的时候，直接复制参数对象的每一个键/值到新对象对应的键/值中\n            }\n        }\n        return result;\n    }\n    return obj;\n}\n```\n\n**3）方式三-Reflect代理法**\n\n```js\nfunction deepClone(obj) {\n    if (!isObject(obj)) {\n        throw new Error('obj 不是一个对象！')\n    }\n    let isArray = Array.isArray(obj)\n    let cloneObj = isArray ? [...obj] : { ...obj }\n    Reflect.ownKeys(cloneObj).forEach(key => {\n        cloneObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key]\n    })\n    return cloneObj\n}\n```\n\n**4）方式四-终极版**\n\n> 循环引用的问题，即obj.x = obj\n> 用一个weakMap<原对象引用,新对象引用>保存已经创建的对象，如果再下次递归中如果当前等于原对象引用，那么直接返回新创建对象的引用\n\n```js\nfunction isObject(obj) {\n    return (typeof obj === 'object' || typeof obj === 'function') && obj !== null\n}\nfunction isFunc(obj) {\n    return typeof obj === 'function'\n}\nfunction isArray(obj) {\n    return Array.isArray(obj)\n}\nfunction isDate(obj) {\n    return Object.prototype.toString.call(obj) === '[object Date]'\n}\nfunction isMap(obj) {\n    return Object.prototype.toString.call(obj) === '[object Map]'\n}\nfunction isSet(obj) {\n    return Object.prototype.toString.call(obj) === '[object Set]'\n}\nfunction isRegExp(obj) {\n    return Object.prototype.toString.call(obj) === '[object RegExp]'\n}\n\nfunction deepCopy(obj,weakMap = new WeakMap()) {\n    if (!isObject(obj)) return obj\n    if (weakMap.get(obj)) return weakMap.get(obj)\n    // 如果是函数\n    if (isFunc(obj)) {\n        let result = null\n        // 获得函数的主体\n        const bodyReg = /(?<={)(.|\\n)+(?=})/m;\n        // 获得参数\n        const paramReg = /(?<=\\().+(?=\\)\\s+{)/;\n        const funcString = obj.toString();\n        // 判断是否是箭头函数\n        if (obj.prototype) {\n            const param = paramReg.exec(funcString);\n            const body = bodyReg.exec(funcString);\n            if (body) {\n                if (param) {\n                    const paramArr = param[0].split(',');\n                    result = new Function(...paramArr, body[0]);\n                } else {\n                    result = new Function(body[0]);\n                }\n            }\n        } else {\n            result = eval(funcString);\n        }\n        weakMap.set(obj,result)\n        return result\n    }\n\n    // 如果是数组\n    if (Array.isArray(obj)) {\n        let result = []\n        for (let val of obj) {\n            result.push(deepCopy(val, weakMap))\n        }\n        weakMap.set(obj,result)\n        return result\n    }\n    // 如果是Date\n    if (isDate(obj)) {\n        let result = new obj.constructor(obj)\n        weakMap.set(obj,result)\n        return result\n    }\n    // 如果是map\n    if (isSet(obj)) {\n        let result = new Set()\n        obj.forEach((val)=> {\n            result.add(deepCopy(val, weakMap))\n        })\n        weakMap.set(obj,result)\n        return result\n    }\n    // 如果是set\n    if (isMap(obj)) {\n        let result = new Map()\n        obj.forEach((val, key) => {\n            result.set(key, deepCopy(key, weakMap))\n        })\n        weakMap.set(obj,result)\n        return result\n    }\n    // 如果是正则\n    if (isRegExp(obj)) {\n        const reFlags = /\\w*$/;\n        const result = new obj.constructor(obj.source, reFlags.exec(obj));\n        result.lastIndex = obj.lastIndex;\n        weakMap.set(obj,result)\n        return result;\n    }\n    let result = {}\n    weakMap.set(obj,result)\n    // 考虑symbol类型的属性名\n    let symbols = Object.getOwnPropertySymbols(obj)\n    if(symbols.length > 0) {\n        for(let key of symbols) {\n            let val = obj[key]\n            result[key] = isObject(val) ? deepCopy(val, weakMap) : val\n        }\n    }\n    // 非symbol类型属性名\n    for (let key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            let val = obj[key]\n            result[key] = isObject(val) ? deepCopy(val, weakMap) : val\n        }\n    }\n    return result\n}\n\nvar map = new Map()\nmap.set(1,1)\nmap.set(2,2)\nvar obj = {\n    a: 1,\n    b: '1',\n    c: Symbol(),\n    d: undefined,\n    e: null,\n    f: true,\n    g: {\n        g1: 1,\n        g2: '2',\n        g3: undefined\n    },\n    [Symbol()]: 'symbol',\n    h: function (a) {\n        console.log(a)\n    },\n    i: [1,2,3],\n    j: new Date(),\n    k: new Set([1,2,3,4]),\n    l: map,\n    m: /\\w*$/g,\n}\nobj.x = obj.i\n\nvar deepObj = deepCopy(obj)\nconsole.log(deepObj.x === deepObj.i) // true\nconsole.log(deepObj)\n```\n",
          "answer": "",
          "biz_type": 1,
          "qid": 40,
          "subject": "",
          "title": "什么是深拷贝，和浅拷贝有什么区别，动手实现一个深拷贝"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["头条"],
        "date": "Fri, 19 Jun 2020 16:20:40 GMT",
        "favorite_num": 4,
        "qid": 62,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "### 代码实现\n\n`Number.isInteger()` 方法用来判断给定的参数是否为整数\n\n**1）代码实现一**\n\n- `isFinite` 方法检测它参数的数值。如果参数是 NaN，Infinity或者-Infinity，会返回false，其他返回 true。\n- `Number.isInteger(Infinity) === false`, 而`typeof Infinity` 和 `Math.floor(Infinity)`得到的均为true\n- 取整：`Math.floor`、`Math.ceil`、`Math.round`均可\n\n```js\nNumber.isInteger = function(value) {\n    return typeof value === \"number\" && \n           isFinite(value) && \n           Math.floor(value) === value;\n};\n```\n\n**2）代码实现二**\n\n- 异或运算\n\n```js\nfunction isInteger(x) {\n  return typeof value === \"number\" && \n           isFinite(value) && x ^ 0 === x\n}\n```\n\n**3）代码实现三**\n\n- 取余\n\n```js\nfunction isInteger(x) {\n  return typeof value === \"number\" && \n           isFinite(value)  && (x % 1 === 0)\n}\n```\n\n",
          "answer": "",
          "biz_type": 1,
          "qid": 62,
          "subject": "",
          "title": "es5 实现 isInteger"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["快手"],
        "date": "Fri, 19 Jun 2020 16:20:40 GMT",
        "favorite_num": 4,
        "qid": 79,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "### 代码实现\n\n**1）暴力双重循环**\n\n```js\nfunction findMaxRight(array) {\n    let result = []\n    for (let i = 0; i < array.length - 1; i++) {\n        for (let j = i + 1; j < array.length; j++) {\n            if (array[j] > array[i]) {\n                result[i] = array[j]\n                break\n            } else {\n                result[i] = -1\n            }\n        }\n    }\n    result[result.length] = -1\n    return result\n}\n```\n\n**2）利用栈的特性**\n\n```js\nfunction findMaxRightWithStack(array) {\n    const size = array.length\n    let indexArr = [0]\n    let result = []\n    let index = 1\n    while (index < size) {\n        if (indexArr.length > 0 && array[indexArr[indexArr.length - 1]] < array[index]) {\n            result[indexArr[indexArr.length - 1]] = array[index]\n            indexArr.pop()\n        } else {\n            indexArr.push(index)\n            index++\n        }\n    }\n    indexArr.forEach((item) => {\n        result[item] = -1\n    })\n    return result\n}\n```\n\n**3）单调递减栈, 反向遍历**\n\n```js\nconst firstBiggerItem = (T) => {\n    const res = new Array(T.length).fill(-1);\n    const stack = [];\n    for (let i = T.length - 1; i >= 0; i--) {\n        while (stack.length && T[i] >= T[stack[stack.length - 1]]) {\n        stack.pop();\n        }\n        if (stack.length && T[i] < T[stack[stack.length - 1]]) {\n        res[i] = T[stack[stack.length - 1]];\n        }\n        stack.push(i);\n    }\n    return res;\n};\n// test\nvar T = [2, 6, 3, 8, 10, 9];\nconsole.log(firstBiggerItem(T));\n```\n\n",
          "answer": "",
          "biz_type": 1,
          "qid": 79,
          "subject": "```js\n/*\n *示例：\n *给定数组：[2,6,3,8,10,9]\n *返回数组：[6,8,8,10,-1,-1]\n */\n```\n",
          "title": "给定一个数组，按找到每个元素右侧第一个比它大的数字，没有的话返回-1 规则返回一个数组"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["伴鱼"],
        "date": "Fri, 19 Jun 2020 16:20:40 GMT",
        "favorite_num": 4,
        "qid": 82,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "### 一、常用的垃圾回收机制\n\n#### 1）引用计数法 reference counting\n\n1. 跟踪记录每个值被引用的次数\n2. 当声明变量并将一个引用类型的值赋值给该变量时，则这个值的引用次数加1，\n3. 同一值被赋予另一个变量，该值的引用计数加1 。\n4. 当引用该值的变量被另一个值所取代，则引用计数减1，\n5. 当计数为 0 的时候，说明无法在访问这个值了，系统将会收回该值所占用的内存空间。\n6. 缺点：循环引用的时候，引用次数不为0，不会被释放；\n\n#### 2）标记清除法 mark-sweep\n\n给存储在内存中的变量都加上标记，判断哪些变量没有在执行环境中引用，进行删除；\n\n#### 3）停止复制 stop-copy\n\n内存分为两块，正在使用的存活对象复制到未被使用的内存块中，清除正在使用的内存块中的所有对象，然后交换两个内存的角色\n\n#### 4）标记压缩 mark-compact\n\n所有可达对象做一次标记，所有存活对象压缩到内存的一端，减少内存碎片\n\n#### 5）增量算法 incremental collecting\n\n每次GC线程只收集一小片内存空间，接着切换到应用程序线程，依次反复，直到垃圾收集完成\n\n### 二、堆、栈的数据的GC\n\njs的内存空间有 调用栈 stack 和堆空间 heap\n\n#### 1）调用栈中的数据的GC\n\n调用栈有一个记录当前执行状态的指针（称为 ESP），JS引擎通过下移ESP指针来销毁栈顶某个执行上下文，释放栈空间\n\n#### 2）堆空间中数据的GC\n\n**分代收集：** 新生代、老生代\n\n提高垃圾回收的效率，V8将堆分为新生代和老生代两个部分：\n\n- 其中新生代为存活时间较短的对象(需要经常进行垃圾回收)，内存占用小，GC频繁；只支持1-8M容量；使用副垃圾回收器；\n- 而老生代为存活时间较长的对象(垃圾回收的频率较低)，内存占用多，GC不频繁；使用主垃圾回收器；\n\n**新生代的GC算法**\n\n新生代的对象通过 Scavenge 算法进行GC。在 Scavenge 的具体实现中，主要采用了 Cheney 算法。\n\n1. Cheney 算法是一种采用停止复制（stop-copy）的方式实现的垃圾回收算法。\n2. 它将堆内存一分为二，每一部分空间成为 semispace-半空间。\n3. 在这两个 semispace 空间中，只有一个处于使用中，另一个处于闲置中。\n4. 处于使用中的 semispace 空间成为 From 对象空间，处于闲置状态的空间成为 To 空闲空间。\n5. 当我们分配对象时，先是在 From 空间中进行分配。当开始进行垃圾回收时，会检查 From 空间中的存活对象，这些存活对象将被复制到 To 空间中，同时还会将这些对象有序的排列起来~~相当于内存整理，所以没有内存碎片，而非存活对象占用的空间将被释放。\n完成复制后，From空间和To空间的角色发生对换。\n6. Scavenge 是典型的空间换取时间的算法，而且复制需要时间成本，无法大规模地应用到所有的垃圾回收中，但非常适合应用在新生代中进行快速频繁清理。\n\n**对象晋升策略**\n\n对象从新生代中移动到老生代中的过程称为晋升。\n\n晋升条件主要有两个：\n\n- 对象是否经历过两次 Scavenge 回收都未清除，则移动到老生代\n- To 空间已经使用超过 25%，To 空间对象移动到老生代\n\n> 因为这次 Scavenge 回收完成后，这个 To 空间将变成 From 空间，接下来的内存分配将在这个空间中进行，如果占比过高，会影响后续的内存分配\n\n**写屏障**\n\n 写缓冲区中有一个列表(CrossRefList)，列表中记录了所有老生区对象指向新生区的情况\n\n 这样可以快速找到指向新生代该对象的老生代对象，根据他是否活跃，来清理这个新生代对象；\n\n **老生代的GC**\n\n老生代的内存空间较大且存活对象较多，使用新生代的Scavenge 复制算法，会耗费很多时间，效率不高；而且还会浪费一半的空间；\n\n为此V8使用了标记-清除算法 (Mark-Sweep)进行垃圾回收，并使用标记-压缩算法 (Mark-Compact)整理内存碎片，提高内存的利用率。步骤如下：\n\n1. 对老生代进行第一遍扫描，标记存活的对象,从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据；\n2. 对老生代进行第二次扫描，清除未被标记的对象\n3. 标记-整理算法，标记阶段一样是递归遍历元素，整理阶段是将存活对象往内存的一端移动\n4. 清除掉存活对象边界外的内存\n\n> 注意，不管那种，整理内存后只要地址有变化，需要及时更新到调用栈的\n\n **全停顿Stop-The-World**\n\nJavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做全停顿（Stop-The-World）；\n\n新生代因为内存小，活动对象少，全停顿影响不大，但是老生代可能会造成卡顿明显；\n\n解决办法：增量标记算法Incremental Marking\n\nV8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成；\n\n\n### 三、JavaScript中的垃圾回收\n\nV8（javascript引擎）的新老空间内存分配与大小限制\n\n#### 新老空间\n\n凡事都有一把双刃剑，在垃圾回收的演变过程中人们发现，没有一种特定的垃圾回收机制是可以完美的解决问题，因此V8采用了新生代与老生代结合的垃圾回收方式，将内存分为新生代和老生代。 新生代频繁进行GC，空间小，采用的是空间换时间的scavenge算法，所以又划分为两块semispace，From和To。 老生代大部分保存的是存活时间较长的或者较大的对象。采用的是mark-sweep（主）&mark-compact（辅）算法。\n\nV8限制了js对象可以使用的内存空间，不止是因为最初V8是作为浏览器引擎而设计的。还有其垃圾回收机制的影响因素。V8使用stop-the-world（全停顿）, generational, accurate的垃圾回收器。在执行回收之时会暂时中断程序的执行，而且只处理对象堆栈。当内存达到一定的体积时，进行一次垃圾回收的时间将会很长，从而影响其相应而造成浏览器假死的状况。因此，在V8中限制老生代64位为1.4GB，32位为0.7GB，新生代64位为32M，32位为16M。 当然，如果需要更大的内存空间，在node中可以进行更改。\n\n#### 对象晋升\n\n新生成的对象放入新生代内存中，那哪些对象会被放入老生代中呢？大部分放入老生代的对象是由新生代晋升而来。对象的晋升的方式：\n\n当新生代的To semispace内存占满25%时，此时再从From semispace拷贝对象将不会再放入To空间中以防影响后续的新对象分配，而将其直接复制到老生代空间中。\n\n在进行一次垃圾回收后，第二次GC时，发现已经经历过一次GC的对象在从From空间复制时直接复制到老生代。\n\n在新对象分配时大部分对象被分配到新生代的From semispace，但当这个对象的体积过大，超过1MB的内存页时，直接分配到老生代中的large Object Space。\n\n#### 新生代的GC机制与优缺点\n\n**回收机制**\n\n新生代采用Scavenge算法，在scavenge算法的实现过程中，则主要采用了cheney算法。即使用复制方式来实现垃圾回收。它将内存一分为二，每一个空间都是一个semispace。\n\n处于使用状态的是From空间，闲置的是To空间。当分配对象时，先是分配到From空间，垃圾回收时会检查From空间中存活的对象，将其复制到To空间，回收其他的对象。完成复制后会进行紧缩，From和To空间的调换。如此循环往复。\n\n**优势**\n\n由其执行的算法及过程我们可以了解到，在新生代的垃圾回收过程中，总是由一半的semispace是空余的。scavenge只复制存活的对象，在新生代的内存中，存活的对象相对较少，所以使用这个算法恰到好处。\n\n#### 老生代的GC机制与优缺点\n\n**回收机制**\n\n由于的scavenge算法只复制存活的对象，如果在老生代中也使用此算法的话就会造成复制很多对象，效率低，并且造成很大的内存空间浪费。 老生代中采用的则是mark-sweep（标记清除）和mark-compact（标记整理）结合的方式。而为什么使用两者结合呢？这就要讲到两者的优点与缺点。\n\n**mark-sweep（标记清除）**\n\n1）优点\n\n- 标记清除需要标记堆内存中的所有对象，标记出在使用的对象，清除那些没有被标记的对象。在老生代内存中与新生代相反，不使用的对象只占很小一部分，所以清除不用的对象效率高。\n- mark-sweep不会将内存空间分为两半，所以，不会浪费一半空间。\n\n2）缺点\n\n但标记清除会造成一个问题，就是在清除过后会导致内存不连续，造成内存碎片，如果此时需要储存一个很大的内存而空间又不够的时候就会造成没有必要的反复垃圾回收。\n\n**mark-compact（标记整理）**\n\n1）优点\n\n此时标记整理就可以出场了，在标记清除的过程中，标记整理会将存活的对象和需要清除的对象移动到两端。然后将其中一段需要清除的消灭掉，可以解决标记清除造成的内存碎片问题。\n\n2）缺点\n\n但是在紧缩内存的过程中需要移动对象，效率比较低。所以V8在清理时主要会使用Mark-sweep,在空间不足以对新生代中晋升过来的对象进行分配时才会使用Mark-compact。\n\n#### 垃圾回收机制的优化\n\n增量标记(在老空间里引入了此方式)\n\nscavenge算法,mark-sweep及mark-compact都会导致stop-the-world（全停顿）。而全停顿很容易带来明显的程序迟滞，标记阶段很容易就会超过100ms，因此V8引入了增量标记，将标记阶段分为若干小步骤，每个步骤控制在5ms内，每运行一段时间标记动作，就让JavaScript程序执行一会儿，如此交替，明显地提高了程序流畅性，一定程度上避免了长时间卡顿。\n\n\n\n\n\n\n\n\n",
          "answer": "",
          "biz_type": 1,
          "qid": 82,
          "subject": "",
          "title": "说一下 GC"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["快手"],
        "date": "Fri, 19 Jun 2020 16:20:40 GMT",
        "favorite_num": 4,
        "qid": 74,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "## 代码实现\n\n```js\n// 转换为真正的数组\nlet el = Array.from(document.getElementsByTagName(\"*\"));\nlet elObj = {};\n// 正则判断是否是h/s开头\nlet reg = /^[h|s].+/gi\nel.map(item=>{\n  const tagName = item.tagName;\n  if(reg.test(tagName)){\n    !elObj[tagName] ? elObj[tagName] = 1 : elObj[tagName]++\n  }\n});\nconsole.log(elObj)\n```\n",
          "answer": "",
          "biz_type": 1,
          "qid": 74,
          "subject": "",
          "title": "随便打开一个网页，用 JavaScript 打印所有以 s 和 h 开头的标签，并计算出标签的种类"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["洋葱学院"],
        "date": "Fri, 19 Jun 2020 16:20:40 GMT",
        "favorite_num": 4,
        "qid": 38,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 38,
          "subject": "",
          "title": "大数计算如何实现"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["心娱"],
        "date": "Fri, 19 Jun 2020 16:20:40 GMT",
        "favorite_num": 4,
        "qid": 64,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 64,
          "subject": "```js\nfunction Foo() {\n  getName = function () {\n    alert(1);\n  };\n  return this;\n}\nvar getName;\nfunction getName() {\n  alert(5);\n}\nFoo.getName = function () {\n  alert(2);\n};\nFoo.prototype.getName = function () {\n  alert(3);\n};\ngetName = function () {\n  alert(4);\n};\n\nFoo.getName(); // ？\ngetName(); // ？\nFoo().getName(); // ？\ngetName(); // ？\nnew Foo.getName(); // ?\nnew Foo().getName(); // ?\nnew new Foo().getName(); // ？\n```\n",
          "title": "写出输出结果"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["伴鱼", "百分点", "心娱"],
        "date": "Fri, 19 Jun 2020 16:20:40 GMT",
        "favorite_num": 4,
        "qid": 81,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 81,
          "subject": "",
          "title": "var、let、const 的区别"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["边锋"],
        "date": "Fri, 19 Jun 2020 16:20:40 GMT",
        "favorite_num": 4,
        "qid": 105,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 105,
          "subject": "",
          "title": "是否用过 restful 接口，和其他风格的有什么区别"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["边锋", "虎扑", "酷家乐", "酷狗", "安居客"],
        "date": "Fri, 19 Jun 2020 16:20:40 GMT",
        "favorite_num": 4,
        "qid": 106,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 106,
          "subject": "",
          "title": "说一下 get、post、put 的区别"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["快手"],
        "date": "Fri, 19 Jun 2020 16:20:40 GMT",
        "favorite_num": 4,
        "qid": 111,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 111,
          "subject": "",
          "title": "justify-content:space-between around 有什么区别"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["老虎"],
        "date": "Fri, 19 Jun 2020 16:20:40 GMT",
        "favorite_num": 4,
        "qid": 117,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 117,
          "subject": "",
          "title": "设计一个 Student 组件，实现输入姓名性别成绩（这三个必填），还有几个不是必填的属性，要设置默认值，点击弹出成绩"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["老虎"],
        "date": "Fri, 19 Jun 2020 16:20:40 GMT",
        "favorite_num": 4,
        "qid": 118,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 118,
          "subject": "",
          "title": "设计一个函数，奇数次执行的时候打印 1，偶数次执行的时候打印 2"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["高德", "百分点"],
        "date": "Fri, 19 Jun 2020 16:20:40 GMT",
        "favorite_num": 9,
        "qid": 119,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 119,
          "subject": "",
          "title": "实现 Promise.then"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": [
          "阿里",
          "顺丰",
          "易车",
          "有赞",
          "挖财",
          "喜马拉雅",
          "兑吧",
          "寺库",
          "海康威视",
          "道一云",
          "58"
        ],
        "date": "Fri, 19 Jun 2020 16:20:40 GMT",
        "favorite_num": 4,
        "qid": 120,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 120,
          "subject": "",
          "title": "平时在项目开发中都做过哪些前端性能优化"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["顺丰"],
        "date": "Fri, 19 Jun 2020 16:20:40 GMT",
        "favorite_num": 8,
        "qid": 121,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 121,
          "subject": "```js\n// 输入两个字符串 2018-08  2018-12\n// 输出他们中间的月份 [2018-10, 2018-11]\n```\n",
          "title": "给定起止日期，返回中间的所有月份"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["顺丰"],
        "date": "Fri, 19 Jun 2020 16:20:40 GMT",
        "favorite_num": 6,
        "qid": 122,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 122,
          "subject": "```js\n// 给两个数组 [A1,A2,B1,B2,C1,C2,D1,D2] [A,B,C,D]\n// 输出 [A1,A2,A,B1,B2,B,C1,C2,C,D1,D2,D]\n```\n",
          "title": "输入两个字符串，输出他们中间的月份"
        },
        "tech_tag": ["JavaScript", "JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["顺丰"],
        "date": "Fri, 19 Jun 2020 16:20:40 GMT",
        "favorite_num": 4,
        "qid": 124,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 124,
          "subject": "",
          "title": "用尽量短的代码实现一个 arrary 的链式操作，将数组中的大于 10 的值进行一个累加"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["顺丰"],
        "date": "Fri, 19 Jun 2020 16:20:40 GMT",
        "favorite_num": 8,
        "qid": 125,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 125,
          "subject": "",
          "title": "简单封装一个异步 fecth，使用 async await 的方式来使用"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["顺丰"],
        "date": "Fri, 19 Jun 2020 16:20:40 GMT",
        "favorite_num": 4,
        "qid": 126,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 126,
          "subject": "",
          "title": "怎么理解 to B 和 to C 的业务"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["顺丰"],
        "date": "Fri, 19 Jun 2020 16:20:40 GMT",
        "favorite_num": 9,
        "qid": 128,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 128,
          "subject": "```js\nvar obj = {\n  a: \"12\",\n  b: \"23\",\n  first: {\n    c: \"34\",\n    d: \"45\",\n    second: { 3: \"56\", f: \"67\", three: { g: \"78\", h: \"89\", i: \"90\" } },\n  },\n};\n// => [a,b,c,d,e,f,g,h,i]\n```\n",
          "title": "请写一个函数，输出出多级嵌套结构的 Object 的所有 key 值"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["头条"],
        "date": "Fri, 19 Jun 2020 16:20:40 GMT",
        "favorite_num": 9,
        "qid": 132,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 132,
          "subject": "```js\nfunction repeat(func, times, wait) {\n  // TODO\n}\nconst repeatFunc = repeat(alert, 4, 3000);\n// 调用这个 repeatFunc (\"hellworld\")，会alert4次 helloworld, 每次间隔3秒\n```\n",
          "title": "动手实现一个 repeat 方法"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["头条"],
        "date": "Fri, 19 Jun 2020 16:20:40 GMT",
        "favorite_num": 5,
        "qid": 133,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 133,
          "subject": "",
          "title": "setTimeout 有什么缺点，和 requestAnimationFrame 有什么区别"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["头条"],
        "date": "Fri, 19 Jun 2020 16:20:40 GMT",
        "favorite_num": 9,
        "qid": 134,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 134,
          "subject": "```js\nvar versions = [\"1.45.0\", \"1.5\", \"6\", \"3.3.3.3.3.3.3\"];\n// 要求从小到大排序，注意'1.45'比'1.5'大\nfunction sortVersion(versions) {\n  // TODO\n}\n// => ['1.5','1.45.0','3.3.3.3.3.3','6']\n```\n",
          "title": "versions 是一个项目的版本号列表，因多人维护，不规则，动手实现一个版本号处理函数"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["头条"],
        "date": "Fri, 19 Jun 2020 16:20:40 GMT",
        "favorite_num": 5,
        "qid": 135,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 135,
          "subject": "",
          "title": "怎样用 css 实现一个弹幕的效果，动手实现一下"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["头条", "网易"],
        "date": "Fri, 19 Jun 2020 16:20:40 GMT",
        "favorite_num": 4,
        "qid": 138,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 138,
          "subject": "```js\nasync function async1() {\n  console.log(\"async1 start\");\n  await async2();\n  console.log(\"async1 end\");\n}\nasync function async2() {\n  console.log(\"async2\");\n}\nconsole.log(\"script start\");\nsetTimeout(function () {\n  console.log(\"setTimeout\");\n}, 0);\nasync1();\nnew Promise(function (resolve) {\n  console.log(\"promise1\");\n  resolve();\n}).then(function () {\n  console.log(\"promise2\");\n});\nconsole.log(\"scripts end\");\n// 写出代码执行完成打印的结果\n```\n",
          "title": "写出代码执行结果"
        },
        "tech_tag": ["JavaScript"],
        "uid": 0,
        "uname": ""
      },
      {
        "audit_flag": 0,
        "corp_tag": ["头条"],
        "date": "Fri, 19 Jun 2020 16:20:40 GMT",
        "favorite_num": 9,
        "qid": 139,
        "qtype": "short_answer",
        "short_answer": {
          "analysis": "",
          "answer": "",
          "biz_type": 1,
          "qid": 139,
          "subject": "```js\nconst a = sum(); // => a === 0\nconst b = sum(); // => b === 2\nconst c = sum(4)(5); // c === 9\nconst k = sum(n1)...(nk) // k === n1 + n2 + ... + nk\n```\n",
          "title": "按要求实现一个 sum 函数"
        },
        "tech_tag": ["JavaScript", "编程题"],
        "uid": 0,
        "uname": ""
      }
    ],
    "page": 1,
    "pages": 1,
    "uid": 4510
  },
  "status": 0
}
