(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{362:function(n){n.exports=JSON.parse('{"msg":"success","result":{"list":[{"audit_flag":0,"corp_tag":["滴滴","快手","掌门一对一","高思教育"],"date":"Fri, 19 Jun 2020 16:21:40 GMT","favorite_num":11,"qid":19,"qtype":"short_answer","short_answer":{"analysis":"**1）优化 Webpack 的构建速度**\\n- 使用高版本的 Webpack （使用webpack4）\\n- 多线程/多实例构建：HappyPack(不维护了)、thread-loader\\n- 缩小打包作用域：\\n  - exclude/include (确定 loader 规则范围)\\n  - resolve.modules 指明第三方模块的绝对路径 (减少不必要的查找)\\n  - resolve.extensions 尽可能减少后缀尝试的可能性\\n  - noParse 对完全不需要解析的库进行忽略 (不去解析但仍会打包到 bundle 中，注意被忽略掉的文件里不应该包含 import、require、define 等模块化语句)\\n  - IgnorePlugin (完全排除模块)\\n  - 合理使用alias\\n- 充分利用缓存提升二次构建速度：\\n  - babel-loader 开启缓存\\n  - terser-webpack-plugin 开启缓存\\n  - 使用 cache-loader 或者 hard-source-webpack-plugin\\n注意：thread-loader 和 cache-loader 兩個要一起使用的話，請先放 cache-loader 接著是 thread-loader 最後才是 heavy-loader\\n- DLL：\\n  - 使用 DllPlugin 进行分包，使用 DllReferencePlugin(索引链接) 对 manifest.json 引用，让一些基本不会改动的代码先打包成静态资源，避免反复编译浪费时间。\\n\\n2）使用webpack4-优化原因\\n- (a)V8带来的优化（for of替代forEach、Map和Set替代Object、includes替代indexOf）\\n- (b)默认使用更快的md4 hash算法\\n- (c)webpacks AST可以直接从loader传递给AST，减少解析时间\\n- (d)使用字符串方法替代正则表达式\\n\\n①noParse\\n- 不去解析某个库内部的依赖关系\\n- 比如jquery 这个库是独立的， 则不去解析这个库内部依赖的其他的东西\\n- 在独立库的时候可以使用\\n```js\\nmodule.exports = {\\n  module: {\\n    noParse: /jquery/,\\n    rules:[]\\n  }\\n}\\n```\\n\\n②IgnorePlugin\\n- 忽略掉某些内容 不去解析依赖库内部引用的某些内容\\n- 从moment中引用 ./locol 则忽略掉\\n- 如果要用local的话 则必须在项目中必须手动引入 import \'moment/locale/zh-cn\'\\nmodule.exports = {\\n  plugins: [\\n    new Webpack.IgnorePlugin(/\\\\.\\\\/local/, /moment/),\\n  ]\\n}\\n\\n③dillPlugin\\n- 不会多次打包， 优化打包时间\\n- 先把依赖的不变的库打包\\n- 生成 manifest.json文件\\n- 然后在webpack.config中引入\\n- webpack.DllPlugin Webpack.DllReferencePlugin\\n\\n④happypack -> thread-loader\\n- 大项目的时候开启多线程打包\\n- 影响前端发布速度的有两个方面，一个是构建，一个就是压缩，把这两个东西优化起来，可以减少很多发布的时间。\\n\\n⑤thread-loader\\nthread-loader 会将您的 loader 放置在一个 worker 池里面运行，以达到多线程构建。\\n把这个 loader 放置在其他 loader 之前（如下图 example 的位置）， 放置在这个 loader 之后的 loader 就会在一个单独的 worker 池(worker pool)中运行。\\n```js\\n// webpack.config.js\\nmodule.exports = {\\n  module: {\\n    rules: [\\n      {\\n        test: /\\\\.js$/,\\n        include: path.resolve(\\"src\\"),\\n        use: [\\n          \\"thread-loader\\",\\n          // 你的高开销的loader放置在此 (e.g babel-loader)\\n        ]\\n      }\\n    ]\\n  }\\n}\\n```\\n每个 worker 都是一个单独的有 600ms 限制的 node.js 进程。同时跨进程的数据交换也会被限制。请在高开销的loader中使用，否则效果不佳\\n\\n⑥压缩加速——开启多线程压缩\\n- 不推荐使用 webpack-paralle-uglify-plugin，项目基本处于没人维护的阶段，issue 没人处理，pr没人合并。\\nWebpack 4.0以前：uglifyjs-webpack-plugin，parallel参数\\n```js\\nmodule.exports = {\\n  optimization: {\\n    minimizer: [\\n      new UglifyJsPlugin({\\n        parallel: true,\\n      }),\\n    ],\\n  },};\\n```\\n- 推荐使用 terser-webpack-plugin\\n```js\\nmodule.exports = {\\n  optimization: {\\n    minimizer: [new TerserPlugin(\\n      parallel: true   // 多线程\\n    )],\\n  },\\n};\\n```\\n**2）优化 Webpack 的打包体积**\\n- 压缩代码\\n  - webpack-paralle-uglify-plugin\\n  - uglifyjs-webpack-plugin 开启 parallel 参数 (不支持ES6)\\n  - terser-webpack-plugin 开启 parallel 参数\\n  - 多进程并行压缩\\n  - 通过 mini-css-extract-plugin 提取 Chunk 中的 CSS 代码到单独文件，通过optimize-css-assets-webpack-plugin插件 开启 cssnano 压缩 CSS。\\n- 提取页面公共资源：\\n  - 使用 html-webpack-externals-plugin，将基础包通过 CDN 引入，不打入 bundle 中\\n  - 使用 SplitChunksPlugin 进行(公共脚本、基础包、页面公共文件)分离(Webpack4内置) ，替代了 CommonsChunkPlugin 插件\\n  - 基础包分离：将一些基础库放到cdn，比如vue，webpack 配置 external是的vue不打入bundle\\n- Tree shaking\\n  - purgecss-webpack-plugin 和 mini-css-extract-plugin配合使用(建议)\\n  - 打包过程中检测工程中没有引用过的模块并进行标记，在资源压缩时将它们从最终的bundle中去掉(只能对ES6 Modlue生效) 开发中尽可能使用ES6 Module的模块，提高tree shaking效率\\n  - 禁用 babel-loader 的模块依赖解析，否则 Webpack 接收到的就都是转换过的 CommonJS 形式的模块，无法进行 tree-shaking\\n  - 使用 PurifyCSS(不在维护) 或者 uncss 去除无用 CSS 代码\\n- Scope hoisting\\n  - 构建后的代码会存在大量闭包，造成体积增大，运行代码时创建的函数作用域变多，内存开销变大。Scope hoisting 将所有模块的代码按照引用顺序放在一个函数作用域里，然后适当的重命名一些变量以防止变量名冲突\\n  - 必须是ES6的语法，因为有很多第三方库仍采用 CommonJS 语法，为了充分发挥 Scope hoisting 的作用，需要配置 mainFields 对第三方模块优先采用 jsnext:main 中指向的ES6模块化语法\\n- 图片压缩\\n  - 使用基于 Node 库的 imagemin (很多定制选项、可以处理多种图片格式)\\n  - 配置 image-webpack-loader\\n- 动态Polyfill\\n  - 建议采用 polyfill-service 只给用户返回需要的polyfill，社区维护。(部分国内奇葩浏览器UA可能无法识别，但可以降级返回所需全部polyfill)\\n  - @babel-preset-env 中通过useBuiltIns: \'usage参数来动态加载polyfill。\\n\\n**3）speed-measure-webpack-plugin**\\n简称 SMP，分析出 Webpack 打包过程中 Loader 和 Plugin 的耗时，有助于找到构建过程中的性能瓶颈。\\n","answer":"","biz_type":1,"qid":19,"subject":"","title":"webpack 做过哪些优化，开发效率方面、打包策略方面等等"},"tech_tag":["工程化"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["玄武科技"],"date":"Fri, 19 Jun 2020 16:20:44 GMT","favorite_num":5,"qid":718,"qtype":"short_answer","short_answer":{"analysis":"MVC，MVP和MVVM都是常见的软件架构设计模式（Architectural Pattern），它通过分离关注点来改进代码的组织方式。不同于设计模式（Design Pattern），只是为了解决一类问题而总结出的抽象方法，一种架构模式往往使用了多种设计模式。\\n\\n要了解MVC、MVP和MVVM，就要知道它们的相同点和不同点。不同部分是C(Controller)、P(Presenter)、VM(View-Model)，而相同的部分则是MV(Model-View)。\\n\\n### 一、Model&View\\n\\n**Model**\\n\\nModel层用于封装和应用程序的业务逻辑相关的数据以及对数据的处理方法。\\n\\n**View**\\n\\nView作为视图层，主要负责数据的展示。\\n\\n但对于一个应用程序，这远远是不够的，我们还需要响应用户的操作、同步更新View和Model。于是，在MVC中引入了控制器controller，让它来定义用户界面对用户输入的响应方式，它连接模型和视图，用于控制应用程序的流程，处理用户的行为和数据上的改变。\\n\\n### 二、MVC\\n\\n上个世纪70年代，美国施乐帕克研究中心，就是那个发明图形用户界面(GUI)的公司，开发了Smalltalk编程语言，并开始用它编写图形界面的应用程序。\\n\\n到了Smalltalk-80这个版本的时候，一位叫Trygve Reenskaug的工程师为Smalltalk设计了MVC（Model-View-Controller）这种架构模式，极大地降低了GUI应用程序的管理难度，而后被大量用于构建桌面和服务器端应用程序。\\n\\nMVC允许在不改变视图的情况下改变视图对用户输入的响应方式，用户对View的操作交给了Controller处理，在Controller中响应View的事件调用Model的接口对数据进行操作，一旦Model发生变化便通知相关视图进行更新。\\n\\n![MVC](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-718-mvc.png)\\n\\n\\n**Model**\\n\\nModel层用来存储业务的数据，一旦数据发生变化，模型将通知有关的视图。\\n\\nModel和View之间使用了观察者模式，View事先在此Model上注册，进而观察Model，以便更新在Model上发生改变的数据。\\n\\n**View**\\n\\nview和controller之间使用了策略模式，View引入Controller的实例来实现特定的响应策略\\n\\n**Controller**\\n\\n控制器是模型和视图之间的纽带，MVC将响应机制封装在controller对象中，当用户和你的应用产生交互时，控制器中的事件触发器就开始工作了。\\n\\nMVC模式的业务逻辑主要集中在Controller，而前端的View其实已经具备了独立处理用户事件的能力，当每个事件都流经Controller时，这层会变得十分臃肿。而且MVC中View和Controller一般是一一对应的，捆绑起来表示一个组件，视图与控制器间的过于紧密的连接让Controller的复用性成了问题，如果想多个View共用一个Controller该怎么办呢？这里有一个解决方案：就是MVP\\n\\n### 三、MVP\\n\\nMVP（Model-View-Presenter）是MVC模式的改良，由IBM的子公司Taligent提出。和MVC的相同之处在于：Controller/Presenter负责业务逻辑，Model管理数据，View负责显示。\\n\\n![mvp](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-718-mvp.png)\\n\\n虽然在MVC里，View是可以直接访问Model的，但MVP中的View并不能直接使用Model，而是通过为Presenter提供接口，让Presenter去更新Model，再通过观察者模式更新View。\\n\\n与MVC相比，MVP模式通过解耦View和Model，完全分离视图和模型使职责划分更加清晰；由于View不依赖Model，可以将View抽离出来做成组件，它只需要提供一系列接口提供给上层操作。\\n\\n**Model**\\n\\nModel层依然是主要与业务相关的数据和对应处理数据的方法。\\n\\n**View**\\n\\nMVP定义了Presenter和View之间的接口，用户对View的操作都转移到了Presenter。\\n\\nView 非常薄，不部署任何业务逻辑，称为\\"被动视图\\"（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里\\n\\n**Presenter**\\n\\nPresenter作为View和Model之间的“中间人”，除了基本的业务逻辑外，还有大量代码需要对从View到Model和从Model到View的数据进行“手动同步”，这样Presenter显得很重，维护起来会比较困难。而且由于没有数据绑定，如果Presenter对视图渲染的需求增多，它不得不过多关注特定的视图，一旦视图需求发生改变，Presenter也需要改动。\\n\\n### 四、MVVM\\n\\nMVVM（Model-View-ViewModel）最早由微软提出。ViewModel指 \\"Model of View\\"——视图的模型。这个概念曾在一段时间内被前端圈热炒，以至于很多初学者拿jQuery和Vue做对比...\\n\\n![mvvm](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-718-mvvm.png)\\n\\nMVVM把View和Model的同步逻辑自动化了。以前Presenter负责的View和Model同步不再手动地进行操作，而是交给框架所提供的数据绑定功能进行负责，只需要告诉它View显示的数据对应的是Model哪一部分即可。\\n\\n基本上与 MVP 模式完全一致。唯一的区别是，它采用双向绑定（data-binding），View的变动，自动反映在 ViewModel，反之亦然。Angular 和 Ember 都采用这种模式。\\n\\n**Model**\\n\\n在MVVM中，我们可以把Model称为数据层，因为它仅仅关注数据本身，不关心任何行为（格式化数据由View的负责\\n\\n**View**\\n\\n和MVC/MVP不同的是，MVVM中的View通过使用模板语法来声明式的将数据渲染进DOM，当ViewModel对Model进行更新的时候，会通过数据绑定更新到View。\\n\\n**ViewModel**\\n\\nViewModel大致上就是MVC的Controller和MVP的Presenter了，也是整个模式的重点，业务逻辑也主要集中在这里，其中的一大核心就是数据绑定。\\n\\n与MVP不同的是，没有了View为Presente提供的接口，之前由Presenter负责的View和Model之间的数据同步交给了ViewModel中的数据绑定进行处理，当Model发生变化，ViewModel就会自动更新；ViewModel变化，Model也会更新。\\n\\n整体来看，比MVC/MVP精简了很多，不仅仅简化了业务与界面的依赖，还解决了数据频繁更新（以前用jQuery操作DOM很繁琐）的问题。因为在MVVM中，View不知道Model的存在，ViewModel和Model也察觉不到View，这种低耦合模式可以使开发过程更加容易，提高应用的可重用性。\\n\\n### 五、总结\\n\\nMV*的目的是把应用程序的数据、业务逻辑和界面这三块解耦，分离关注点，不仅利于团队协作和测试，更有利于维护和管理。业务逻辑不再关心底层数据的读写，而这些数据又以对象的形式呈现给业务逻辑层。从 MVC --\x3e MVP --\x3e MVVM，就像一个打怪升级的过程，它们都是在MVC的基础上随着时代和应用环境的发展衍变而来的。\\n\\n在我们纠结于使用什么架构模式或框架的时候，不如先了解它们。静下来思考业务场景和开发需求，不同需求下会有最适合的解决方案。我们使用这个框架就代表认同它的思想，相信它能够提升开发效率解决当前的问题，而不仅仅是因为大家都在学。","answer":"","biz_type":1,"qid":718,"subject":"","title":"请说出前端框架设计模式(MVVM 或 MVP 又或 MVC)的含义以及原理"},"tech_tag":["工程化"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["乘法云"],"date":"Fri, 19 Jun 2020 16:20:44 GMT","favorite_num":4,"qid":743,"qtype":"short_answer","short_answer":{"analysis":"**持久化缓存**\\n\\n- 服务端设置 HTTP 缓存头（Cache-Control等）。\\n- 打包依赖（dependencies）和运行时（runtime）到不同 chunk（在 webpack 中，编译后的单独文件称为chunk），即作 splitChunks，因为它们几乎是不变的。\\n- 延迟加载：使用 `import()` 方式，可以将动态加载的文件分到独立的 chunk，以得到自己的 chunkhash\\n- 保证 hash 值稳定：编译过程和文件内容的更改尽量不影响其他文件 hash 的计算。对于低版本 webpack 生成的增量数字 ID 不稳定问题，可用 `HashedModuleIdsPlugin` 基于文件路径生成解决。","answer":"","biz_type":1,"qid":743,"subject":"","title":"如何实现 webpack 持久化缓存"},"tech_tag":["工程化"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["玄武科技"],"date":"Fri, 19 Jun 2020 16:20:44 GMT","favorite_num":4,"qid":717,"qtype":"short_answer","short_answer":{"analysis":"### 一、JavaScript 进行压缩、合并、打包实现的原理\\n\\n#### 压缩原理\\n\\n1. 去掉注释代码\\n2. 去掉换行符，空格等\\n3. 规范的变量名、函数名对于代码阅读有很大的帮助，但是对于机器来说，没有太多意义，所以缩短变量名长度，可以有效减少代码文件的体积\\n\\n#### 合并原理\\n\\n合并即多个JavaScript代码后在输出，Nginx有个concat模块可以多个资源合并在输出；\\n\\n另外可以自建Combo服务，从URL中获取对应需要获取的静态资源名，再从对应文件中获取后合并输出。\\n\\n目前前端项目合并一般会在打包过程中已处理完。\\n\\n#### 打包原理\\n\\n模块化打包，一般至少有一个入口文件，从入口文件代码中，根据代码中出现的import或者require之类语法，解析推断出这个文件所依赖的资源模块，然后再去分别解析每个资源模块的依赖，最终形成整个项目所有用到文件自己的依赖关系树。之后根据这个依赖树对每个资源文件处理，其中过程可能有代码编译、优化等，结果会被打包到目标文件中\\n\\n### 二、为什么需要压缩、合并、打包\\n\\n1. 压缩可以减少JavaScript代码体积大小，加快HTTP请求速度\\n2. 因为浏览器对同一个域名有并发请求限制，过多请求会导致HTTP请求队头阻塞等问题，合并可以减少HTTP请求数量\\n3. 对于项目代码的模块化，一些规律性的重复工作，甚至是整个前端项目的工程化，提升效率打包工具必不可少\\n\\n### 三、分别列出一个种常用工具或插件？\\n\\n1. 压缩：UglifyjsWebpackPlugin\\n2. 合并：Combo\\n3. 打包：Webpack","answer":"","biz_type":1,"qid":717,"subject":"","title":"请说明 JavaScript 进行压缩、合并、打包实现的原理是什么？为什么需要压缩、合并、打包？分别列出一种常用工具或插件"},"tech_tag":["工程化"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["高思教育"],"date":"Fri, 19 Jun 2020 16:20:44 GMT","favorite_num":3,"qid":727,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":727,"subject":"","title":"开发环境热更新的优化方式"},"tech_tag":["工程化"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["58"],"date":"Fri, 19 Jun 2020 16:20:44 GMT","favorite_num":2,"qid":735,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":735,"subject":"","title":"AMD 和 CMD 有哪些区别？"},"tech_tag":["工程化"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["58"],"date":"Fri, 19 Jun 2020 16:20:44 GMT","favorite_num":3,"qid":737,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":737,"subject":"","title":"你是怎么配置开发环境的？"},"tech_tag":["工程化"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["58"],"date":"Fri, 19 Jun 2020 16:20:44 GMT","favorite_num":5,"qid":738,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":738,"subject":"","title":"列举 3 种强制类型转换和 2 种隐式类型转换"},"tech_tag":["工程化","JavaScript"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":[],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":2,"qid":641,"qtype":"short_answer","short_answer":{"analysis":"### 优化 Webpack 的打包体积\\n\\n#### 1.压缩代码\\n\\n- **webpack-paralle-uglify-plugin**\\n- **uglifyjs-webpack-plugin** 开启 parallel 参数 (不支持ES6)\\n- **terser-webpack-plugin** 开启 parallel 参数\\n- 多进程并行压缩\\n- 通过 **mini-css-extract-plugin** 提取 Chunk 中的 CSS 代码到单独文件，通过 **optimize-css-assets-webpack-plugin** 插件 开启 cssnano 压缩 CSS。\\n\\n#### 2.提取页面公共资源\\n\\n- 使用 **html-webpack-externals-plugin** ，将基础包通过 CDN 引入，不打入 bundle 中\\n- 使用 **SplitChunksPlugin** 进行(公共脚本、基础包、页面公共文件)分离(Webpack4内置) ，替代了 **CommonsChunkPlugin** 插件\\n- 基础包分离：将一些基础库放到cdn，比如vue，webpack 配置  **external** 是的vue不打入bundle\\n\\n#### 3.Tree shaking\\n\\n- **purgecss-webpack-plugin** 和 **mini-css-extract-plugin** 配合使用(建议)\\n- 打包过程中检测工程中没有引用过的模块并进行标记，在资源压缩时将它们从最终的bundle中去掉(只能对ES6 Modlue生效) 开发中尽可能使用ES6 Module的模块，提高tree shaking效率\\n- 禁用 babel-loader 的模块依赖解析，否则 Webpack 接收到的就都是转换过的 CommonJS 形式的模块，无法进行 tree-shaking\\n- 使用 PurifyCSS(不在维护) 或者 uncss 去除无用 CSS 代码\\n\\n#### 4.Scope hoisting\\n\\n- 构建后的代码会存在大量闭包，造成体积增大，运行代码时创建的函数作用域变多，内存开销变大。Scope hoisting 将所有模块的代码按照引用顺序放在一个函数作用域里，然后适当的重命名一些变量以防止变量名冲突\\n- 必须是ES6的语法，因为有很多第三方库仍采用 CommonJS 语法，为了充分发挥 Scope hoisting 的作用，需要配置 mainFields 对第三方模块优先采用 jsnext:main 中指向的ES6模块化语法\\n\\n#### 5.图片压缩\\n\\n- 使用基于 Node 库的 **imagemin** (很多定制选项、可以处理多种图片格式)\\n- 配置 **image-webpack-loader**\\n\\n#### 6.动态Polyfill\\n\\n- 建议采用 **polyfill-service** 只给用户返回需要的polyfill，社区维护。(部分国内奇葩浏览器UA可能无法识别，但可以降级返回所需全部polyfill)\\n- **@babel-preset-env** 中通过 `useBuiltIns: \'usage` 参数来动态加载polyfill。\\n\\n#### 7.借助工具分析性能瓶颈\\n\\n**speed-measure-webpack-plugin** ，简称 SMP，分析出 Webpack 打包过程中 Loader 和 Plugin 的耗时，有助于找到构建过程中的性能瓶颈。","answer":"","biz_type":1,"qid":641,"subject":"","title":"Webpack 打包出来的体积太大，如何优化体积？"},"tech_tag":["工程化"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["微医"],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":2,"qid":506,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":506,"subject":"","title":"Webpack 做了什么？使用 webpack 构建时有无做一些自定义操作？"},"tech_tag":["工程化"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":[],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":3,"qid":590,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":590,"subject":"","title":"为什么用 gulp 打包 node"},"tech_tag":["工程化"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["会小二"],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":3,"qid":619,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":619,"subject":"","title":"git pull -rebase 和 git pull 的区别是什么？"},"tech_tag":["工程化"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["酷狗"],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":4,"qid":688,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":688,"subject":"","title":"一个活动项目里包含多个活动，Webpack 如何实现单独打包某个活动？"},"tech_tag":["工程化"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["微医"],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":3,"qid":505,"qtype":"short_answer","short_answer":{"analysis":"\\n#### 1.Hash\\n\\nwebpack 生态中存在多种计算 hash 的方式：\\n\\n- hash\\n- chunkhash\\n- contenthash。\\n\\n**hash** 代表每次 webpack 编译中生成的 hash 值，所有使用这种方式的文件 hash 都相同。每次构建都会使 webpack 计算新的 hash。\\n\\n**chunkhash** 基于入口文件（entry）及其关联的 chunk 生成，某个文件的改动只会影响与它有关联的 chunk 的 hash 值，不会影响其他文件。\\n\\n**conenthash** 根据文件内容创建。当文件内容发生变化时，contenthash 发生变化。\\n\\n#### 2.避免相同随机值\\n\\nwebpack 在计算 hash 后分割 chunk。产生相同随机值可能是因为这些文件属于同一个 chunk，可以将某一个文件提到独立的 chunk（如放入 entry）","answer":"","biz_type":1,"qid":505,"subject":"","title":"Webpack 打包时 Hash 码是怎么生成的？随机值存在一样的情况，如何避免？"},"tech_tag":["工程化"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["酷狗"],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":2,"qid":685,"qtype":"short_answer","short_answer":{"analysis":"\\n### 一、基础概念\\n\\n1. **Webpack Compiler:** 将 JS 编译成 Bundle\\n2. **Bundle Server:** 提供文件在浏览器的访问，实际上就是一个服务器\\n3. **HMR Server:** 将热更新的文件输出给HMR Runtime\\n4. **HMR Runtime:** 会被注入到bundle.js中，与HRM Server通过WebSocket链接，接收文件变化，并更新对应文件\\n5. **bundle.js:** 构建输出的文件\\n\\n### 二、原理\\n\\n#### 1.启动阶段\\n\\n1. Webpack Compiler 将对应文件打包成bundle.js(包含注入的HMR Server)，发送给Bundler Server\\n2. 浏览器即可以访问服务器的方式获取bundle.js\\n\\n#### 2.更新阶段(即文件发生了变化)\\n\\n1. Webpack Compiler 重新编译，发送给HMR Server\\n2. HMR Server 可以知道有哪些资源、哪些模块发生了变化，通知HRM Runtime\\n3. HRM Runtime更新代码\\n\\n### 三、HMR原理详解\\n\\n![hmr](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-685-hmr.png)\\n\\n使用webpack-dev-server去启动本地服务，内部实现主要使用了webpack、express、websocket。\\n\\n- 使用express启动本地服务，当浏览器访问资源时对此做响应。\\n- 服务端和客户端使用websocket实现长连接\\n- webpack监听源文件的变化，即当开发者保存文件时触发webpack的重新编译。\\n  - 每次编译都会生成hash值、已改动模块的json文件、已改动模块代码的js文件\\n  - 编译完成后通过socket向客户端推送当前编译的hash戳\\n- 客户端的websocket监听到有文件改动推送过来的hash戳，会和上一次对比\\n  - 一致则走缓存\\n  - 不一致则通过ajax和jsonp向服务端获取最新资源\\n- 使用内存文件系统去替换有修改的内容实现局部刷新\\n\\n#### 1.server端\\n\\n- 启动webpack-dev-server服务器\\n- 创建webpack实例\\n- 创建Server服务器\\n- 添加webpack的done事件回调\\n- 编译完成向客户端发送消息\\n- 创建express应用app\\n- 设置文件系统为内存文件系统\\n- 添加webpack-dev-middleware中间件\\n- 中间件负责返回生成的文件\\n- 启动webpack编译\\n- 创建http服务器并启动服务\\n- 使用sockjs在浏览器端和服务端之间建立一个 websocket 长连接\\n- 创建socket服务器\\n\\n#### 2.client端\\n\\n- webpack-dev-server/client端会监听到此hash消息\\n- 客户端收到ok的消息后会执行reloadApp方法进行更新\\n- 在reloadApp中会进行判断，是否支持热更新，如果支持的话发射webpackHotUpdate事件，如果不支持则直接刷新浏览器\\n- 在webpack/hot/dev-server.js会监听webpackHotUpdate事件\\n- 在check方法里会调用module.hot.check方法\\n- HotModuleReplacement.runtime请求Manifest\\n- 它通过调用 JsonpMainTemplate.runtime的hotDownloadManifest方法 \\n- 调用JsonpMainTemplate.runtime的hotDownloadUpdateChunk方法通过JSONP请求获取到最新的模块代码  \\n- 补丁JS取回来后会调用JsonpMainTemplate.runtime.js的webpackHotUpdate方法 \\n- 然后会调用HotModuleReplacement.runtime.js的hotAddUpdateChunk方法动态更新模块代码 \\n- 然后调用hotApply方法进行热更新","answer":"","biz_type":1,"qid":685,"subject":"","title":"Webpack 热更新的原理"},"tech_tag":["工程化"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":[],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":3,"qid":592,"qtype":"short_answer","short_answer":{"analysis":"\\n### 一、webpack 为什么慢\\n\\nwebpack是所谓的模块捆绑器，内部有循环引用来分析模块间之间的依赖，把文件解析成AST，通过一系类不同loader的加工，最后全部打包到一个js文件里。\\n\\nwebpack4以前在打包速度上没有做过多的优化手段，编译慢的大部分时间是花费在不同loader编译过程，webpack4以后，吸收借鉴了很多优秀工具的思路，\\n\\n如支持0配置，多线程等功能，速度也大幅提升，单依然有一些优化手段。如合理的代码拆分，公共代码的提取，css资源的抽离\\n\\n### 二、优化 Webpack 的构建速度\\n\\n- 使用高版本的 Webpack （使用webpack4）\\n- 多线程/多实例构建：HappyPack(不维护了)、thread-loader\\n- 缩小打包作用域：\\n  - `exclude/include` (确定 loader 规则范围)\\n  - `resolve.modules` 指明第三方模块的绝对路径 (减少不必要的查找)\\n  - `resolve.extensions` 尽可能减少后缀尝试的可能性\\n  - `noParse` 对完全不需要解析的库进行忽略 (不去解析但仍会打包到 bundle 中，注意被忽略掉的文件里不应该包含 import、require、define 等模块化语句)\\n  - IgnorePlugin (完全排除模块)\\n  - 合理使用alias\\n- 充分利用缓存提升二次构建速度：\\n  - babel-loader 开启缓存\\n  - terser-webpack-plugin 开启缓存\\n  - 使用 cache-loader 或者 hard-source-webpack-plugin\\n注意：thread-loader 和 cache-loader 兩個要一起使用的話，請先放 cache-loader 接著是 thread-loader 最後才是 heavy-loader\\n- DLL\\n  - 使用 DllPlugin 进行分包，使用 DllReferencePlugin(索引链接) 对 manifest.json 引用，让一些基本不会改动的代码先打包成静态资源，避免反复编译浪费时间。\\n\\n### 三、使用Webpack4带来的优化\\n\\n- V8带来的优化（for of替代forEach、Map和Set替代Object、includes替代indexOf）\\n- 默认使用更快的md4 hash算法\\n- webpack AST可以直接从loader传递给AST，减少解析时间\\n- 使用字符串方法替代正则表达式\\n\\n来看下具体使用\\n\\n#### 1.noParse\\n\\n- 不去解析某个库内部的依赖关系\\n- 比如jquery 这个库是独立的， 则不去解析这个库内部依赖的其他的东西\\n- 在独立库的时候可以使用\\n\\n```js\\nmodule.exports = {\\n  module: {\\n    noParse: /jquery/,\\n    rules:[]\\n  }\\n}\\n```\\n\\n#### 2.IgnorePlugin\\n\\n- 忽略掉某些内容 不去解析依赖库内部引用的某些内容\\n- 从moment中引用 `./local` 则忽略掉\\n- 如果要用local的话 则必须在项目中必须手动引入 `import \'moment/locale/zh-cn\'`\\n\\n```js\\nmodule.exports = {\\n  plugins: [\\n    new Webpack.IgnorePlugin(/\\\\.\\\\/local/, /moment/),\\n  ]\\n}\\n```\\n\\n#### 3.dillPlugin\\n\\n- 不会多次打包， 优化打包时间\\n- 先把依赖的不变的库打包\\n- 生成 manifest.json文件\\n- 然后在webpack.config中引入\\n- `webpack.DllPlugin`、`Webpack.DllReferencePlugin`\\n\\n#### 4.happypack -> thread-loader\\n\\n- 大项目的时候开启多线程打包\\n- 影响前端发布速度的有两个方面，一个是 **构建** ，一个就是 **压缩** ，把这两个东西优化起来，可以减少很多发布的时间。\\n\\n#### 5.thread-loader\\n\\n**thread-loader** 会将您的 loader 放置在一个 worker 池里面运行，以达到多线程构建。\\n\\n把这个 loader 放置在其他 loader 之前,放置在这个 loader 之后的 loader 就会在一个单独的 worker 池(worker pool)中运行。\\n\\n```js\\n// webpack.config.js\\nmodule.exports = {\\n  module: {\\n    rules: [\\n      {\\n        test: /\\\\.js$/,\\n        include: path.resolve(\\"src\\"),\\n        use: [\\n          \\"thread-loader\\",\\n          // 你的高开销的loader放置在此 (e.g babel-loader)\\n        ]\\n      }\\n    ]\\n  }\\n}\\n```\\n\\n每个 worker 都是一个单独的有 600ms 限制的 node.js 进程。同时跨进程的数据交换也会被限制。请在高开销的loader中使用，否则效果不佳\\n\\n\\n#### 6.压缩加速——开启多线程压缩\\n\\n不推荐使用 webpack-paralle-uglify-plugin，项目基本处于没人维护的阶段，issue 没人处理，pr没人合并。\\n\\nWebpack 4.0以前：uglifyjs-webpack-plugin，parallel参数\\n\\n```js\\nmodule.exports = {\\n  optimization: {\\n    minimizer: [\\n      new UglifyJsPlugin({\\n        parallel: true,\\n      }),\\n    ],\\n  },};\\n```\\n\\n推荐使用 terser-webpack-plugin\\n\\n```js\\nmodule.exports = {\\n  optimization: {\\n    minimizer: [new TerserPlugin(\\n      parallel: true   // 多线程\\n    )],\\n  },\\n};\\n```\\n","answer":"","biz_type":1,"qid":592,"subject":"","title":"Webpack 为什么慢，如何进行优化"},"tech_tag":["工程化"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":[],"date":"Fri, 19 Jun 2020 16:20:42 GMT","favorite_num":2,"qid":324,"qtype":"short_answer","short_answer":{"analysis":"**CSS 内联的核心思路是**\\n\\n将页面打包过程的产生的所有 CSS 提取成一个独立的文件，然后将这个 CSS 文件内联进 HTML head 里面。\\n\\n可以借助 `mini-css-extract-plugin` 和 `html-inline-css-webpack-plugin` 来实现 CSS 的内联功能，注意 `html-inline-css-webpack-plugin` 需要放在 `html-webpack-plugin` 后面。\\n","answer":"","biz_type":1,"qid":324,"subject":"","title":"webpack 怎么处理内联 css 的"},"tech_tag":["工程化"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["阿里"],"date":"Fri, 19 Jun 2020 16:20:42 GMT","favorite_num":2,"qid":358,"qtype":"short_answer","short_answer":{"analysis":"### 一、dev-server运行配置\\n\\n- 安装webpack-dev-server的npm包\\n- 在webpack.config.js中进行配置\\n\\n**devServer中常用的配置对象属性如下:**\\n\\n1. `contentBase：”./”`,本地服务器在哪个目录搭建页面，一般在当前目录即可；\\n2. `historyApiFallback：true` ,搭建spa应用时有用，它使用的是HTML5 History Api，任意的跳转或404响应可以指向 index.html 页面；\\n3. `inline：true` ,用来支持dev-server自动刷新的配置，webpack有两种模式支持自动刷新，一种是iframe模式，一种是inline模式；使用iframe模式是不需要在devServer进行配置的，只需使用特定的URL格式访问即可；不过我们一般还是常用inline模式，在devServer中对inline设置为true后，当启动webpack-dev-server时仍要需要配置inline才能生效\\n4. `hot：true` ,启动webpack热模块替换特性\\n5. `port`，端口号(默认8080) \\n\\n### 二、怎么跑起来的\\n\\n1. 启动HTTP服务\\n2. Webpack构建输出Bundle到内存，HTTP服务从内存中读取Bundle文件\\n3. 监听文件变化，重新执行第二个步骤\\n\\ndev-server实际上是一个HTTP服务器，所以还可以做静态资源的访问和API的Proxy代码\\n\\n#### 1.静态资源访问\\n\\n```js\\n{\\n    devServer: {\\n        contentBase: \'public\'\\n    }\\n}\\n```\\n\\n#### 2.Proxy 代理\\n\\n```js\\n{\\n    devServer: {\\n        proxy: {\\n            \'/api\': {\\n                target: \'http://api.target.com/\'\\n            }\\n        }\\n    }\\n}\\n```\\n","answer":"","biz_type":1,"qid":358,"subject":"","title":"dev-server 是怎么跑起来的"},"tech_tag":["工程化"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":[],"date":"Fri, 19 Jun 2020 16:20:42 GMT","favorite_num":2,"qid":321,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":321,"subject":"","title":"A、B 两个条件组件，如何做到 webpack 只打包条件为 true 的组件，false 的组件不打包"},"tech_tag":["工程化"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":[],"date":"Fri, 19 Jun 2020 16:20:42 GMT","favorite_num":2,"qid":325,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":325,"subject":"","title":"webpack 如何做异步加载"},"tech_tag":["工程化"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["阿里"],"date":"Fri, 19 Jun 2020 16:20:42 GMT","favorite_num":3,"qid":357,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":357,"subject":"","title":"Webpack 里面的插件时怎么实现的"},"tech_tag":["工程化"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["阿里"],"date":"Fri, 19 Jun 2020 16:20:42 GMT","favorite_num":2,"qid":359,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":359,"subject":"","title":"Webpack 抽取公共文件是怎么配置的"},"tech_tag":["工程化"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["滴滴"],"date":"Fri, 19 Jun 2020 16:20:42 GMT","favorite_num":3,"qid":384,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":384,"subject":"","title":"import { Button } from \'antd\'，打包的时候只打包 button，分模块加载，是怎么做到的"},"tech_tag":["工程化"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["滴滴"],"date":"Fri, 19 Jun 2020 16:20:42 GMT","favorite_num":2,"qid":385,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":385,"subject":"","title":"使用 import 时，webpack 对 node_modules 里的依赖会做什么"},"tech_tag":["工程化"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["挖财"],"date":"Fri, 19 Jun 2020 16:20:42 GMT","favorite_num":2,"qid":437,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":437,"subject":"","title":"前端怎么做单元测试"},"tech_tag":["工程化"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["沪江"],"date":"Fri, 19 Jun 2020 16:20:42 GMT","favorite_num":3,"qid":450,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":450,"subject":"","title":"一般怎么组织 CSS（Webpack）"},"tech_tag":["工程化"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["饿了么"],"date":"Fri, 19 Jun 2020 16:20:42 GMT","favorite_num":3,"qid":453,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":453,"subject":"","title":"webpack 如何配 sass，需要配哪些 loader，配 css 需要哪些 loader"},"tech_tag":["工程化"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["饿了么"],"date":"Fri, 19 Jun 2020 16:20:42 GMT","favorite_num":2,"qid":454,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":454,"subject":"","title":"如何配置把 js、css、html 单独打包成一个文件"},"tech_tag":["工程化"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["兑吧"],"date":"Fri, 19 Jun 2020 16:20:42 GMT","favorite_num":3,"qid":482,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":482,"subject":"","title":"webpack 和 gulp 的优缺点"},"tech_tag":["工程化"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["兑吧"],"date":"Fri, 19 Jun 2020 16:20:42 GMT","favorite_num":3,"qid":484,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":484,"subject":"","title":"如何实现分模块打包（多入口）"},"tech_tag":["工程化"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["完美世界"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":3,"qid":145,"qtype":"short_answer","short_answer":{"analysis":"#### 1.es6模块调用commonjs模块\\n\\n可以直接使用commonjs模块，commonjs模块将不会被webpack的模块系统编译而是会原样输出，并且commonjs模块没有default属性\\n\\n#### 2.es6模块调用es6模块\\n\\n被调用的es6模块不会添加`{__esModule:true}`，只有调用者才会添加`{__esModule:true}`，并且可以进行`tree-shaking`操作，如果被调用的es6模块只是import进来，但是并没有被用到，那么被调用的es6模块将会被标记为`/* unused harmony default export */`，在压缩时此模块将会被删除（例外：如果被调用的es6模块里有立即执行语句，那么这些语句将会被保留）\\n\\n\\n#### 3.commonjs模块引用es6模块\\n\\nes6模块编译后会添加`{__esModule:true}`。如果被调用的es6模块中恰好有`export default`语句，那么编译后的es6模块将会添加default属性。\\n\\n#### 4.commonjs模块调用commonjs模块\\n\\ncommonjs模块会原样输出\\n","answer":"","biz_type":1,"qid":145,"subject":"","title":"Import 和 CommonJS 在 webpack 打包过程中有什么不同"},"tech_tag":["工程化"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["网易"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":3,"qid":157,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":157,"subject":"","title":"说一下 webpack 中 css-loader 和 style-loader 的区别，file-loader 和 url-loader 的区别"},"tech_tag":["工程化"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["易车"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":2,"qid":167,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":167,"subject":"","title":"脚手架具体都做了哪些事，webpack 具体做了什么配置，怎样优化的打包大小"},"tech_tag":["工程化"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["滴滴"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":3,"qid":185,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":185,"subject":"","title":"webpack如何用localStorage离线缓存静态资源 "},"tech_tag":["工程化"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["自如"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":2,"qid":243,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":243,"subject":"","title":"说一下 webpack 与 gulp 的区别（源码角度）"},"tech_tag":["工程化"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["滴滴","挖财"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":2,"qid":168,"qtype":"short_answer","short_answer":{"analysis":"\\n\\n**Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程**\\n\\n- **初始化参数** 从配置文件和 Shell 语句中读取与合并参数，得出最终的参数\\n- **开始编译** 用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译\\n- **确定入口** 根据配置中的 entry 找出所有的入口文件\\n- **编译模块** 从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理\\n- **完成模块编译** 在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系\\n- **输出资源** 根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会\\n- **输出完成** 在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统\\n\\n在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。","answer":"","biz_type":1,"qid":168,"subject":"","title":"介绍下 Webpack 的整个生命周期"},"tech_tag":["工程化"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["头条"],"date":"Fri, 19 Jun 2020 16:20:40 GMT","favorite_num":3,"qid":50,"qtype":"short_answer","short_answer":{"analysis":"### 答案\\n\\n当前端项目到达一定的规模后，我们一般会采用按模块方式组织代码，这样可以方便代码的组织及维护。但会存在一个问题，比如我们有一个utils工具类，在另一个模块中导入它。这会在打包的时候将utils中不必要的代码也打包，从而使得打包体积变大，这时候就需要用到Tree shaking技术了。\\n\\n> Tree shaking 是一种通过清除多余代码方式来优化项目打包体积的技术，专业术语叫Dead code elimination\\n\\n#### 原理\\n\\n利用 ES6 模块的特点:\\n\\n- 只能作为模块顶层的语句出现\\n- import 的模块名只能是字符串常量，不能动态引入模块\\n- import binding 是 immutable的，引入的模块不能再进行修改\\n\\n虽然tree shaking的概念在1990就提出了，但直到ES6的ES6-style模块出现后才真正被利用起来。这是因为tree shaking只能在静态modules下工作。ECMAScript 6 模块加载是静态的,因此整个依赖树可以被静态地推导出解析语法树。所以在ES6中使用tree shaking是非常容易的。而且，tree shaking不仅支持import/export级别，而且也支持statement(声明)级别。\\n\\n在ES6以前，我们可以使用CommonJS引入模块：require()，这种引入是动态的，也意味着我们可以基于条件来导入需要的代码：\\n\\n```js\\nlet dynamicModule;\\n// 动态导入\\nif(condition) {\\n    myDynamicModule = require(\\"foo\\");\\n} else {\\n    myDynamicModule = require(\\"bar\\");\\n}\\n```\\n\\nCommonJS的动态特性模块意味着tree shaking不适用。因为它是不可能确定哪些模块实际运行之前是需要的或者是不需要的。在ES6中，进入了完全静态的导入语法：import。这也意味着下面的导入是不可行的：\\n\\n```js\\n// 不可行，ES6 的import是完全静态的\\nif(condition) {\\n    myDynamicModule = require(\\"foo\\");\\n} else {\\n    myDynamicModule = require(\\"bar\\");\\n}\\n```\\n\\n只能通过导入所有的包后再进行条件获取\\n\\n```js\\nimport foo from \\"foo\\";\\nimport bar from \\"bar\\";\\n\\nif(condition) {\\n    // foo.xxxx\\n} else {\\n    // bar.xxx\\n}\\n```\\n\\nES6的import语法完美可以使用tree shaking，因为可以在代码不运行的情况下就能分析出不需要的代码。\\n\\n\\n#### 如何使用\\n\\n从webpack 2开始支持实现了Tree shaking特性，webpack 2正式版本内置支持ES2015 模块（也叫做harmony模块）和未引用模块检测能力。新的webpack 4 正式版本，扩展了这个检测能力，通过package.json的 sideEffects属性作为标记，向compiler 提供提示，表明项目中的哪些文件是 “pure(纯的 ES2015 模块)”，由此可以安全地删除文件中未使用的部分。\\n\\n如果使用的是webpack4,只需要将mode设置为production即可开启tree shaking\\n\\n```js\\nentry: \'./src/index.js\',\\nmode: \'production\', // 设置为production模式\\noutput: {\\n\\tpath: path.resolve(__dirname, \'dist\'),\\n\\tfilename: \'bundle.js\'\\n},\\n```\\n\\n如果是使用webpack2,可能你会发现tree shaking不起作用。因为babel会将代码编译成CommonJs模块，而tree shaking不支持CommonJs。所以需要配置不转义：\\n\\n```js\\noptions: { presets: [ [ \'es2015\', { modules: false } ] ] }\\n```\\n\\n#### 关于side effects（副作用）\\n\\nside effects是指那些当import的时候会执行一些动作，但是不一定会有任何export。比如ployfill,ployfills不对外暴露方法给主程序使用。\\n\\ntree shaking 不能自动的识别哪些代码属于side effects，因此手动指定这些代码显得非常重要，如果不指定可能会出现一些意想不到的问题。\\n\\n在webapck中，是通过package.json的sideEffects属性来实现的。\\n\\n```js\\n{\\n  \\"name\\": \\"tree-shaking\\",\\n  \\"sideEffects\\": false\\n}\\n```\\n\\n如果所有代码都不包含副作用，我们就可以简单地将该属性标记为false，来告知 webpack，它可以安全地删除未用到的export导出。\\n\\n如果你的代码确实有一些副作用，那么可以改为提供一个数组：\\n\\n```js\\n{\\n  \\"name\\": \\"tree-shaking\\",\\n  \\"sideEffects\\": [\\n    \\"./src/common/polyfill.js\\"\\n  ]\\n}\\n```\\n\\n#### 总结\\n\\n- tree shaking 不支持动态导入（如CommonJS的require()语法），只支持纯静态的导入（ES6的import/export）\\n- webpack中可以在项目package.json文件中，添加一个 “sideEffects” 属性,手动指定由副作用的脚本\\n","answer":"","biz_type":1,"qid":50,"subject":"","title":"说下 tree-shaking 的原理"},"tech_tag":["工程化"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["头条","滴滴","挖财","阿里"],"date":"Fri, 19 Jun 2020 16:20:40 GMT","favorite_num":4,"qid":61,"qtype":"short_answer","short_answer":{"analysis":"### 答案\\n\\n#### 一、webpack原理\\n\\n**1）初始化参数**\\n\\n从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；\\n\\n**2）开始编译**\\n\\n用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译。\\n\\n**3）确定入口**\\n\\n根据配置中的 entry 找出所有的入口文件；\\n\\n**4）编译模板**\\n\\n从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；\\n\\n**5）模块编译完成**\\n\\n在经过第 4 步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；\\n\\n**6）输出资源**\\n\\n根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；\\n\\n**7）输出完成**\\n\\n在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统；\\n\\n**8）其它**\\n\\n整个过程中特定的时间点广播事件，插件可以进行监听和处理；\\n\\n\\n\\n#### 二、loader&plugin\\n\\n**1）loader**\\n\\nloader是文件加载器，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中，处理一个文件可以使用多个loader，loader的执行顺序和配置中的顺序是相反的，即最后一个loader最先执行，第一个loader最后执行，第一个执行的loader接收源文件内容作为参数，其它loader接收前一个执行的loader的返回值作为参数，最后执行的loader会返回此模块的JavaScript源码\\n\\n编写自己的loader时需要引用官方提供的laoder-utils ，调用loaderUtils.getOptions(this)拿到webpack的配置参数，然后进行自己的处理。\\n\\nLoader 本身仅仅只是一个函数，接收模块代码的内容，然后返回代码内容转化后的结果，并且一个文件还可以链式的经过多个loader转化(比如scss-loader => css-loader => style-loader)。\\n\\n一个 Loader 的职责是单一的，只需要完成一种转化。 如果一个源文件需要经历多步转化才能正常使用，就通过多个 Loader 去转化。 在调用多个 Loader 去转化一个文件时，每个 Loader 会链式的顺序执行， 第一个 Loader 将会拿到需处理的原内容，上一个 Loader 处理后的结果会传给下一个接着处理，最后的 Loader 将处理后的最终结果返回给 Webpack。\\n\\n一个最简单的loader例子:\\n\\n```js\\nmodule.exports = function(source) {\\n  // source 为 compiler 传递给 Loader 的一个文件的原内容\\n  // 该函数需要返回处理后的内容，这里简单起见，直接把原内容返回了，相当于该 Loader 没有做任何转换\\n  return source;\\n};\\n```\\n\\n**2）plugin**\\n\\nplugin功能更强大，Loader不能做的都是它做。它的功能要更加丰富。从打包优化和压缩，到重新定义环境变量，功能强大到可以用来处理各种各样的任务。\\n\\nplugin让webpack的机制更加灵活，它在编译过程中留下的一系列生命周期的钩子，通过调用这些钩子来实现在不同编译结果时对源模块进行处理。它的编译是基于事件流来编译的，主要通过taptable来实现插件的绑定和执行的，taptable主要是基于发布订阅执行的插件架构，是用来创建声明周期钩子的库。调用complier.hooks.run.tap开始注册，创建compilation，基于配置创建chunks，在通过parser解析chunks，使用模块和依赖管理模块之间的依赖关系，最后使用template基于compilation数据生成结果代码 \\n\\nplugin 的实现可以是一个类，使用时传入相关配置来创建一个实例，然后放到配置的 `plugins` 字段中，而 plugin 实例中最重要的方法是 `apply`，该方法在 webpack compiler 安装插件时会被调用一次，`apply` 接收 webpack compiler 对象实例的引用，你可以在 compiler 对象实例上注册各种事件钩子函数，来影响 webpack 的所有构建流程，以便完成更多其他的构建任务。\\n\\n一个最简单的plugin例子：\\n\\n```js\\nclass BasicPlugin{\\n  // 在构造函数中获取用户给该插件传入的配置\\n  constructor(options){\\n  }\\n\\n  // Webpack 会调用 BasicPlugin 实例的 apply 方法给插件实例传入 compiler 对象\\n  apply(compiler){\\n    compiler.plugin(\'compilation\',function(compilation) {\\n    })\\n  }\\n}\\n\\n// 导出 Plugin\\nmodule.exports = BasicPlugin;\\n```\\n\\nWebpack 启动后，在读取配置的过程中会先执行 new BasicPlugi(options) 初始化一个 BasicPlugin 获得其实例。 在初始化 compiler 对象后，再调用 basicPlugin.apply(compiler) 给插件实例传入 compiler 对象。 插件实例在获取到 compiler 对象后，就可以通过 compiler.plugin(事件名称, 回调函数) 监听到 Webpack 广播出来的事件。 并且可以通过 compiler 对象去操作 Webpack。\\n\\n开发 Plugin 最主要的就是理解 compiler 和 compilation，它们是Plugin 和 Webpack 之间的桥梁。这两者提供的各种 hooks 和 api，则是开发plugin 所必不可少的材料，通过 compiler 和 compilation 的生命周期 hooks，也可以更好地深入了解 webpack 的整个构建工作是如何进行的。\\n\\n**3）常见loader**\\n\\n1. file-loader:文件加载\\n2. url-loader：文件加载，可以设置阈值，小于时把文件base64编码\\n3. image-loader：加载并压缩图片\\n4. json-loader：webpack默认包含了\\n5. babel-loader：ES6+ 转成ES5\\n6. ts-loader：将ts转成js\\n7. awesome-typescript-loader：比上面那个性能好\\n8. css-loader：处理@import和url这样的外部资源\\n9. style-loader：在head创建style标签把样式插入；\\n10. postcss-loader：扩展css语法，使用postcss各种插件autoprefixer，cssnext，cssnano\\n11. eslint-loader,tslint-loader:通过这两种检查代码，tslint不再维护，用的eslint\\n12. vue-loader：加载vue单文件组件\\n13. i18n-loader：国际化\\n14. cache-loader：性能开销大的loader前添加，将结果缓存到磁盘；\\n15. svg-inline-loader：压缩后的svg注入代码；\\n16. source-map-loader：加载source Map文件，方便调试；\\n17. expose-loader:暴露对象为全局变量\\n18. imports-loader、exports-loader等可以向模块注入变量或者提供导出模块功能\\n19. raw-loader可以将文件已字符串的形式返回\\n20. 校验测试：mocha-loader、jshint-loader 、eslint-loader等\\n\\n**3）常见plugin**\\n\\n- ignore-plugin：忽略文件\\n- uglifyjs-webpack-plugin：不支持 ES6 压缩 (Webpack4 以前使用)\\n- terser-webpack-plugin: 支持压缩 ES6 (Webpack4)\\n- webpack-parallel-uglify-plugin: 多进程执行代码压缩，提升构建速度\\n- mini-css-extract-plugin: 分离样式文件，CSS 提取为独立文件，支持按需加载\\n- serviceworker-webpack-plugin：为网页应用增加离线缓存功能\\n- clean-webpack-plugin: 目录清理\\n- speed-measure-webpack-plugin: 可以看到每个 Loader 和 Plugin 执行耗时\\n- webpack内置UglifyJsPlugin，压缩和混淆代码。\\n- webpack内置CommonsChunkPlugin，提高打包效率，将第三方库和业务代码分开打包。\\n- ProvidePlugin：自动加载模块，代替require和import\\n- html-webpack-plugin可以根据模板自动生成html代码，并自动引用css和js文件\\n- extract-text-webpack-plugin 将js文件中引用的样式单独抽离成css文件\\n- DefinePlugin 编译时配置全局变量，这对开发模式和发布模式的构建允许不同的行为非常有用。\\n- HotModuleReplacementPlugin 热更新\\n- DllPlugin和DllReferencePlugin相互配合，前者第三方包的构建，只构建业务代码，同时能解决Externals多次引用问题。DllReferencePlugin引用DllPlugin配置生成的manifest.json文件，manifest.json包含了依\\n赖模块和module id的映射关系\\n- optimize-css-assets-webpack-plugin 不同组件中重复的css可以快速去重\\n- webpack-bundle-analyzer 一个webpack的bundle文件分析工具，将bundle文件以可交互缩放的treemap的形式展示。\\n- compression-webpack-plugin 生产环境可采用gzip压缩JS和CSS\\n- happypack：通过多进程模型，来加速代码构建\\n\\n\\n\\n### 三、模块化标准\\n\\n**1）CommonJS**\\n\\n通过require方法来同步加载依赖模块  用过exports 或者 module.exports 来导出需要暴露的接口\\n\\n每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见所有代码都运行在模块作用域，不会污染全局作用域。\\n\\n模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。\\n\\n模块加载的顺序，按照其在代码中出现的顺序。\\n\\n同步的模块加载方式不适合在浏览器环境中，同步意味着阻塞加载 浏览器资源多是异步加载的\\n\\n不能非阻塞的并行加载多个模块\\n\\n**2）AMD**\\n\\n实现有 curl  requireJS,适合在浏览器环境中异步加载模块,可以并行加载多个模块,依赖前置,提前执行\\n\\n**3）CMD**\\n\\n实现有 Sea.js、coolie，依赖就近，延迟执行\\n\\n缺点：依赖SPM打包 模块的加载逻辑偏重\\n\\n**4）UMD**\\n\\n规范类似于兼容CommonJS和AMD的语法糖 是模块定义的跨平台解决方案\\n\\n**5）ES6模块**\\n\\n- 编译时就能确定模块的依赖关系 以及输入和输出的变量\\n- 容易进行静态分析\\n- 面向未来的ECMAScript标准\\n- 缺点\\n    -  原生的浏览器还没有实现该标准\\n    - 全新的命令字只有node.js才支持\\n\\n### 四、cjs 和 esmodule 的区别\\n\\n**1）加载方式不同**\\n\\ncommonjs是同步加载的。主要是在nodejs，也就是服务端应用的模块化机制，通过module.export 导出声明，通过require(\'\')加载。每个文件都是一个模块。他有自己的作用域，文件内的变量，属性函数等不被外界访问。node会将模块缓存，第二次加载会直接在缓存中获取。\\n\\nES6的模块化加载时通过export default 导出 用import导入 可通过 {} 对导出的内容进行解构。\\n\\nCommonJS 在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次；ES Module 采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化\\n\\nCommonJS 加载的是整个模块，即将所有的接口全部加载进来；ES6 可以单独加载其中的某个方法\\n\\n**2）运行机制不同**\\n\\nES6的模块的运行机制与common不一样，js引擎对脚本静态分析的时候，遇到模块加载指令后会生成一个只读引用，等到脚本真正执行的时候才会通过引用去模块中获取值，在引用到执行的过程中 模块中的值发生了变化，导入的这里也会跟着变，ES6模块是动态引用，并不会缓存值，模块里总是绑定其所在的模块。\\n\\nCommonJS 模块是运行时加载，ES6 模块是编译时输出接口\\n\\n**3）主要运行环境不同**\\n\\ncommonjs主要运行在服务端、运行时加载、输出的是整个文件、值的引入是直接导入的、this指向当前模块、node会将模块缓存\\n\\nES6主要运行在浏览器端、编译时加载/ 延迟加载、异步加载、导出某个接口，可按需加载、值是引用的，执行时获取值、this指向undefined\\n","answer":"","biz_type":1,"qid":61,"subject":"","title":"讲一下 webpack 原理， loader 和 plugin，你知道哪些模块化标准，说下 cjs 和 esmodule 的区别"},"tech_tag":["工程化"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["头条","挖财"],"date":"Fri, 19 Jun 2020 16:20:40 GMT","favorite_num":3,"qid":49,"qtype":"short_answer","short_answer":{"analysis":"### 答案\\n\\n#### 1.什么是Webpack\\n\\nwebpack是一个**打包模块化**JavaScript的工具，它将一切文件都视为模块，通过loader编译转换文件，通过plugin注入钩子，最后将输出的资源模块组合成文件。\\n\\n它主要的**配置信息**有entry、output、modules、plugins。\\n\\n#### 2.构建流程\\n\\n**基础概念**\\n\\n1. Compiler：Webpack的运行入口，实例化时定义webpack构建主要流程，同时创建构建时使用的核心对象compilation\\n2. Compilation：由Compiler实例化，存储构建过程中流程使用到的数据，用于控制这些数据的变化，每一次构建创建一个Compilation实例\\n3. Chunk：一般一个入口对应一个Chunk\\n4. Module：用于表示代码模块的类型，有很多子类用于处理不同情况的模块，模块相关信息都可以从Module实例中获取，例如dependiencies记录模块的依赖信息\\n5. Parser：基于acorn来分析AST语法树，解析出代码模块的依赖\\n6. Dependency：解析时用于保存代码模块对应的依赖使用的对象\\n7. Template：生成最终代码要使用到的代码模块\\n\\n**基本流程**\\n\\n1. 创建Compiler实例，用于控制构建流程，compiler实例包含webpack基本环境信息\\n2. 根据配置项转换成对应内部插件，并初始化options配置项\\n3. 执行compiler.run\\n4. 创建Compiltation实例，每次构建都会新创建一个Compliation实例，包含了这次构建的基本信息\\n5. 从entry开始递归分析依赖，对每个依赖模块进行buildModule，通过Loader将不同类型的模块转换成Webpack模块\\n6. 调用Parser.parse将上面的结果转换成AST树\\n7. 遍历AST树，收集依赖Dependency，并保存在Compliation实例的dependiencies属性中\\n8. 生成Chunks，不同entry生成不同chunk，动态导入也会生成自己的chunk，生成chunk后还会进行优化\\n9. 使用Template基于Compilation的数据生成结果代码\\n\\n**编译过程**\\n\\n- **第一步**先初始化参数，通过yargs将webpack.config.js和shell脚本的配置信息合并，进行参数的初始化；\\n- **第二步**利用初始化的参数创建complier对象，complier可以视为一个webpack的实例，存在于webpack从启动到结束的整个过程，它包含了webpack的module、plugin等参数信息，然后调用complier.run方法开始编译。\\n- **第三步**根据entry配置信息找到入口文件，创建compilation对象，可以理解为webpack一次编译的过程，包含了当前编译环境的所有资源，包括编译后的文件。\\n- **第四步**通过配置信息，调用loader进行模块翻译，使用acorn将模块转换为AST，当遇到require依赖时，创建依赖并加入依赖数组，再找出依赖的依赖，递归异步的处理所有的依赖。\\n- **第五步**完成第四步后将得到所有模块的依赖关系和模块翻译后的文件，然后调用compilation.seal方法，对这些模块和根据模块依赖关系创建的chunk进行整理，将所有资源进行合并拆分等操作。这是最后一次能修改输出内容的地方。\\n- **第六步**根据配置信息中的output配置，进行最后模块的文件输出，指定输出文件名和文件路径。\\n\\n#### 3.原理\\n\\nwebpack打包输出后的文件其实就是一个闭包，传入的参数是一个对象，键值为所有输出文件的路径，内容为eval包裹的文件内容；闭包内重写了模块的加载方式，自己定义了`__webpack_require__方法，来实现模拟的commonjs规范模块加载机制。\\n\\nWebpack实际上是基于事件流的，通过一系列的插件来运行。Webpack利用tapable库提供各种钩子来实现对于整个构建流程各个步骤的控制\\n","answer":"","biz_type":1,"qid":49,"subject":"","title":"介绍下 webpack，并说下 Webpack 的构建流程"},"tech_tag":["工程化"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["阿里","滴滴","挖财"],"date":"Fri, 19 Jun 2020 16:20:40 GMT","favorite_num":2,"qid":47,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":47,"subject":"","title":"说下 webpack 的 loader 和 plugin 的区别，都使用过哪些 loader 和 plugin"},"tech_tag":["工程化"],"uid":0,"uname":""}],"page":1,"pages":1,"uid":4510},"status":0}')}}]);