(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{358:function(n){n.exports=JSON.parse('{"msg":"success","result":{"list":[{"audit_flag":0,"corp_tag":["滴滴","虎扑","挖财","58","头条"],"date":"Fri, 19 Jun 2020 16:21:40 GMT","favorite_num":45,"qid":9,"qtype":"short_answer","short_answer":{"analysis":"1）防抖\\n- 原理：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。\\n- 适用场景：\\n  - 按钮提交场景：防止多次提交按钮，只执行最后提交的一次\\n  - 搜索框联想场景：防止联想发送请求，只发送最后一次输入\\n- 简易版实现\\n\\n```js\\nfunction debounce(func, wait) {\\n    let timeout;\\n    return function () {\\n        const context = this;\\n        const args = arguments;\\n        clearTimeout(timeout)\\n        timeout = setTimeout(function(){\\n            func.apply(context, args)\\n        }, wait);\\n    }\\n}\\n```\\n\\n- 立即执行版实现\\n  - 有时希望立刻执行函数，然后等到停止触发 n 秒后，才可以重新触发执行。\\n\\n```js\\n// 有时希望立刻执行函数，然后等到停止触发 n 秒后，才可以重新触发执行。\\nfunction debounce(func, wait, immediate) {\\n  let timeout;\\n  return function () {\\n    const context = this;\\n    const args = arguments;\\n    if (timeout) clearTimeout(timeout);\\n    if (immediate) {\\n      const callNow = !timeout;\\n      timeout = setTimeout(function () {\\n        timeout = null;\\n      }, wait)\\n      if (callNow) func.apply(context, args)\\n    } else {\\n      timeout = setTimeout(function () {\\n        func.apply(context, args)\\n      }, wait);\\n    }\\n  }\\n}\\n```\\n\\n- 返回值版实现\\n  - func函数可能会有返回值，所以需要返回函数结果，但是当 immediate 为 false 的时候，因为使用了 setTimeout ，我们将 func.apply(context, args) 的返回值赋给变量，最后再 return 的时候，值将会一直是 undefined，所以只在 immediate 为 true 的时候返回函数的执行结果。\\n\\n```js\\nfunction debounce(func, wait, immediate) {\\n  let timeout, result;\\n  return function () {\\n    const context = this;\\n    const args = arguments;\\n    if (timeout) clearTimeout(timeout);\\n    if (immediate) {\\n      const callNow = !timeout;\\n      timeout = setTimeout(function () {\\n        timeout = null;\\n      }, wait)\\n      if (callNow) result = func.apply(context, args)\\n    }\\n    else {\\n      timeout = setTimeout(function () {\\n        func.apply(context, args)\\n      }, wait);\\n    }\\n    return result;\\n  }\\n}\\n```\\n\\n2）节流\\n- 原理：规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。\\n- 适用场景\\n  - 拖拽场景：固定时间内只执行一次，防止超高频次触发位置变动\\n  - 缩放场景：监控浏览器resize\\n- 使用时间戳实现\\n  - 使用时间戳，当触发事件的时候，我们取出当前的时间戳，然后减去之前的时间戳(最一开始值设为 0 )，如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，如果小于，就不执行。\\n\\n```js\\nfunction throttle(func, wait) {\\n  let context, args;\\n  let previous = 0;\\n\\n  return function () {\\n    let now = +new Date();\\n    context = this;\\n    args = arguments;\\n    if (now - previous > wait) {\\n      func.apply(context, args);\\n      previous = now;\\n    }\\n  }\\n}\\n```\\n\\n- 使用定时器实现\\n  - 当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行，直到定时器执行，然后执行函数，清空定时器，这样就可以设置下个定时器。\\n\\n```js\\nfunction throttle(func, wait) {\\n  let timeout;\\n  return function () {\\n    const context = this;\\n    const args = arguments;\\n    if (!timeout) {\\n      timeout = setTimeout(function () {\\n        timeout = null;\\n        func.apply(context, args)\\n      }, wait)\\n    }\\n\\n  }\\n}\\n```\\n","answer":"","biz_type":1,"qid":9,"subject":"","title":"介绍防抖节流原理、区别以及应用，并用JavaScript进行实现"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["滴滴","头条","喜马拉雅","兑吧","寺库","百分点","58","安居客"],"date":"Fri, 19 Jun 2020 16:21:40 GMT","favorite_num":18,"qid":23,"qtype":"short_answer","short_answer":{"analysis":"1）Promise基本特性\\n- 1、Promise有三种状态：pending(进行中)、fulfilled(已成功)、rejected(已失败)\\n- 2、Promise对象接受一个回调函数作为参数, 该回调函数接受两个参数，分别是成功时的回调resolve和失败时的回调reject；另外resolve的参数除了正常值以外， 还可能是一个Promise对象的实例；reject的参数通常是一个Error对象的实例。\\n- 3、then方法返回一个新的Promise实例，并接收两个参数onResolved(fulfilled状态的回调)；onRejected(rejected状态的回调，该参数可选)\\n- 4、catch方法返回一个新的Promise实例\\n- 5、finally方法不管Promise状态如何都会执行，该方法的回调函数不接受任何参数\\n- 6、Promise.all()方法将多个多个Promise实例，包装成一个新的Promise实例，该方法接受一个由Promise对象组成的数组作为参数(Promise.all()方法的参数可以不是数组，但必须具有Iterator接口，且返回的每个成员都是Promise实例)，注意参数中只要有一个实例触发catch方法，都会触发Promise.all()方法返回的新的实例的catch方法，如果参数中的某个实例本身调用了catch方法，将不会触发Promise.all()方法返回的新实例的catch方法\\n- 7、Promise.race()方法的参数与Promise.all方法一样，参数中的实例只要有一个率先改变状态就会将该实例的状态传给Promise.race()方法，并将返回值作为Promise.race()方法产生的Promise实例的返回值\\n- 8、Promise.resolve()将现有对象转为Promise对象，如果该方法的参数为一个Promise对象，Promise.resolve()将不做任何处理；如果参数thenable对象(即具有then方法)，Promise.resolve()将该对象转为Promise对象并立即执行then方法；如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为fulfilled，其参数将会作为then方法中onResolved回调函数的参数，如果Promise.resolve方法不带参数，会直接返回一个fulfilled状态的 Promise 对象。需要注意的是，立即resolve()的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时。\\n- 9、Promise.reject()同样返回一个新的Promise对象，状态为rejected，无论传入任何参数都将作为reject()的参数\\n\\n\\n2）Promise优点\\n\\n- ①统一异步 API\\n  - Promise 的一个重要优点是它将逐渐被用作浏览器的异步 API ，统一现在各种各样的 API ，以及不兼容的模式和手法。\\n- ②Promise 与事件对比\\n  - 和事件相比较， Promise 更适合处理一次性的结果。在结果计算出来之前或之后注册回调函数都是可以的，都可以拿到正确的值。 Promise 的这个优点很自然。但是，不能使用 Promise 处理多次触发的事件。链式处理是 Promise 的又一优点，但是事件却不能这样链式处理。\\n- ③Promise 与回调对比\\n  - 解决了回调地狱的问题，将异步操作以同步操作的流程表达出来。\\n- ④Promise 带来的额外好处是包含了更好的错误处理方式（包含了异常处理），并且写起来很轻松（因为可以重用一些同步的工具，比如 Array.prototype.map() ）。\\n\\n3）Promise缺点\\n\\n- 1、无法取消Promise，一旦新建它就会立即执行，无法中途取消。\\n- 2、如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。\\n- 3、当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。\\n- 4、Promise 真正执行回调的时候，定义 Promise 那部分实际上已经走完了，所以 Promise 的报错堆栈上下文不太友好。\\n\\n\\n4）简单代码实现\\n最简单的Promise实现有7个主要属性, state(状态), value(成功返回值), reason(错误信息), resolve方法, reject方法, then方法.\\n\\n```js\\nclass Promise{\\n  constructor(executor) {\\n    this.state = \'pending\';\\n    this.value = undefined;\\n    this.reason = undefined;\\n    let resolve = value => {\\n      if (this.state === \'pending\') {\\n        this.state = \'fulfilled\';\\n        this.value = value;\\n      }\\n    };\\n    let reject = reason => {\\n      if (this.state === \'pending\') {\\n        this.state = \'rejected\';\\n        this.reason = reason;\\n      }\\n    };\\n    try {\\n      // 立即执行函数\\n      executor(resolve, reject);\\n    } catch (err) {\\n      reject(err);\\n    }\\n  }\\n  then(onFulfilled, onRejected) {\\n    if (this.state === \'fulfilled\') {\\n      let x = onFulfilled(this.value);\\n    };\\n    if (this.state === \'rejected\') {\\n      let x = onRejected(this.reason);\\n    };\\n  }\\n}\\n```\\n\\n5）面试够用版\\n\\n```js\\nfunction myPromise(constructor){ let self=this;\\n  self.status=\\"pending\\" //定义状态改变前的初始状态 \\n  self.value=undefined;//定义状态为resolved的时候的状态 \\n  self.reason=undefined;//定义状态为rejected的时候的状态 \\n  function resolve(value){\\n    //两个===\\"pending\\"，保证了了状态的改变是不不可逆的 \\n    if(self.status===\\"pending\\"){\\n      self.value=value;\\n      self.status=\\"resolved\\"; \\n    }\\n  }\\n  function reject(reason){\\n     //两个===\\"pending\\"，保证了了状态的改变是不不可逆的\\n     if(self.status===\\"pending\\"){\\n        self.reason=reason;\\n        self.status=\\"rejected\\"; \\n      }\\n  }\\n  //捕获构造异常 \\n  try{\\n      constructor(resolve,reject);\\n  }catch(e){\\n    reject(e);\\n    } \\n}\\nmyPromise.prototype.then=function(onFullfilled,onRejected){ \\n  let self=this;\\n  switch(self.status){\\n    case \\"resolved\\": onFullfilled(self.value); break;\\n    case \\"rejected\\": onRejected(self.reason); break;\\n    default: \\n  }\\n}\\n\\n// 测试\\nvar p=new myPromise(function(resolve,reject){resolve(1)}); \\np.then(function(x){console.log(x)})\\n//输出1\\n```\\n\\n6）大厂专供版\\n\\n```js\\nconst PENDING = \\"pending\\"; \\nconst FULFILLED = \\"fulfilled\\"; \\nconst REJECTED = \\"rejected\\";\\nfunction Promise(excutor) {\\n  let that = this; // 缓存当前promise实例例对象\\n  that.status = PENDING; // 初始状态\\n  that.value = undefined; // fulfilled状态时 返回的信息\\n  that.reason = undefined; // rejected状态时 拒绝的原因 \\n  that.onFulfilledCallbacks = []; // 存储fulfilled状态对应的onFulfilled函数\\n  that.onRejectedCallbacks = []; // 存储rejected状态对应的onRejected函数\\n  function resolve(value) { // value成功态时接收的终值\\n    if(value instanceof Promise) {\\n      return value.then(resolve, reject);\\n    }\\n    // 实践中要确保 onFulfilled 和 onRejected ⽅方法异步执⾏行行，且应该在 then ⽅方法被调⽤用的那⼀一轮事件循环之后的新执⾏行行栈中执⾏行行。\\n    setTimeout(() => {\\n      // 调⽤用resolve 回调对应onFulfilled函数\\n      if (that.status === PENDING) {\\n        // 只能由pending状态 => fulfilled状态 (避免调⽤用多次resolve reject)\\n        that.status = FULFILLED;\\n        that.value = value;\\n        that.onFulfilledCallbacks.forEach(cb => cb(that.value));\\n      }\\n    });\\n  }\\n  function reject(reason) { // reason失败态时接收的拒因\\n    setTimeout(() => {\\n      // 调⽤用reject 回调对应onRejected函数\\n      if (that.status === PENDING) {\\n        // 只能由pending状态 => rejected状态 (避免调⽤用多次resolve reject)\\n        that.status = REJECTED;\\n        that.reason = reason;\\n        that.onRejectedCallbacks.forEach(cb => cb(that.reason));\\n      }\\n    });\\n  }\\n\\n  // 捕获在excutor执⾏行行器器中抛出的异常\\n  // new Promise((resolve, reject) => {\\n  //     throw new Error(\'error in excutor\')\\n  // })\\n  try {\\n    excutor(resolve, reject);\\n  } catch (e) {\\n    reject(e);\\n  }\\n}\\nPromise.prototype.then = function(onFulfilled, onRejected) {\\n  const that = this;\\n  let newPromise;\\n  // 处理理参数默认值 保证参数后续能够继续执⾏行行\\n  onFulfilled = typeof onFulfilled === \\"function\\" ? onFulfilled : value => value;\\n  onRejected = typeof onRejected === \\"function\\" ? onRejected : reason => {\\n    throw reason;\\n  };\\n  if (that.status === FULFILLED) { // 成功态\\n    return newPromise = new Promise((resolve, reject) => {\\n      setTimeout(() => {\\n        try{\\n          let x = onFulfilled(that.value);\\n          resolvePromise(newPromise, x, resolve, reject); //新的promise resolve 上⼀一个onFulfilled的返回值\\n        } catch(e) {\\n          reject(e); // 捕获前⾯面onFulfilled中抛出的异常then(onFulfilled, onRejected);\\n        }\\n      });\\n    })\\n  }\\n  if (that.status === REJECTED) { // 失败态\\n    return newPromise = new Promise((resolve, reject) => {\\n      setTimeout(() => {\\n        try {\\n          let x = onRejected(that.reason);\\n          resolvePromise(newPromise, x, resolve, reject);\\n        } catch(e) {\\n          reject(e);\\n        }\\n      });\\n    });\\n  }\\n  if (that.status === PENDING) { // 等待态\\n// 当异步调⽤用resolve/rejected时 将onFulfilled/onRejected收集暂存到集合中\\n    return newPromise = new Promise((resolve, reject) => {\\n      that.onFulfilledCallbacks.push((value) => {\\n        try {\\n          let x = onFulfilled(value);\\n          resolvePromise(newPromise, x, resolve, reject);\\n        } catch(e) {\\n          reject(e);\\n        }\\n      });\\n      that.onRejectedCallbacks.push((reason) => {\\n        try {\\n          let x = onRejected(reason);\\n          resolvePromise(newPromise, x, resolve, reject);\\n        } catch(e) {\\n          reject(e);\\n        }\\n      });\\n    });\\n  }\\n};\\n```","answer":"","biz_type":1,"qid":23,"subject":"","title":"介绍下 promise 的特性、优缺点，内部是如何实现的，动手实现 Promise"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["滴滴","头条","有赞","微医"],"date":"Fri, 19 Jun 2020 16:21:40 GMT","favorite_num":16,"qid":24,"qtype":"short_answer","short_answer":{"analysis":"**1) 核心思路**\\n\\n- ①接收一个 Promise 实例的数组或具有 Iterator 接口的对象作为参数\\n- ②这个方法返回一个新的 promise 对象，\\n- ③遍历传入的参数，用Promise.resolve()将参数\\"包一层\\"，使其变成一个promise对象\\n- ④参数所有回调成功才是成功，返回值数组与参数顺序一致\\n- ⑤参数数组其中一个失败，则触发失败状态，第一个触发失败的 Promise 错误信息作为 Promise.all 的错误信息。\\n\\n**2）实现代码**\\n一般来说，Promise.all 用来处理多个并发请求，也是为了页面数据构造的方便，将一个页面所用到的在不同接口的数据一起请求过来，不过，如果其中一个接口失败了，多个请求也就失败了，页面可能啥也出不来，这就看当前页面的耦合程度了～\\n\\n```js\\nfunction promiseAll(promises) {\\n  return new Promise(function(resolve, reject) {\\n    if(!Array.isArray(promises)){\\n        throw new TypeError(`argument must be a array`)\\n    }\\n    var resolvedCounter = 0;\\n    var promiseNum = promises.length;\\n    var resolvedResult = [];\\n    for (let i = 0; i < promiseNum; i++) {\\n      Promise.resolve(promises[i]).then(value=>{\\n        resolvedCounter++;\\n        resolvedResult[i] = value;\\n        if (resolvedCounter == promiseNum) {\\n            return resolve(resolvedResult)\\n          }\\n      },error=>{\\n        return reject(error)\\n      })\\n    }\\n  })\\n}\\n\\n// test\\nlet p1 = new Promise(function (resolve, reject) {\\n    setTimeout(function () {\\n        resolve(1)\\n    }, 1000)\\n})\\nlet p2 = new Promise(function (resolve, reject) {\\n    setTimeout(function () {\\n        resolve(2)\\n    }, 2000)\\n})\\nlet p3 = new Promise(function (resolve, reject) {\\n    setTimeout(function () {\\n        resolve(3)\\n    }, 3000)\\n})\\npromiseAll([p3, p1, p2]).then(res => {\\n    console.log(res) // [3, 1, 2]\\n})\\n```","answer":"","biz_type":1,"qid":24,"subject":"```js\\nPromise.all = function (arr) {\\n  // 实现代码\\n};\\n```\\n","title":"实现 Promise.all"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["爱范儿","道一云"],"date":"Fri, 19 Jun 2020 16:20:44 GMT","favorite_num":8,"qid":697,"qtype":"short_answer","short_answer":{"analysis":"#### 代码实现\\n\\n```js\\n// 直接实现\\ndocument.onclick = function(e){\\n    let e = e || window.event;//处理兼容，获取事件的对象\\n    let o = e[\\"target\\"] || e[\\"srcElement\\"];//处理兼容，获取事件目标\\n    alert(o.tagName.toLowerCase()); \\n}\\n\\n// 优雅实现\\nfunction elementName(evt) {\\n  evt = evt || window.event;\\n  var selected = evt.target || evt.srcElement;\\n  var eleName =\\n      selected && selected.tagName\\n  ? selected.tagName.toLowerCase()\\n  : \\"no tagName\\";\\n  alert(eleName);\\n}\\n\\nwindow.onload = function() {\\n  var el = document.getElementsByTagName(\\"body\\");\\n  el[0].onclick = elementName;\\n};\\n```","answer":"","biz_type":1,"qid":697,"subject":"","title":"请实现鼠标点击页面中的任意标签，alert 该标签的名称(注意兼容性)"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["爱范儿"],"date":"Fri, 19 Jun 2020 16:20:44 GMT","favorite_num":8,"qid":699,"qtype":"short_answer","short_answer":{"analysis":"#### Object.create()\\n\\n- Object.create()方法使用指定的原型对象和其属性创建了一个新的对象。\\n- Object.create(proto,[propertiesObject])\\n- Object.create方法创建一个空对象，然后将空对象的__proto__ = proto，如果还有propertiesObject参数的话，就进行object.assign类似的操作，把属性赋上去。\\n\\n#### 代码实现\\n\\n**1）简单粗暴**\\n\\n```js\\n// create 创建一个对象，使其 __proto__ 指向传入的原型\\nfuction creat(obj){\\n  // 创建一个空的构造函数\\n  function F(){}\\n  // 将构造函数的 prototype 指向传入的对象\\n  F.prototype = obj\\n  // 返回新构造函数的实例\\n  retrun new F()\\n}\\n```\\n\\n**2）实现propertiesObject参数**\\n\\n```js\\nObject.create = function (prototype, properties) {\\n    if (typeof prototype !== \\"object\\") { \\n        throw TypeError(); }\\n    function Ctor() {}\\n    Ctor.prototype = prototype;\\n    var o = new Ctor();\\n    if (prototype) { \\n        o.constructor = Ctor; \\n    }\\n    if (properties !== undefined) {\\n      if (properties !== Object(properties)) { \\n          throw TypeError(); \\n       }\\n      Object.defineProperties(o, properties);\\n    }\\n    return o;\\n};\\n```","answer":"","biz_type":1,"qid":699,"subject":"","title":"原生实现 ES5 的 Object.create()方法"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["爱范儿"],"date":"Fri, 19 Jun 2020 16:20:44 GMT","favorite_num":30,"qid":703,"qtype":"short_answer","short_answer":{"analysis":"#### 1.原生方式实现\\n\\n- **html**\\n\\n```html\\n<body>\\n    <button id=\\"expire1\\">过期设置(暴力法)</button>\\n    <button id=\\"expire2\\">过期设置(innerHTMl)</button>\\n    <ul id=\\"wrap\\"></ul>\\n</body>\\n```\\n\\n- **JavaScript**\\n\\n```js\\n//生成大量dom \\nlet start = new Date().getTime()\\nlet $ul = document.getElementById(\\"wrap\\");\\n\\nlet el = document.createDocumentFragment()\\nlet allKeys = []\\nfor(var i = 0; i < 1000; i++){\\n    let li = document.createElement(\'li\');\\n    li.dataset.key = i  //key\\n    li.innerHTML = i\\n    el.appendChild(li)\\n    allKeys.push(i)\\n}\\n$ul.appendChild(el)\\n\\n\\n// 生成过期项 模拟服务端生成的数据\\nfunction getExpireKeys(){\\n    let keys = []\\n    while(keys.length < 100){\\n    let randomKey = Math.floor(Math.random() * 1000)\\n    if(keys.indexOf(randomKey) === -1){\\n        keys.push(randomKey)\\n    }else{\\n        continue\\n    }\\n    }\\n    return keys\\n}\\n\\n// 暴力项 逐项遍历\\ndocument.getElementById(\'expire1\').onclick = function(){\\n    let expireKeys = getExpireKeys()\\n    let children = $ul.children;\\n    let start = Date.now()\\n    for (let i = 0; i < expireKeys.length; i++) {\\n    const element = document.querySelector(`[data-key=\\"${expireKeys[i]}\\"]`);\\n    element.innerHTML = element.innerHTML + \'已过期\'\\n    }\\n}\\n\\n//模板字符串 innerHtml替换\\ndocument.getElementById(\'expire2\').onclick = function(){\\n    let expireKeys = getExpireKeys()\\n    const item = []\\n    for (let i = 0; i < allKeys.length; i++) {\\n    item.push( `<li>${allKeys[i]} ${expireKeys.indexOf(allKeys[i]) !== -1 ? \'已过期\' : \'\'}</li>`)\\n    }\\n    $ul.innerHTML = item.join(\'\')\\n}\\n```\\n\\n#### 2.Vue方式处理\\n\\n```js\\n// template\\n<button @click=setExpire>过期</button>\\n<ul>\\n  <li v-for=\\"item in allKeys\\" :key=\\"item.value\\">\\n    {{item.value}}\\n    {{item.expire ? \'已过期\' : \'\'}}\\n  </li>\\n</ul>\\n\\n// script\\n<script>\\nexport default {\\n  data() {\\n    return {\\n      allKeys: [],  //所有项\\n      expireKeys: []  //过期项\\n    }\\n  },\\n  created(){\\n    for(var i = 0; i < 1000; i++){\\n      this.allKeys.push({\\n        value: i,\\n        expire: false\\n      })\\n    }\\n  },\\n  methods: {\\n    setExpire(){\\n      let keys = this.getExpireKeys()\\n      for (let i = 0; i < this.allKeys.length; i++) {\\n        if(keys.indexOf(this.allKeys[i].value) !== -1){\\n          this.allKeys[i].expire = true\\n        }\\n      }\\n    },\\n    // 生成过期项 模拟服务端生成的数据\\n    getExpireKeys(){\\n      let keys = []\\n      while(keys.length < 100){\\n        let randomKey = Math.floor(Math.random() * 1000)\\n        if(keys.indexOf(randomKey) === -1){\\n          keys.push(randomKey)\\n        }else{\\n          continue\\n        }\\n      }\\n      return keys\\n    }\\n  },\\n}\\n<\/script>\\n```\\n","answer":"","biz_type":1,"qid":703,"subject":"```js\\n/* \\n  a)在不使用vue、react的前提下写代码解决一下问题\\n    一个List页面上，含有1000个条目的待办列表，现其中100项在同一时间达到了过期时间，需要在对应项的text-node里添加“已过期”文字。需要尽可能减少dom重绘次数以提升性能。\\n  b)尝试使用vue或react解决上述问题\\n*/\\n```\\n","title":"按要求完成题目"},"tech_tag":["JavaScript","Vue","React","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["新东方"],"date":"Fri, 19 Jun 2020 16:20:44 GMT","favorite_num":9,"qid":750,"qtype":"short_answer","short_answer":{"analysis":"### 代码实现\\n\\n#### 1.实现方式一\\n\\n- 装饰器写法\\n\\n```js\\nconst myDecorator = (fn, execute, obj=window) => {\\n        let old = obj[fn]\\n         obj[fn] = function() {\\n            return execute(old.bind(obj))\\n        }\\n  }\\n \\n  function A() {\\n         console.log(\'调用函数A\')\\n  }\\n         \\n  myDecorator(\'A\', (fn) => {\\n         fn()\\n         console.log(\'hello world\')\\n  })\\n  A();\\n```\\n\\n#### 2.实现方式二\\n\\n- 添加原型方法\\n\\n```js\\nFunction.prototype.before = function (beforeFN) {\\n    var _self = this;\\n    return function () {\\n        beforeFN.apply(_self, arguments)\\n        return _self.apply(this, arguments)\\n    }\\n}\\n\\nFunction.prototype.after = function (afterFN) {\\n    var _self = this;\\n    return function () {\\n        var fn = _self.apply(this, arguments);\\n        afterFN.apply(_self, arguments)\\n        return fn\\n    }\\n}\\n\\nvar A = function () {\\n    console.warn(\\"调用了函数A\\")\\n}\\n\\nA = A.before(function () {\\n    console.warn(\\"前置钩子 HelloWorld\\")\\n}).after(function () {\\n    console.warn(\\"后置钩子 HelloWorld\\")\\n})\\n\\nA()\\n```\\n\\n#### 3.实现方式三\\n\\n- 粗暴直接\\n\\n```js\\nfunction A() {\\n    console.log(\'调用了函数A\');\\n}\\nconst nativeA = A;\\nA = function () {\\n    console.log(\'HelloWorld\');\\n    nativeA();\\n}\\nA()\\n```\\n\\n","answer":"","biz_type":1,"qid":750,"subject":"```js\\nfunction A() {\\n  console.log(\\"调用了函数A\\");\\n}\\n```\\n","title":"有这样一个函数 A,要求在不改变原有函数 A 功能以及调用方式的情况下，使得每次调用该函数都能在控制台打印出“HelloWorld”"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["玄武科技"],"date":"Fri, 19 Jun 2020 16:20:44 GMT","favorite_num":8,"qid":719,"qtype":"short_answer","short_answer":{"analysis":"### 一、概念理解\\n\\n#### 1.什么是事件代理\\n\\n事件委托或事件代理：根据《js高级程序设计》一书（前端红宝书）来说就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有时间。举一个栗子：dom需要事件处理程序，我们都会直接给它设置事件处理程序。but，如果有在ul中全部100个li需要添加事件处理程序，其具有相同的点击事件，那么可以根据for来进行遍历，也可以根据上层的ul来进行添加。在性能的角度来看，把ul建立事件会减少dom的交互次数，提高性能。\\n\\n#### 2.事件代理原理\\n\\n事件委托是利用事件的冒泡原理来实现的，就是事件从最深的节点开始，然后逐步向上传播事件。\\n\\n举个例子：页面上有这么一个节点树，div>ul>li>a;比如给最里面的a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a>li>ul>div，有这样一个机制，那么我们给最外面的div加点击事件，那么里面的ul，li，a做点击事件的时候，都会冒泡到最外层的div上，所以都会触发，这就是事件委托，委托它们父级代为执行事件。\\n\\n\\n### 二、代码实现\\n\\n#### 1.比如实现ul中li的事件代理\\n\\n```js\\nwindow.onload = function () {\\n    var oBtn = document.getElementById(\\"btn\\");\\n    var oUl = document.getElementById(\\"ul1\\");\\n    var aLi = oUl.getElementsByTagName(\'li\');\\n    var num = 4;\\n    //事件委托，添加的子元素也有事件 \\n    oUl.onmouseover = function (ev) {\\n      var ev = ev || window.event;\\n      var target = ev.target || ev.srcElement;\\n      if (target.nodeName.toLowerCase() == \'li\') {\\n        target.style.background = \\"red\\";\\n      }\\n    };\\n    oUl.onmouseout = function (ev) {\\n      var ev = ev || window.event;\\n      var target = ev.target || ev.srcElement;\\n      if (target.nodeName.toLowerCase() == \'li\') {\\n        target.style.background = \\"#fff\\";\\n      }\\n    };\\n    //添加新节点 \\n    oBtn.onclick = function () {\\n      num++;\\n      var oLi = document.createElement(\'li\');\\n      oLi.innerHTML = 111 * num;\\n      oUl.appendChild(oLi);\\n    };\\n}\\n}\\n```\\n\\n\\n#### 2.简单封装一个事件代理通用代码\\n\\n```js\\n!function (root, doc) {\\n  class Delegator {\\n    constructor (selector) {\\n      this.root = document.querySelector(selector);//父级dom\\n      this.delegatorEvents = {};//代理元素及事件\\n      //代理逻辑\\n      this.delegator = e => {        \\n        let currentNode = e.target;//目标节点\\n        const targetEventList = this.delegatorEvents[e.type];\\n        //如果当前目标节点等于事件当前所在的节点，不再向上冒泡\\n        while (currentNode !== e.currentTarget) {\\n          targetEventList.forEach(target => {\\n            if (currentNode.matches(target.matcher)) {\\n              //开始委托并把当前目标节点的event对象传过去\\n              target.callback.call(currentNode, e);\\n            }\\n          })\\n          currentNode = currentNode.parentNode;\\n        }\\n      }\\n    }\\n    /*\\n     *绑定事件\\n     *@param event 绑定事件类型\\n     *@param selector 需要被代理的选择器\\n     *@param fn 触发函数\\n     * */\\n    on (event, selector, fn) {\\n     //相同事件只添加一次，如果存在，则再对应的代理事件里添加\\n      if (!this.delegatorEvents[event]) {\\n        this.delegatorEvents[event] = [{\\n          matcher: selector,\\n          callback: fn\\n        }]\\n        this.root.addEventListener(event, this.delegator);\\n      }else{\\n        this.delegatorEvents[event].push({\\n          matcher: selector,\\n          callback: fn\\n        })\\n      }\\n      return this;\\n    }\\n    /*\\n     *移除事件\\n     */\\n    destroy () {\\n      Object.keys(this.delegatorEvents).forEach(eventName => {\\n        this.root.removeEventListener(eventName, this.delegator)\\n      });\\n    }\\n  }\\n\\n  root.Delegator = Delegator\\n}(window, document)\\n```","answer":"","biz_type":1,"qid":719,"subject":"","title":"请用 JavaScript 代码实现事件代理"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["爱范儿"],"date":"Fri, 19 Jun 2020 16:20:44 GMT","favorite_num":9,"qid":698,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":698,"subject":"","title":"完成一个表达式，验证用户输入是否是电子邮箱"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["网易"],"date":"Fri, 19 Jun 2020 16:20:44 GMT","favorite_num":9,"qid":707,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":707,"subject":"```js\\nvar str = \\"您好，<%=name%>。欢迎来到<%=location%>\\";\\nfunction template(str) {\\n  // your code\\n}\\nvar compiled = template(srt);\\n// compiled的输出值为：“您好，张三。欢迎来到网易游戏”\\ncompiled({ name: \\"张三\\", location: \\"网易游戏\\" });\\n```\\n","title":"填充代码实现 template 方法"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["亚美科技"],"date":"Fri, 19 Jun 2020 16:20:44 GMT","favorite_num":8,"qid":720,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":720,"subject":"","title":"实现格式化输出，比如输入 999999999，输出 999,999,999"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["亚美科技"],"date":"Fri, 19 Jun 2020 16:20:44 GMT","favorite_num":8,"qid":721,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":721,"subject":"","title":"使用 JavaScript 实现 cookie 的设置、读取、删除"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["亚美科技"],"date":"Fri, 19 Jun 2020 16:20:44 GMT","favorite_num":8,"qid":722,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":722,"subject":"","title":"请编写一个 JavaScript 函数 parseQueryString,它的用途是把 URL 参数解析为一个对象，url=\\"http://iauto360.cn/index.php?key0=0&key1=1&key2=2\\""},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["高思教育"],"date":"Fri, 19 Jun 2020 16:20:44 GMT","favorite_num":8,"qid":728,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":728,"subject":"","title":"给 JavaScript 的 String 原生对象添加一个名为 trim 的原型方法，用于截取字符串前后的空白字符"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["快手"],"date":"Fri, 19 Jun 2020 16:20:44 GMT","favorite_num":8,"qid":749,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":749,"subject":"","title":"用 typescript 实现函数 caller，接收一个函数作为第一个参数，其返回参数类型由接收的函数参数决定"},"tech_tag":["其它","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":[],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":8,"qid":582,"qtype":"short_answer","short_answer":{"analysis":"#### 1.原生js实现\\n\\n拖拽需要三大事件：\\n\\n- mousedown  鼠标摁下触发\\n- mousemove  鼠标移动触发\\n- mouseup    鼠标抬起触发\\n\\n```html\\n<!DOCTYPE html>\\n<html lang=\\"en\\">\\n<head>\\n  <meta charset=\\"UTF-8\\">\\n  <meta name=\\"viewport\\" content=\\"width=device-width, initial-scale=1.0\\">\\n  <title>手动实现拖拽</title>\\n</head>\\n<style>\\n  .move {\\n    position: absolute;\\n    width: 100px;\\n    height: 100px;\\n    background: gray\\n  }\\n</style>\\n\\n<body>\\n  <div class=\\"move-container\\">\\n    <div class=\\"move\\">\\n    </div>\\n  </div>\\n  <script>\\n    let elem = document.querySelector(\'.move\');\\n    let dragging; //拖拽状态\\n    let trans, portrait; //鼠标按下时相对于选中元素的位移\\n\\n    document.addEventListener(\'mousedown\', function (e) {\\n      if (e.target == elem) {\\n        dragging = true; //激活拖拽状态\\n        let elemRect = elem.getBoundingClientRect(); //返回元素的大小及其相对于视口的位置\\n        trans = e.clientX - elemRect.left; //鼠标按下时和选中元素的坐标偏移:x坐标\\n        portrait = e.clientY - elemRect.top; //鼠标按下时和选中元素的坐标偏移:y坐标\\n      }\\n    });\\n    document.addEventListener(\'mouseup\', function (e) {\\n      dragging = false;\\n    });\\n    document.addEventListener(\'mousemove\', function (e) {\\n      if (dragging) {\\n        var moveX = e.clientX - trans,\\n          moveY = e.clientY - portrait;\\n\\n        elem.style.left = moveX + \'px\';\\n        elem.style.top = moveY + \'px\';\\n\\n      }\\n    });\\n  <\/script>\\n</body>\\n</html>\\n```\\n\\n#### 2.HTML5原⽣ 拖拽draggable属性以及DataTranfers对象\\n\\n![流程图](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-582-process.png)\\n\\n```html\\n<!DOCTYPE html>\\n<html lang=\\"en\\">\\n<head>\\n  <meta charset=\\"UTF-8\\">\\n  <meta name=\\"viewport\\" content=\\"width=device-width, initial-scale=1.0\\">\\n  <title>手动实现拖拽</title>\\n</head>\\n<style>\\n  .main {\\n    display: flex;\\n    justify-content: space-around;\\n  }\\n\\n  .left {\\n    width: 300px;\\n    height: 500px;\\n    margin-right: 10px;\\n    border: 1px solid red;\\n    text-align: center;\\n    box-sizing: border-box;\\n    padding: 1pxx\\n  }\\n\\n  .right {\\n    width: 300px;\\n    height: 500px;\\n    border: 1px solid lightseagreen;\\n    text-align: center;\\n    box-sizing: border-box;\\n    padding: 1px;\\n  }\\n\\n  .txt {\\n    border: 1px solid gray;\\n    margin: 1px;\\n    padding: 5px;\\n    cursor: move;\\n  }\\n</style>\\n\\n<body>\\n  <main class=\\"main\\">\\n    <div class=\\"left\\" id=\\"left\\">\\n      <div class=\\"txt-show\\">左边区域</div>\\n      <div id=\'txt1\' draggable=\\"true\\" class=\\"dragable txt txt1\\">可移动的文字一</div>\\n      <div id=\'txt2\' draggable=\\"true\\" class=\\"dragable txt txt2\\">可移动的文字二</div>\\n      <div id=\'txt3\' draggable=\\"true\\" class=\\"dragable txt txt3\\">可移动的文字三</div>\\n      <div id=\'txt4\' draggable=\\"true\\" class=\\"dragable txt txt4\\">可移动的文字四</div>\\n      <div id=\'txt5\' draggable=\\"true\\" class=\\"dragable txt txt5\\">可移动的文字五</div>\\n    </div>\\n    <div class=\\"right\\" id=\'right\'>\\n      <div class=\\"txt-show\\">右边区域</div>\\n    </div>\\n  </main>\\n\\n  <script>\\n    let txtObj = document.getElementsByClassName(\'txt\')\\n    for (let i = 0; i < txtObj.length; i++) {\\n      txtObj[i].ondragstart = handle_start\\n      txtObj[i].ondrag = handle_drag\\n      txtObj[i].ondragend = handle_end\\n    }\\n\\n    function handle_start(e) {\\n      e.dataTransfer.setData(\'Text\', e.target.id)\\n      console.log(\'handle_start-拖动开始\')\\n    }\\n\\n    function handle_drag(e) {\\n      console.log(\'handle_drag-拖动中\')\\n    }\\n\\n    function handle_end(e) {\\n      console.log(\'handle_end-拖动结束\')\\n    }\\n    let target = document.getElementById(\'right\')\\n    target.ondragenter = handle_enter\\n    target.ondragover = handle_over\\n    target.ondragleave = handle_leave\\n    target.ondrop = handle_drop\\n\\n    function handle_enter(e) {\\n      e.preventDefault()\\n      console.log(\'handle_enter-进入目的地\')\\n    }\\n\\n    function handle_over(e) {\\n      e.preventDefault()\\n      let returnObj = e.dataTransfer.getData(\'Text\')\\n      console.log(returnObj + \'-handle_over-在目的地范围内\')\\n    }\\n\\n    function handle_leave(e) {\\n      e.preventDefault()\\n      let returnObj = e.dataTransfer.getData(\'Text\')\\n      console.log(returnObj)\\n      console.log(\'handle_leave-没有放下就离开目的地\')\\n    }\\n\\n    function handle_drop(e) {\\n      e.stopPropagation(); // 不再派发事件。解决Firefox浏览器，打开新窗口的问题。\\n      e.preventDefault()\\n      let returnObj = e.dataTransfer.getData(\'Text\')\\n      if (returnObj) {\\n        e.target.appendChild(document.getElementById(returnObj))\\n      }\\n      console.log(returnObj + \'-handle_drop-在目的地区释放\')\\n    }\\n  <\/script>\\n</body>\\n\\n</html>\\n```","answer":"","biz_type":1,"qid":582,"subject":"","title":"请手写实现一个拖拽"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":[],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":8,"qid":568,"qtype":"short_answer","short_answer":{"analysis":"### 实现方案\\n\\n#### 1.实现方式一\\n\\n```js\\n//通过标签语句,跳出无限循环：\\nloop1:\\nwhile(1){\\n switch (\'yideng\'){\\n  case \'yideng\': break loop1;\\n }\\n}\\n```\\n\\n#### 2.实现方式二\\n\\n```js\\ntry{\\n    while (1) {\\n       switch(\\"yideng\\"){\\n           case \\"yideng\\" :\\n           \\t\\tconsole.log(true);\\n           \\t\\tthrow new Error(\\"跳出循环\\");\\n        }  \\n    }\\n} catch(e){\\n    console.log(e);\\n}\\n```\\n\\n#### 3.实现方式三\\n\\n```js\\n//javascript goto实现 \\nout:\\nfor(let i =0;i<1;i++){\\n\\twhile (1) {\\n    switch (\\"yideng\\") {\\n      case \\"yideng\\":\\n        console.log(\\"yideng\\");\\n        continue out\\n    }\\n\\t}\\n}\\n```\\n\\n#### 4.实现方式四\\n\\n```js\\n//return\\nfunction test(){\\n  while (1) {\\n    switch (\\"yideng\\") {\\n      case \\"yideng\\":\\n        console.log(\\"yideng\\");\\n        return;\\n    }\\n  }\\n}\\ntest();\\n```\\n\\n\\n","answer":"","biz_type":1,"qid":568,"subject":"```js\\nwhile (1) {\\n  switch (\\"yideng\\") {\\n    case \\"yideng\\":\\n    //禁止直接写一句break\\n  }\\n}\\n```\\n","title":"请修改代码能跳出死循环"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":[],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":9,"qid":555,"qtype":"short_answer","short_answer":{"analysis":"### 代码实现\\n\\n```js\\nclass PersonGenerator {\\n  taskQueue = [];\\n  constructor(name) {\\n    this.taskQueue.push(() => this.sayHi(name));\\n    this.runTaskQueue();\\n  }\\n  nextTask = () => {\\n    if (this.taskQueue.length > 0) {\\n      const task = this.taskQueue.shift();\\n      if (typeof task === \\"function\\") {\\n        task();\\n        this.nextTask();\\n      }\\n      if (typeof task === \\"number\\") {\\n        console.log(`Sleep ${task} seconds \\\\n`);\\n        setTimeout(() => this.nextTask(), task * 1000);\\n      }\\n    }\\n  };\\n\\n  runTaskQueue = () => {\\n    setTimeout(() => this.nextTask());\\n  };\\n\\n  sayHi(name) {\\n    console.log(`Hi! This is ${name}! \\\\n`);\\n    return this;\\n  }\\n\\n  sleep(seconds) {\\n    this.taskQueue.push(seconds);\\n    return this;\\n  }\\n\\n  sleepFirst(seconds) {\\n    this.taskQueue.splice(-1, 0, seconds);\\n    return this;\\n  }\\n\\n  eat(food) {\\n    this.taskQueue.push(() => console.log(`Eat ${food}~ \\\\n`));\\n    return this;\\n  }\\n}\\n\\nconst Person = name => new PersonGenerator(name);\\n\\nPerson(\\"helloWorld\\").sleepFirst(3).sleep(3).eat(\\"little_cute\\");\\n```","answer":"","biz_type":1,"qid":555,"subject":"```js\\nPerson(\\"Li\\");\\n// 输出： Hi! This is Li!\\n\\nPerson(\\"Dan\\").sleep(10).eat(\\"dinner\\");\\n// 输出：\\n// Hi! This is Dan!\\n// 等待10秒..\\n// Wake up after 10\\n// Eat dinner~\\n\\nPerson(\\"Jerry\\").eat(\\"dinner\\").eat(\\"supper\\");\\n// 输出：\\n// Hi This is Jerry!\\n// Eat dinner~\\n// Eat supper~\\n\\nPerson(\\"Smith\\").sleepFirst(5).eat(\\"supper\\");\\n// 输出：\\n// 等待5秒\\n// Wake up after 5\\n// Hi This is Smith!\\n// Eat supper\\n```\\n","title":"按照调用实例，实现下面的 Person 方法"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["阿里"],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":8,"qid":565,"qtype":"short_answer","short_answer":{"analysis":"### 代码实现\\n\\n#### 1.实现方式一\\n\\n```js\\n// es6 串行\\nconst mergePromise = (ajaxArray) => {\\n  return (async function () {\\n      let ret = []\\n      let idx = 0\\n      let len = ajaxArray.length\\n      while(idx < len) {\\n          let data = await ajaxArray[idx]()\\n          ret.push(data)\\n          idx++\\n      }\\n      return ret\\n  })()\\n}\\n\\nmergePromise([ajax1, ajax2, ajax3]).then(data => {\\n  console.log(\'done\')\\n  console.log(data)\\n})\\n```\\n\\n#### 2.实现方式二\\n\\n```js\\n// 串行\\nconst mergePromise = (ajaxArray) => {\\n  return new Promise((resolve, reject) => {\\n    let tem = []\\n    let promise = ajaxArray.map(ajax => () => ajax().then(data => tem.push(data)))\\n      .reduce((memo, cur) => {\\n        return () => {\\n          return memo().then(cur)\\n        }\\n      })\\n    promise().then(() => {\\n      resolve(tem)\\n    })\\n  })\\n}\\n\\nmergePromise([ajax1, ajax2, ajax3]).then(data => {\\n  console.log(\'done\')\\n  console.log(data)\\n})\\n```\\n\\n#### 3.实现方式三\\n\\n```js\\nconst mergePromise = (ajaxArray) => {\\n  //串行\\n  return new Promise((resolve, reject) => {\\n      let len = ajaxArray.length\\n      let idx = 0\\n      let tem = []\\n      function next() {\\n          if (idx === len) return resolve(tem)\\n          ajaxArray[idx]().then((data) => {\\n              tem.push(data)\\n              idx++\\n              next()\\n          }).catch(reject)\\n      }\\n      next()\\n  })\\n}\\n\\nmergePromise([ajax1, ajax2, ajax3]).then(data => {\\n  console.log(\'done\')\\n  console.log(data)\\n})\\n```\\n\\n#### 4.实现方式四\\n\\n```js\\nfunction mergePromise(promiselist) {\\n  var result = []\\n  mergePromise.then = function (callback) {\\n    function fn(i) {\\n      // console.log(promiselist[i]())\\n      promiselist[i]().then((data) => {\\n        result.push(data)\\n        if (i !== promiselist.length - 1) {\\n          fn(++i)\\n        }\\n        if (result.length === promiselist.length) {\\n          callback(result)\\n        }\\n      })\\n    }\\n    fn(0)\\n  }\\n  return mergePromise\\n}\\nmergePromise([ajax1, ajax2, ajax3]).then((data) => {\\n  console.log(\'done\')\\n  console.log(data) // data 为[1,2,3]\\n})\\n// 执行结果为：1 2 3 done [1,2,3]\\n```\\n","answer":"","biz_type":1,"qid":565,"subject":"```js\\nconst timeout = (ms) =>\\n  new Promise((resolve, reject) => {\\n    setTimeout(() => {\\n      resolve();\\n    }, ms);\\n  });\\nconst ajax1 = () =>\\n  timeout(2000).then(() => {\\n    console.log(\\"1\\");\\n    return 1;\\n  });\\nconst ajax2 = () =>\\n  timeout(1000).then(() => {\\n    console.log(\\"2\\");\\n    return 2;\\n  });\\nconst ajax3 = () =>\\n  timeout(2000).then(() => {\\n    console.log(\\"3\\");\\n    return 3;\\n  });\\nconst mergePromise = (ajaxArray) => {\\n  // 1,2,3 done [1,2,3] 此处写代码 请写出ES6、ES3 2中解法\\n};\\nmergePromise([ajax1, ajax2, ajax3]).then((data) => {\\n  console.log(\\"done\\");\\n  console.log(data); // data 为[1,2,3]\\n});\\n// 执行结果为：1 2 3 done [1,2,3]\\n```\\n","title":"按要求完成代码"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["宝宝树"],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":8,"qid":519,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":519,"subject":"","title":"promise 如何实现 then 处理，动手实现 then"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":[],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":8,"qid":569,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":569,"subject":"```js\\nwhile (1) {\\n  console.log(Math.random());\\n}\\n```\\n","title":"修改代码不造成死循环"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":[],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":8,"qid":583,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":583,"subject":"","title":"请手动实现一个浅拷贝"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":[],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":8,"qid":584,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":584,"subject":"","title":"介绍 instanceof 原理，并手动实现"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":[],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":8,"qid":585,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":585,"subject":"","title":"请实现一个 JSON.stringfy"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":[],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":8,"qid":586,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":586,"subject":"","title":"请实现一个 JSON.parse"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["会小二"],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":8,"qid":609,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":609,"subject":"","title":"JavaScript 中如何模拟实现方法的重载"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["会小二"],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":8,"qid":611,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":611,"subject":"","title":"用 html、css、js 模拟实现一个下拉框，使得下拉框在各个浏览器下的样式和行为完全一致，说出你的设计方案，并且重点说明功能设计时要考虑的因素。"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["会小二"],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":8,"qid":613,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":613,"subject":"```js\\n/* \\n  1.从start至end,每隔100毫秒console.log一个数字，每次数字增幅为1\\n  2.返回的对象中需要包含一个cancel方法，用于停止定时操作\\n  3.第一个数字需要立即输出\\n*/\\n```\\n","title":"实现一个打点计时器"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["会小二"],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":8,"qid":615,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":615,"subject":"","title":"JavaScript 写一个单例模式，可以具体到某一个场景"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":[],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":8,"qid":625,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":625,"subject":"","title":"在一个 ul 里有 10 个 li,实现点击对应的 li,输出对应的下标"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":[],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":8,"qid":626,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":626,"subject":"","title":"分别对以下数组进行去重，1:[1,\'1\',2,\'2\',3]，2:[1,[1,2,3[\'1\',\'2\',\'3\'],4],5,6]"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":[],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":8,"qid":628,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":628,"subject":"","title":"编写一个 Person 类，并创建两个不同的 Person 对象"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":[],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":9,"qid":643,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":643,"subject":"","title":"说一下 let、const 的实现，动手实现一下"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["快手"],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":7,"qid":653,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":653,"subject":"","title":"Css 实现多列等高布局，要求元素实际占用的高度以多列中较高的为准"},"tech_tag":["Css","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["快手"],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":8,"qid":656,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":656,"subject":"","title":"写一个函数打乱一个数组，传入一个数组，返回一个打乱的新数组"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["头条","亚美科技"],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":9,"qid":677,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":677,"subject":"","title":"手写 EventEmitter 实现"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":[],"date":"Fri, 19 Jun 2020 16:20:42 GMT","favorite_num":9,"qid":312,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":312,"subject":"","title":"reduce 函数的功能，如何实现的，动手实现一下"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["兑吧"],"date":"Fri, 19 Jun 2020 16:20:42 GMT","favorite_num":8,"qid":478,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":478,"subject":"","title":"new 的实现原理，动手实现一个 new"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["微软"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":8,"qid":164,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":164,"subject":"","title":"实现一个函数将中文数字转成数字"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["微软"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":8,"qid":165,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":165,"subject":"","title":"节流"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["新东方"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":8,"qid":174,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":174,"subject":"```js\\nfunction A(name) {\\n  this.name = name;\\n}\\nA.prototype.getName = function () {\\n  console.log(this.name);\\n};\\n```\\n","title":"已知函数 A，要求构造⼀个函数 B 继承 A"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["新东方"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":8,"qid":178,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":178,"subject":"```js\\n/*\\n\\t已知对象A = {name: \'sfd\', getName: function(){console.log(this.name)}},\\n\\t现要求⽤不同⽅式对A进⾏改造实现A.name发⽣变化时⽴即执⾏A.getName\\n*/\\n```\\n","title":"要求⽤不同⽅式对 A 进⾏改造实现 A.name 发⽣变化时⽴即执⾏ A.getName"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["新东方"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":8,"qid":179,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":179,"subject":"```js\\nvar arrys = [];\\nfor (var i = 0; i < 10; i++) {\\n  arrys.push(function () {\\n    return i;\\n  });\\n}\\narrys.forEach(function (fn) {\\n  console.log(fn());\\n}); //本⾏不能修改\\n```\\n","title":"修改以下代码，使得最后⼀⾏代码能够输出数字 0-9（最好能给多种答案）"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["头条"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":8,"qid":182,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":182,"subject":"","title":"请给出识别 Email 的正则表达式"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["头条"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":8,"qid":184,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":184,"subject":"```js\\nclass TreeNode{\\n  value:number\\n  left?:TreeNode\\n  right?:TreeNode\\n}\\nfunction getPathSum(root){\\n  // your code\\n}\\n// 例子，一层二叉树如下定义，路径包括1 —> 2 ,1 -> 3\\nconst node = new TreeNode();\\nnode.value = 1;\\nnode.left = new TreeNode();\\nnode.left.value = 2;\\nnode.right = new TreeNode();\\nnode.right.value = 3;\\ngetPathSum(node); // return 7 = (1+2) + (1+3)\\n```\\n","title":"实现函数接受任意二叉树，求二叉树所有根到叶子路径组成的数字之和"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["滴滴"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":8,"qid":188,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":188,"subject":"","title":"Promise 链式调用如何实现"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["高德"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":8,"qid":197,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":197,"subject":"","title":"如何把真实 dom 转变为虚拟 dom，代码实现一下"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["快手"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":8,"qid":213,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":213,"subject":"```js\\nfunction add() {\\n  // your code\\n}\\nfunction one() {\\n  // your code\\n}\\nfunction two() {\\n  // your code\\n}\\nconsole.log(add(one(two()))); //3\\nconsole.log(add(two(one()))); //3\\n```\\n","title":"实现以下代码"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["快手"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":8,"qid":214,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":214,"subject":"","title":"请实现一个 cacheRequest 方法，保证发出多次同一个 ajax 请求时都能拿到数据，而实际上只发出一次请求"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["快手"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":8,"qid":215,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":215,"subject":"","title":"实现一个函数柯里化"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["脉脉"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":8,"qid":232,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":232,"subject":"","title":"用 Promise 封装一个 ajax"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["自如","头条"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":6,"qid":233,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":233,"subject":"","title":"动手实现一个左右固定100px，中间自适应的三列布局？(至少三种)"},"tech_tag":["Css","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["自如"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":8,"qid":239,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":239,"subject":"","title":"请实现`$on,$emit`"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["自如","腾讯应用宝","快手"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":8,"qid":240,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":240,"subject":"","title":"实现 bind 方法，不能使用 call、apply、bind"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["自如"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":8,"qid":241,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":241,"subject":"","title":"手写实现 sleep 函数"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["自如"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":8,"qid":250,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":250,"subject":"","title":"用原生 js 实现自定义事件"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":[],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":8,"qid":251,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":251,"subject":"","title":"换行字符串格式化"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":[],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":6,"qid":252,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":252,"subject":"","title":"屏幕占满和未占满的情况下，使 footer 固定在底部，尽量多种方法"},"tech_tag":["Css","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":[],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":8,"qid":253,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":253,"subject":"","title":"输入一个日期 返回几秒前、几小时前、几天前、几月前"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":[],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":8,"qid":254,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":254,"subject":"","title":"将 153812.7 转化为 153,812.7"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["会小二","高思教育","58"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":6,"qid":257,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":257,"subject":"","title":"Css 画一个三角形"},"tech_tag":["Css","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":[],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":8,"qid":284,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":284,"subject":"```js\\nlet setter = function (conten, key, value) {\\n  // your code\\n};\\nlet n = {\\n  a: {\\n    b: {\\n      c: { d: 1 },\\n      bx: { y: 1 },\\n    },\\n    ax: { y: 1 },\\n  },\\n};\\n// 修改值\\nsetter(n, \\"a.b.c.d\\", 3);\\nconsole.log(n.a.b.c.d); //3\\nsetter(n, \\"a.b.bx\\", 1);\\nconsole.log(n.b.bx); //1\\n```\\n","title":"实现一个 setter 方法"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":[],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":8,"qid":296,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":296,"subject":"","title":"实现一个功能，发送请求 5s 时间后，如果没有数据返回，中断请求,提示错误"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":[],"date":"Fri, 19 Jun 2020 16:20:40 GMT","favorite_num":8,"qid":94,"qtype":"short_answer","short_answer":{"analysis":"**1）思路**\\n\\n1 fetch 请求介绍\\n2 并发，并发，某个完成后可以继续发请求\\n3 所有请求结束后 callback\\n4 注意容错（①参数错误，参数不正确、接口地址不正确、最大数不正确、回调函数不正确；②接口错误）\\n5 边界值\\n6 不能在 while 中使用 fetch，因为 while 是同步，它永远不会等待异步的 fetch 结果回来\\n7 使用 for 循环 + 递归的方法\\n\\n**2）代码实现**\\n\\n```js\\n/**\\n *\\n * @param { Array } urls  请求地址数组\\n * @param { Number } max 最大并发请求数\\n * @param { Function } callback  回调地址\\n */\\nfunction parallelFetch(urls, max, callback) {\\n  // 如果当前环境不支持 fetch , 则提示程序无法正常运行\\n  if (!window.fetch || \\"function\\" !== typeof window.fetch) {\\n    throw Error(\\"当前环境不支持 fetch 请求，程序终止\\");\\n  }\\n\\n  // 如果参数有误，则提示输入正确的参数\\n  if (!urls || urls.length <= 0) {\\n    throw Error(\\"urls is empty: 请传入正确的请求地址\\");\\n  }\\n\\n  const _urlsLength = urls.length; // 请求地址数组的长度\\n  const _max = max || 1; // 保证最大并发值的有效性\\n  let _currentIndex = 0; // 当前请求地址的索引\\n  let _maxFetch = max <= _urlsLength ? max : _urlsLength; // 当前可以正常请求的数量，保证最大并发数的安全性\\n  let _finishedFetch = 0; // 当前完成请求的数量，用于判断何时调用回调\\n  \\n  console.log(`开始并发请求，接口总数为 ${_urlsLength} ，最大并发数为 ${_maxFetch}`);\\n  // 根据最大并发数进行循环发送，之后通过状态做递归请求\\n  for (let i = 0; i < _maxFetch; i++) {\\n    fetchFunc();\\n  }\\n  // 请求方法\\n  function fetchFunc() {\\n    // 如果所有请求数都完成，则执行回调方法\\n    if (_finishedFetch === _urlsLength) {\\n        console.log(`当前一共 ${_urlsLength} 个请求，已完成 ${_finishedFetch} 个`)\\n      if (\\"function\\" === typeof callback) return callback();\\n      return false;\\n    }\\n    // 如果当前请求的索引大于等于请求地址数组的长度，则不继续请求\\n    if (_currentIndex >= _urlsLength) {\\n      _maxFetch = 0;\\n    }\\n\\n    //如果可请求的数量大于0，表示可以继续发起请求\\n    if (_maxFetch > 0) {\\n      console.log( `当前正发起第 ${_currentIndex + 1 } 次请求，当前一共 ${_urlsLength} 个请求，已完成 ${_finishedFetch} 个，请求地址为：${urls[_currentIndex]}`);\\n      // 发起 fetch 请求\\n      fetch(urls[_currentIndex])\\n        .then((res) => {\\n          // TODO 业务逻辑，正常的逻辑，异常的逻辑\\n          // 当前请求结束，正常请求的数量 +1\\n          _maxFetch += 1;\\n          _finishedFetch += 1;\\n          fetchFunc();\\n        })\\n        .catch((err) => {\\n          // TODO 异常处理，处理异常逻辑\\n          // 当前请求结束，正常请求的数量 +1\\n          _maxFetch += 1;\\n          _finishedFetch += 1;\\n          fetchFunc();\\n        });\\n      // 每次请求，当前请求地址的索引  +1\\n      _currentIndex += 1;\\n      // 每次请求，可以正常请求的数量 -1\\n      _maxFetch -= 1;\\n    }\\n  }\\n}\\n\\nlet urls = [];\\nfor (let i = 0; i < 100; i++) {\\n  urls.push(`https://jsonplaceholder.typicode.com/todos/${i}`);\\n}\\nconst max = 10;\\nconst callback = () => {\\n  console.log(\\"我请求完了\\");\\n};\\n\\nparallelFetch(urls, max, callback);\\n```","answer":"","biz_type":1,"qid":94,"subject":"```js\\n/*\\n\\t可以批量请求数据，所有的 URL 地址在 urls 参数中，\\n        同时可以通过 max 参数控制请求的并发度，当所有请\\n        求结束之后，需要执行 callback 回调函数。发请求的\\n        函数可以直接使用 fetch 即可\\n*/\\n```\\n","title":"请实现如下的函数"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["头条"],"date":"Fri, 19 Jun 2020 16:20:40 GMT","favorite_num":7,"qid":48,"qtype":"short_answer","short_answer":{"analysis":"### 答案\\n\\n**简单版**\\n\\n```css\\n/* 简版一  */\\n.sector1 {\\n   border-radius: 0  0  0 200px;\\n   width: 200px;\\n   height: 200px;\\n   background: yellowgreen;\\n}\\n /* 简版二  */\\n.sector1 {\\n  width: 0;\\n  height: 0;\\n  border-width: 100px;\\n  border-style: solid;\\n  border-color: transparent transparent red;\\n  border-radius: 100px;\\n}\\n\\n```\\n\\n**1）实现方式一**\\n\\n```html\\n<!DOCTYPE html>\\n<html lang=\\"en\\">\\n<head>\\n  <meta charset=\\"UTF-8\\">\\n  <meta name=\\"viewport\\" content=\\"width=device-width, initial-scale=1.0\\">\\n  <meta http-equiv=\\"X-UA-Compatible\\" content=\\"ie=edge\\">\\n  <title>使用css3绘制任意角度扇形</title>\\n  <style>\\n  .pie {\\n    position: relative;\\n    margin: 1em auto;\\n    padding: 0;\\n    width: 32em;\\n    height: 32em;\\n    border-radius: 100%;\\n    list-style: none;\\n    overflow: hidden;\\n    transform: rotate(0deg) /*针对mac safari浏览器兼容*/\\n\\n  }\\n  .slice {   /*一个slice最多设置成一个90度的扇形，超过就需要多个slice进行拼接*/\\n    overflow: hidden;\\n    position: absolute;\\n    top: 0;\\n    right: 0;\\n    width: 50%;\\n    height: 50%;\\n    transform-origin: 0% 100%;/*设置旋转的基准点*/\\n  }\\n  .slice-1 {\\n    transform: rotate(-36deg) skewY(-54deg);/*通过配置rotate和skewY的值来设置扇形的角度和位置*/\\n    background: #FF0088;\\n }\\n  .slice-2 {\\n    transform: rotate(-72deg) skewY(-54deg);\\n    background: #FF0000;\\n }\\n \\n  </style>\\n</head>\\n<body>\\n   <ul class=\'pie\'>\\n      <li class=\'slice-1 slice\'> </li>\\n      <li class=\'slice-2 slice\'> </li>\\n  <ul>\\n</body>\\n</html>\\n```\\n\\n\\n**2）实现方式二**\\n\\n```html\\n<!DOCTYPE html>\\n<html lang=\\"en\\">\\n  <head>\\n    <meta charset=\\"UTF-8\\" />\\n    <meta name=\\"viewport\\" content=\\"width=device-width, initial-scale=1.0\\" />\\n    <title>扇形绘制</title>\\n    <style>\\n      .shanxing {\\n        position: relative;\\n        width: 200px;\\n        height: 200px;\\n        border-radius: 100px;\\n        background-color: yellow;\\n      }\\n      .sx1 {\\n        position: absolute;\\n        width: 200px;\\n        height: 200px;\\n        transform: rotate(0deg);\\n        clip: rect(\\n          0px,\\n          100px,\\n          200px,\\n          0px\\n        ); /*这个clip属性用来绘制半圆，在clip的rect范围内的内容显示出来，使用clip属性，元素必须是absolute的 */\\n        border-radius: 100px;\\n        background-color: #f00;\\n        /*-webkit-animation: an1 2s infinite linear; */\\n      }\\n      .sx2 {\\n        position: absolute;\\n        width: 200px;\\n        height: 200px;\\n        transform: rotate(0deg);\\n        clip: rect(0px, 100px, 200px, 0px);\\n        border-radius: 100px;\\n        background-color: #f00;\\n        /*-webkit-animation: an2 2s infinite linear;*/\\n      }\\n      /*绘制一个60度扇形*/\\n      .shanxing1 .sx1 {\\n        transform: rotate(-30deg);\\n      }\\n      .shanxing1 .sx2 {\\n        transform: rotate(-150deg);\\n      }\\n\\n      /*绘制一个85度扇形*/\\n      .shanxing2 .sx1 {\\n        transform: rotate(-45deg);\\n      }\\n      .shanxing2 .sx2 {\\n        transform: rotate(-140deg);\\n      }\\n\\n      /*绘制一个向右扇形，90度扇形*/\\n      .shanxing3 .sx1 {\\n        transform: rotate(45deg);\\n      }\\n      .shanxing3 .sx2 {\\n        transform: rotate(-45deg);\\n      }\\n\\n      /*绘制一个颜色扇形 */\\n      .shanxing4 .sx1 {\\n        transform: rotate(45deg);\\n        background-color: #fff;\\n      }\\n      .shanxing4 .sx2 {\\n        transform: rotate(-45deg);\\n        background-color: #fff;\\n      }\\n\\n      /*绘制一个不同颜色半圆夹角 */\\n      .shanxing5 .sx1 {\\n        transform: rotate(45deg);\\n        background-color: #f00;\\n      }\\n      .shanxing5 .sx2 {\\n        transform: rotate(-45deg);\\n        background-color: #0f0;\\n      }\\n    </style>\\n  </head>\\n  <body>\\n    <h2>CSS之如何绘制任意角度的扇形</h2>\\n    <div>\\n      扇形制作原理，底部一个纯色原形， 里面2个相同颜色的半圆，可以是白色,\\n      内部半圆按一定角度变化，就可以产生出扇形效果\\n    </div>\\n    <div class=\\"shanxing\\">\\n      <div class=\\"sx1\\"></div>\\n      <div class=\\"sx2\\"></div>\\n    </div>\\n    <div class=\\"shanxing shanxing1\\">\\n      <div class=\\"sx1\\"></div>\\n      <div class=\\"sx2\\"></div>\\n    </div>\\n    <div class=\\"shanxing shanxing2\\">\\n      <div class=\\"sx1\\"></div>\\n      <div class=\\"sx2\\"></div>\\n    </div>\\n    <div class=\\"shanxing shanxing3\\">\\n      <div class=\\"sx1\\"></div>\\n      <div class=\\"sx2\\"></div>\\n    </div>\\n    <div class=\\"shanxing shanxing4\\">\\n      <div class=\\"sx1\\"></div>\\n      <div class=\\"sx2\\"></div>\\n    </div>\\n    <div class=\\"shanxing shanxing5\\">\\n      <div class=\\"sx1\\"></div>\\n      <div class=\\"sx2\\"></div>\\n    </div>\\n  </body>\\n</html>\\n```\\n","answer":"","biz_type":1,"qid":48,"subject":"","title":"Css 如何画出一个扇形，动手实现下"},"tech_tag":["Css","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["高德","百分点"],"date":"Fri, 19 Jun 2020 16:20:40 GMT","favorite_num":9,"qid":119,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":119,"subject":"","title":"实现 Promise.then"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["顺丰"],"date":"Fri, 19 Jun 2020 16:20:40 GMT","favorite_num":8,"qid":121,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":121,"subject":"```js\\n// 输入两个字符串 2018-08  2018-12\\n// 输出他们中间的月份 [2018-10, 2018-11]\\n```\\n","title":"给定起止日期，返回中间的所有月份"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["顺丰"],"date":"Fri, 19 Jun 2020 16:20:40 GMT","favorite_num":8,"qid":125,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":125,"subject":"","title":"简单封装一个异步 fecth，使用 async await 的方式来使用"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["顺丰"],"date":"Fri, 19 Jun 2020 16:20:40 GMT","favorite_num":9,"qid":128,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":128,"subject":"```js\\nvar obj = {\\n  a: \\"12\\",\\n  b: \\"23\\",\\n  first: {\\n    c: \\"34\\",\\n    d: \\"45\\",\\n    second: { 3: \\"56\\", f: \\"67\\", three: { g: \\"78\\", h: \\"89\\", i: \\"90\\" } },\\n  },\\n};\\n// => [a,b,c,d,e,f,g,h,i]\\n```\\n","title":"请写一个函数，输出出多级嵌套结构的 Object 的所有 key 值"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["头条"],"date":"Fri, 19 Jun 2020 16:20:40 GMT","favorite_num":6,"qid":129,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":129,"subject":"","title":"使用 Css 实现一个水波纹效果"},"tech_tag":["Css","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["头条"],"date":"Fri, 19 Jun 2020 16:20:40 GMT","favorite_num":9,"qid":132,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":132,"subject":"```js\\nfunction repeat(func, times, wait) {\\n  // TODO\\n}\\nconst repeatFunc = repeat(alert, 4, 3000);\\n// 调用这个 repeatFunc (\\"hellworld\\")，会alert4次 helloworld, 每次间隔3秒\\n```\\n","title":"动手实现一个 repeat 方法"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["头条"],"date":"Fri, 19 Jun 2020 16:20:40 GMT","favorite_num":9,"qid":134,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":134,"subject":"```js\\nvar versions = [\\"1.45.0\\", \\"1.5\\", \\"6\\", \\"3.3.3.3.3.3.3\\"];\\n// 要求从小到大排序，注意\'1.45\'比\'1.5\'大\\nfunction sortVersion(versions) {\\n  // TODO\\n}\\n// => [\'1.5\',\'1.45.0\',\'3.3.3.3.3.3\',\'6\']\\n```\\n","title":"versions 是一个项目的版本号列表，因多人维护，不规则，动手实现一个版本号处理函数"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["头条"],"date":"Fri, 19 Jun 2020 16:20:40 GMT","favorite_num":9,"qid":139,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":139,"subject":"```js\\nconst a = sum(); // => a === 0\\nconst b = sum(); // => b === 2\\nconst c = sum(4)(5); // c === 9\\nconst k = sum(n1)...(nk) // k === n1 + n2 + ... + nk\\n```\\n","title":"按要求实现一个 sum 函数"},"tech_tag":["JavaScript","编程题"],"uid":0,"uname":""}],"page":1,"pages":1,"uid":4510},"status":0}')}}]);