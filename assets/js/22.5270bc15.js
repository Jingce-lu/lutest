(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{393:function(n){n.exports=JSON.parse('{"msg":"success","result":{"list":[{"audit_flag":0,"corp_tag":["头条"],"date":"Sat, 04 Jul 2020 00:05:10 GMT","favorite_num":5,"qid":867,"qtype":"short_answer","short_answer":{"analysis":"### 答案\\n\\n```js\\n/**\\n* \\n* 解题思路：从array中取出n个数全排列，在取的同时判断是否符合条件，为了不影响后续排列，每次递归完成，将当前的数组添加到正在排序的array中\\n* 时间复杂度O(n)\\n* 空间复杂度O(n)\\n* @param {Array} array 需要判断的数组\\n* @param {number} n 取出n个数\\n* @param {number} sum 和为sum的值\\n* @param {array} temp 输出和为sum的数组 \\n*/\\n\\nfunction getAllCombin(array, n, sum, temp) {\\n  if (temp.length === n) {\\n    if (temp.reduce((t, c) => t + c) === sum) {\\n      return temp;\\n    }\\n    return false;\\n  }\\n  for (let i = 0; i < array.length; i++) {\\n    const current = array.shift();\\n    temp.push(current);\\n    const result = getAllCombin(array, n, sum, temp);\\n    if (result) {\\n      return result;\\n    }\\n    temp.pop();\\n    array.push(current);\\n  }\\n}\\n\\nconst arr = [1, 5, 6, 2, 4, 3];\\nconsole.log(getAllCombin(arr, 3, 10, []));\\n```","answer":"","biz_type":1,"qid":867,"subject":null,"title":"请用算法实现，从给定的无序、不重复的数组data中，取出n个数，使其相加和为sum。并给出算法的时间/空间复杂度。(不需要找到所有的解，找到一个解即可)"},"tech_tag":["算法"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["头条"],"date":"Fri, 19 Jun 2020 16:21:40 GMT","favorite_num":7,"qid":2,"qtype":"short_answer","short_answer":{"analysis":"```js\\nfunction mergeSort(arr) {\\n    const len = arr.length\\n    // 处理边界情况\\n    if(len <= 1) {\\n        return arr[0]\\n    }   \\n    // 计算分割点\\n    const mid = Math.floor(len / 2)    \\n    // 递归分割左子数组，然后合并为有序数组\\n    const leftArr = mergeSort(arr.slice(0, mid)) \\n    // 递归分割右子数组，然后合并为有序数组\\n    const rightArr = mergeSort(arr.slice(mid,len))  \\n    // 合并左右两个有序数组\\n    arr = mergeArr(leftArr, rightArr)  \\n    // 返回合并后的结果\\n    return arr\\n}\\n  \\nfunction mergeArr(arr1, arr2) {  \\n    // 初始化两个指针，分别指向 arr1 和 arr2\\n    let i = 0, j = 0   \\n    // 初始化结果数组\\n    const res = []    \\n    // 缓存arr1的长度\\n    const len1 = arr1.length  \\n    // 缓存arr2的长度\\n    const len2 = arr2.length  \\n    // 合并两个子数组\\n    while(i < len1 && j < len2) {\\n        if(arr1[i] < arr2[j]) {\\n            res.push(arr1[i])\\n            i++\\n        } else {\\n            res.push(arr2[j])\\n            j++\\n        }\\n    }\\n    // 若其中一个子数组首先被合并完全，则直接拼接另一个子数组的剩余部分\\n    if(i<len1) {\\n        return res.concat(arr1.slice(i))\\n    } else {\\n        return res.concat(arr2.slice(j))\\n    }\\n}\\n\\nvar arr=[[1,2,4],[2,3,7],[3,5,7],[4,5,8]]\\nmergeArr(arr)\\n```","answer":"","biz_type":1,"qid":2,"subject":"","title":"合并二维有序数组成一维有序数组，归并排序的思路"},"tech_tag":["算法"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["腾讯"],"date":"Fri, 19 Jun 2020 16:21:40 GMT","favorite_num":6,"qid":4,"qtype":"short_answer","short_answer":{"analysis":"```js\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar lengthOfLongestSubstring = function (s) {\\n    const arr = [...s]\\n    let res = 1;\\n    let result = arr.reduce((total, cur, i, arr) => {\\n        if (i == 0) {\\n            return cur;\\n        } else {\\n            if (total.indexOf(cur) < 0) {\\n                return total + cur\\n            } else if (res < total.length) {\\n                res = total.length\\n                return total.slice(total.indexOf(cur) + 1, total.length) + cur\\n            } else {\\n                return total.slice(total.indexOf(cur) + 1, total.length) + cur\\n            }\\n        }\\n    }, \\"\\")\\n    if (res < result.length) {\\n        res = result.length\\n    }\\n\\n    return res\\n};\\n\\nconsole.log(lengthOfLongestSubstring(\\"loddktdji\\"))\\nconsole.log(lengthOfLongestSubstring(\\"dvdf\\"))\\nconsole.log(lengthOfLongestSubstring(\\"adfafwefffdasdcx\\"))\\n```","answer":"","biz_type":1,"qid":4,"subject":"","title":"字符串出现的不重复最长长度"},"tech_tag":["算法"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["腾讯","CVTE","微软"],"date":"Fri, 19 Jun 2020 16:21:40 GMT","favorite_num":6,"qid":3,"qtype":"short_answer","short_answer":{"analysis":"```js\\n/**\\n * @description 求斐波那契数列第n项\\n * @param {number} n 项目数\\n * @return {number} 返回第n项值\\n */\\nfunction fibonacci(n, map = {}) {\\n    if (n == 1 || n == 2) return 1;\\n    if (map[n]) return map[n];\\n    let data = fibonacci(n - 1, map) + fibonacci(n - 2, map)\\n    map[n] = data\\n    return data\\n}\\n/**\\n * @description 求斐波那契数列第n项\\n * @param {number} n 项目数\\n * @return {number} 返回第n项值\\n */\\nfunction fibonacci(n) {\\n    let pre = 1;\\n    let cur = 1;\\n    let data;\\n    if (n == 1 || n == 2) return 1;\\n    for (let i = 3; i <= n; i++) {\\n        data = pre + cur;\\n        pre = cur;\\n        cur = data;\\n    }\\n    return data;\\n}\\n\\n/**\\n * @description 求斐波那契数列第n项\\n * @param {number} n 项目数\\n * @return {number} 返回第n项值\\n */\\nfunction fibonacci(n, v1 = 1, v2 = 1) {\\n    if (n == 1) return v1\\n    if (n == 2) return v2\\n    return fibonacci(n - 1, v2, v1 + v2)\\n}\\n```","answer":"","biz_type":1,"qid":3,"subject":"","title":"多种方式实现斐波那契数列"},"tech_tag":["算法"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["滴滴"],"date":"Fri, 19 Jun 2020 16:21:40 GMT","favorite_num":5,"qid":13,"qtype":"short_answer","short_answer":{"analysis":"\\n```js\\n    // 计算数组元素和\\n    function sum(o) {\\n\\n        var sum = 0;\\n\\n        if (Array.isArray(o)) {\\n            o.map(function(item, index, array) {\\n                sum += item;\\n            });\\n        } else {\\n            sum += o;\\n        }\\n\\n        return sum;\\n\\n    }\\n\\n    // 多维数组排序\\n    function sortMArray(arr) {\\n\\n        for (var i = 0, len = arr.length; i < len - 1; i++) {\\n            for (var j = i + 1; j < len; j++) {\\n                if (sum(arr[i]) < sum(arr[j])) {\\n                    var temp = arr[i];\\n                    arr[i] = arr[j];\\n                    arr[j] = temp;\\n                }\\n            }\\n        }\\n\\n        return arr;\\n\\n    }\\n// 任意数分三组，每组和尽量相等（也就是最大值与最小值差值最小）\\n    function equal(arr) {\\n\\n        var array = [];\\n\\n        arr = sortMArray(arr);\\n\\n        for (var i = 0; i < arr.length; i++) {\\n            // 转换成多维数组\\n            array.push([arr[i]]);\\n        }\\n\\n        while (array.length > 3) {\\n            array[2].push(array[3][0]);\\n            array.splice(3, 1);\\n            array = sortMArray(array);\\n        }\\n\\n        return array;\\n\\n    }\\n```","answer":"","biz_type":1,"qid":13,"subject":"","title":"有一堆整数，请把他们分成三份，确保每一份和尽量相等（11，42，23，4，5，6 4 5 6 11 23 42 56 78 90）"},"tech_tag":["算法"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["爱范儿"],"date":"Fri, 19 Jun 2020 16:20:44 GMT","favorite_num":4,"qid":706,"qtype":"short_answer","short_answer":{"analysis":"### 代码实现\\n\\n“下一个排列”的定义是：给定数字序列的字典序中下一个更大的排列。如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。\\n\\n可以将该问题形式化地描述为：给定若干个数字，将其组合为一个整数。如何将这些数字重新排列，以得到下一个更大的整数。如 123 下一个更大的数为 132。如果没有更大的整数，则输出最小的整数。\\n\\n```js\\nvar nextPermutation = function (nums) {\\n    for (let i = nums.length - 1; i > 0; i--) {\\n        //第一个升序\\n        if (nums[i] > nums[i - 1]) {\\n            //查找后面数字中第一个大于nums[i-1]的值，并且交换位置\\n            for (let j = nums.length - 1; j > i - 1; j--) {\\n                // 第一个大于nums[i-1]的值\\n                if (nums[j] > nums[i - 1]) {\\n                    //交换位置\\n                    [nums[j], nums[i - 1]] = [nums[i - 1], nums[j]];\\n                    //i开始的数字需要是升序，交叉替换\\n                    let a = i, b = nums.length - 1;\\n                    while (a <= b) {\\n                        [nums[a], nums[b]] = [nums[b], nums[a]];\\n                        a++;\\n                        b--;\\n                    }\\n                    return nums;\\n                }\\n            }\\n        }\\n    }\\n    //如果没有找到，数组升序排列，最小\\n    return nums.sort((a, b) => a - b);\\n};\\n```","answer":"","biz_type":1,"qid":706,"subject":"```js\\n/* \\n  Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.\\n  If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).\\n  The replacement must be in-place, do not allocate extra memory.\\n  Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.\\n  1,2,3 → 1,3,2\\n  3,2,1 → 1,2,3\\n  1,1,5 → 1,5,1\\n*/\\n```\\n","title":"算法考察：Next Permutation"},"tech_tag":["算法"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["新东方"],"date":"Fri, 19 Jun 2020 16:20:44 GMT","favorite_num":4,"qid":752,"qtype":"short_answer","short_answer":{"analysis":"### 代码实现\\n\\n#### 1.实现一\\n\\n```js\\nconst NumberOf1 = (n) => {\\n    if(n < 0){\\n        n = n >>> 0;//能够获取到负数的补码\\n    }\\n    var arr = n.toString(2).split(\'\');\\n    return arr.reduce(function(a,b){\\n        return b === \\"1\\" ? a + 1 : a;\\n    },0);\\n}\\n```\\n\\n#### 2.实现二\\n\\n```js\\nfunction hammingWeight(n){\\n let arr = n.toString(2).split(\'\').filter((item) => item == 1);\\n return arr.length;\\n}\\n\\nfunction hammingWeight(n) {\\n  let count = 0;\\n  while (n !== 0) {\\n    n = n & (n - 1);\\n    count++;\\n  }\\n  return count;\\n};\\n```\\n\\n#### 3.实现三\\n\\n```js\\nvar hammingWeight = function(n) {\\n  let res = 0;\\n  while(n!==0){\\n    res += n&1;\\n    n >>>= 1;\\n  }\\n  return res;\\n};\\n```\\n\\n#### 4.实现四\\n\\n```js\\nvar hammingWeight = function (n) {\\n    var ans = 0;\\n    while (n) {\\n      if (n & 1) ans++;\\n      n /= 2;\\n    }\\n    return ans;\\n  };\\n```","answer":"","biz_type":1,"qid":752,"subject":"","title":"输入一个整数，输出该数二进制表示中 1 的个数"},"tech_tag":["算法"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["乘法云"],"date":"Fri, 19 Jun 2020 16:20:44 GMT","favorite_num":4,"qid":744,"qtype":"short_answer","short_answer":{"analysis":"### 代码实现\\n\\n#### 1.实现一\\n\\n```js\\nconst getIntersection = (arr1, arr2) =>{\\n   let arr = [];\\n   if (arr1.length > arr2.length) {\\n      for(let i =0; i<arr1.length; i++) {\\n          if (arr2.includes[arr1[i]]){\\n            arr.push(arr1[i])\\n          };\\n      }\\n   } else {\\n       for(let i =0; i<arr1.length; i++) {\\n          if (arr1.includes[arr2[i]]){\\n            arr.push(arr2[i])\\n          };\\n      }\\n   }\\n   return Array.from(new Set(arr))\\n}\\n```\\n\\n#### 2.实现二\\n\\n- ES6中使用Set结构\\n\\n```js\\nlet a = new Set([1,2,3,4,5,6]);\\nlet b = new Set([4,5,6,7,8,9]); \\nlet jiaoji = new Set([...a].filter(x => b.has(x)));\\n```\\n\\n#### 3.实现三\\n\\n```js\\nvar intersection = function (nums1, nums2) {\\n    nums1 = new Set(nums1);\\n    nums2 = new Set(nums2);\\n    let res = [];\\n    for(let item of nums1){\\n        if(nums2.has(item)){\\n            res.push(item);\\n        }\\n    }\\n    return res;\\n};\\n```\\n\\n#### 4.实现四\\n\\n```js\\nvar interaction1 = (nums1, nums2) => {\\n  var result = [];\\n  var store;\\n  var arr;\\n  if (nums1.length < nums2.length) {\\n    arr = nums1;\\n    store = nums2;\\n  } else {\\n    arr = nums2;\\n    store = nums1;\\n  }\\n  for (let i = 0; i < arr.length; i++) {\\n    //store中有，结果中没有\\n    if (store.indexOf(arr[i]) !== -1 && result.indexOf(arr[i]) === -1) {\\n      result.push(arr[i]);\\n    }\\n  }\\n  return result;\\n};\\n```","answer":"","biz_type":1,"qid":744,"subject":"","title":"找出两个数组的交集元素"},"tech_tag":["算法"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["高思教育"],"date":"Fri, 19 Jun 2020 16:20:44 GMT","favorite_num":4,"qid":729,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":729,"subject":"```js\\n/* \\n  根据传入参数n(数字)对一维数组(纯数字)按照距离n最近的顺序排序。(距离即数字与n的差值的绝对值)\\n*/\\nvar arr = [7, 28, -1, 0, 7, 33];\\nfunction sort(n) {\\n  // your code\\n}\\n```\\n","title":"按要求实现代码"},"tech_tag":["算法"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":[],"date":"Fri, 19 Jun 2020 16:20:44 GMT","favorite_num":4,"qid":756,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":756,"subject":"","title":"⽤ js 实现随机选取 10–100 之间的 10 个且不重复的数字，存⼊⼀个数组，还要排序"},"tech_tag":["算法"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":[],"date":"Fri, 19 Jun 2020 16:20:44 GMT","favorite_num":4,"qid":761,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":761,"subject":"","title":"给定⼀个⼤⼩为 n 的数组，找到其中的众数。众数是指在数组中出现次数⼤于 ⌊⌊ n/2 ⌋⌋ 的元素"},"tech_tag":["算法"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["百分点"],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":4,"qid":548,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":548,"subject":"","title":"找到前 K 个最大的元素"},"tech_tag":["算法"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["海风教育"],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":4,"qid":554,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":554,"subject":"","title":"介绍下 DFS 深度优先"},"tech_tag":["算法"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["会小二"],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":4,"qid":605,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":605,"subject":"```js\\nA.O(n)\\nB.O(logn)\\nC.O(nlogn)\\nD.O(n2)\\n\\n```\\n","title":"递归公式的时间复杂度为？(单选题)"},"tech_tag":["算法"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["会小二"],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":4,"qid":612,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":612,"subject":"","title":"用 JavaScript 实现一个标准的排序算法(快排、冒泡、选择排序)，对某个数字数组进行由低到高的排序。"},"tech_tag":["算法"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["心娱"],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":4,"qid":623,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":623,"subject":"","title":"找出“aaaabbcccdddd”字符串中出现最多的字母？"},"tech_tag":["算法"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":[],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":4,"qid":632,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":632,"subject":"","title":"求 n 以内的所有素数，并说明时间复杂度"},"tech_tag":["算法"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["头条"],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":4,"qid":674,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":674,"subject":"","title":"给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。说明: 叶子节点是指没有子节点的节点"},"tech_tag":["算法"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["头条"],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":4,"qid":676,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":676,"subject":"","title":"给定一个整数数组 nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和"},"tech_tag":["算法"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["有赞"],"date":"Fri, 19 Jun 2020 16:20:42 GMT","favorite_num":4,"qid":410,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":410,"subject":"","title":"介绍冒泡排序、选择排序，说说冒泡排序如何优化"},"tech_tag":["算法"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["有赞"],"date":"Fri, 19 Jun 2020 16:20:42 GMT","favorite_num":4,"qid":412,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":412,"subject":"","title":"如何判断链表是否有环"},"tech_tag":["算法"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["有赞"],"date":"Fri, 19 Jun 2020 16:20:42 GMT","favorite_num":4,"qid":413,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":413,"subject":"","title":"介绍二叉搜索树的特点"},"tech_tag":["算法"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["携程","心娱"],"date":"Fri, 19 Jun 2020 16:20:42 GMT","favorite_num":4,"qid":463,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":463,"subject":"","title":"手写数组去重函数(至少三种以上，说明时间复杂度)"},"tech_tag":["算法"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["微软"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":4,"qid":160,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":160,"subject":"","title":"二叉树序列化反序列化"},"tech_tag":["算法"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["微软"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":4,"qid":161,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":161,"subject":"```js\\n/*\\n\\t如输入1 返回a\\n\\t输入26返回z\\n\\t输入27返回aa\\n\\t输入28返回ab\\n\\t输入53返回aaa\\n*/\\n```\\n","title":"输入一个数字，找到对应的字母"},"tech_tag":["算法"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["微软"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":4,"qid":162,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":162,"subject":"```js\\n// Given an int n, output Mausoleum Array solutions.\\n// Mausoleum Array:\\n// Construct by 1,1,2,2,3,3,…,n-1,n-1,n,n\\n// first were non-decreasing (i.e., increasing or remained the same), and then — non-increasing (decrease or remained unchanged).\\n// Mausoleum Array example:\\n// [1, 2, 2, 3, 4, 4, 3, 1];\\n// [1, 1];\\n// [2, 2, 1, 1];\\n// [1, 2, 3, 3, 2, 1].\\n// input/output example:\\n// n=1, [1,1]\\n// n=2, [1,1,2,2],[1,2,2,1],[2,2,1,1]\\n// n = 3,[3, 3, 2, 2, 1, 1],[2, 3, 3, 2, 1, 1],[2, 2, 3, 3, 1, 1],[1, 3, 3, 2, 2, 1],[1, 2, 3, 3, 2, 1],[1, 2, 2, 3, 3, 1],[1, 1, 3, 3, 2, 2],[1, 1, 2, 3, 3, 2],[1, 1, 2, 2, 3, 3]\\n```\\n","title":"Given an int n, output Mausoleum Array solutions."},"tech_tag":["算法"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["易车"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":4,"qid":173,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":173,"subject":"","title":"给一个字符串比如\'abca\'，返回第一个不重复的字母"},"tech_tag":["算法"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["新东方"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":4,"qid":180,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":180,"subject":"```js\\n/*\\n  有效字符串需满⾜：\\n \\t \\t1. 左括号必须⽤相同类型的右括号闭合。\\n  \\t2. 左括号必须以正确的顺序闭合。\\n  注意空字符串可被认为是有效字符串。\\n  示例1：\\n  \\t输⼊: \\"()\\"\\n  \\t输出: true\\n  示例2：\\n  \\t输⼊: \\"()[]{}\\"\\n  \\t输出: true\\n  示例 3:\\n  \\t输⼊: \\"(]\\"\\n  \\t输出: false\\n  示例 4:\\n  \\t输⼊: \\"([)]\\"\\n  \\t输出: false\\n  示例 5:\\n  \\t输⼊: \\"{[]}\\"\\n  \\t输出: true\\n*/\\n```\\n","title":"给定⼀个只包括 \'(\'，\')\'，\'{\'，\'}\'，\'[\'，\']\' 的字符串，判断字符串是否有效."},"tech_tag":["算法"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["滴滴"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":4,"qid":186,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":186,"subject":"","title":"手动实现一个函数，给定一个数组[1,0,2,3,4,-1,-3]，输出任意两个值和为 0 的下标"},"tech_tag":["算法"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["寺库","百分点"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":4,"qid":193,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":193,"subject":"","title":"介绍排序算法和快排原理"},"tech_tag":["算法"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["快手"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":4,"qid":216,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":216,"subject":"","title":"一个人每次只能走一层楼梯或者两层楼梯，问走到第 80 层楼梯一共有多少种方法"},"tech_tag":["算法"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":[],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":4,"qid":255,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":255,"subject":"","title":"给定一个数组，形如 [1, 1, 2 , 3, 3, 3, 3, 4, 6, 6]，给定一个数 n，例如 3，找出给定的数 n 在数组内出现的次数，要求时间复杂度小于 O(n)"},"tech_tag":["算法"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":[],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":4,"qid":282,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":282,"subject":"","title":"现在有随机整数数组，例如[2,11,20,160,3,1...]，请挑出数组内，三个随机整数和为 100 的所有数据。"},"tech_tag":["算法"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["心娱"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":5,"qid":306,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":306,"subject":"","title":"统计一组整形数组的最大差值？"},"tech_tag":["算法"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["头条"],"date":"Fri, 19 Jun 2020 16:20:40 GMT","favorite_num":4,"qid":140,"qtype":"short_answer","short_answer":{"analysis":"#### 代码实现\\n\\n题目的思路很明显，对二叉树进行层序遍历，然后取得每一层的最后一个节点。放到一个数组里最后返回。\\n\\n- 可以设置一个队列存放依次遍历的节点对象。\\n- 使用两层循环\\n  - 内层循环通过不断出队列的方式遍历当前层的节点，同时通过左右链接收集下一层节点\\n  - 外层循环判断队列长度>0时就继续运行，从而实现逐层迭代\\n\\n```js\\nfunction rightView(root) {\\n  if (!root) return [];\\n  const queue = [];\\n  const arrRS = [];\\n  // 先保存根结点，也就是第一层二叉树\\n  queue.push(root);\\n  while (queue.length > 0) {\\n    // 将队列长度先保存到一个变量里面\\n    // 表示的是上一层的节点的数量\\n    let length = queue.length;\\n    let temp = null;\\n    // 遍历上一层节点，将它们的子节点加入队列中，收集得到二叉树的下一层\\n    for (let i = 0; i < length; i++) {\\n      // 出队列，并获得返回的父节点\\n      const node = queue.shift();\\n      // 每次都用当前节点的val覆盖temp\\n      // temp最后会等于当前层最右的一个非空节点的val值\\n      if (node.val) temp = node.val;\\n      // 收集当前节点的左节点和右节点，从而得到下一层\\n      if (node.left) queue.push(node.left);\\n      if (node.right) queue.push(node.right);\\n    }\\n    // 收集每一层的最右节点\\n    arrRS.push(temp);\\n  }\\n  return arrRS;\\n};\\n```","answer":"","biz_type":1,"qid":140,"subject":"```js\\nfunction TreeNode(val){\\n  this.val = val;\\n  this.left = null;\\n  this.right = null;\\n}\\nfunction rightView(root){\\n  // 请你实现\\n}\\n// => [1,4,3]\\n     1       => 1\\n   2   4     => 4\\n 7   3       => 3\\n```\\n","title":"按要求实现 rightView 函数"},"tech_tag":["算法"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["头条"],"date":"Fri, 19 Jun 2020 16:20:40 GMT","favorite_num":4,"qid":63,"qtype":"short_answer","short_answer":{"analysis":"#### 代码实现\\n\\n**1）代码实现一**\\n\\n```js\\nfunction Node(data) {\\n    this.data = data;\\n    this.next = null\\n}\\n\\nfunction Queue() {\\n    this.front = null; //初始化队列：创建一个指向队列节点的头指针\\n}\\nQueue.prototype = {\\n    add(node) { //入队：创建一个新节点，将它添加到链表尾部，如果链表为空，让头指针指向该节点\\n        var current = this.front;\\n        if (current) {\\n            while (current.next != null) {\\n                current = current.next;\\n            }\\n            current.next = new Node(node);\\n        } else {\\n            this.front = new Node(node)\\n        }\\n\\n    },\\n    remove() { // 出队 free 头指针指向第一个节点， 让头指针指向该节点的下一个节点， 然后返回该节点的值。\\n        if (this.front) {\\n            let current = this.front;\\n            let data = current.data;\\n            this.front = current.next;\\n            return data;\\n        } else {\\n            throw new Error(\'the queue is empty!\');\\n        }\\n    },\\n    isEmpty() { //判空\\n        return this.front === null;\\n    },\\n    getFront() { // 读队头\\n        return this.front.data\\n    },\\n    printQueue() {  //输出队列\\n        var temp = this.front;\\n        while (temp) {\\n            console.log(temp.data);\\n            temp = temp.next\\n        }\\n    }\\n}\\n/** test ***/\\nvar queue = new Queue();\\nqueue.add(1);\\nqueue.add(2);\\nqueue.add(3);\\nqueue.printQueue();\\nconsole.log(\'-----split----\')\\nqueue.remove();\\nqueue.add(1);\\nqueue.printQueue();\\nconsole.log(\'-----split----\')\\nconsole.log(queue.getFront());\\nconsole.log(queue.isEmpty());\\n```\\n\\n**2）代码实现二**\\n\\n- 队列的特点：先进先出\\n- 队列的方法：进队列、出队列\\n- 获得队列长度\\n- 清空队列\\n- 返回队头指针\\n- 单链表实现队列\\n\\n```js\\nfunction Node(val,next) {\\n    this.val = val\\n    this.next = next || null\\n}\\n\\nfunction LinkQueue() {\\n    // 记录头部指针\\n    this.head = null\\n    this.len = 0\\n}\\n\\n// 入队列\\nLinkQueue.prototype.add = function (val) {\\n    const node = new Node(val,this.head)\\n    this.head = node\\n    this.len++\\n}\\n\\n// 出队列\\nLinkQueue.prototype.remove = function () {\\n    if (this.len === 0) {\\n        return\\n    }\\n    if (this.len === 1) {\\n        this.head = null\\n    } else {\\n        let p = this.head\\n        while (p.next.next !== null) {\\n            p = p.next\\n        }\\n        p.next = null\\n    }\\n    this.len--\\n}\\n// 获得队头指针\\nLinkQueue.prototype.getHead = function () {\\n    return this.head\\n}\\n// 清空队列\\nLinkQueue.prototype.clear = function () {\\n    while (this.head) {\\n        let node = this.head\\n        node.next = null\\n        node = null\\n        this.head = this.head.next\\n    }\\n}\\n// 打印队列所有元素\\nLinkQueue.prototype.console = function () {\\n    console.log(\'打印队列\')\\n    while (this.head) {\\n        console.log(this.head.val)\\n        this.head = this.head.next\\n    }\\n    console.log(\'打印队列完成\')\\n}\\n\\nconst queue = new LinkQueue()\\nqueue.add(1)\\nqueue.add(2)\\nqueue.add(3)\\nqueue.add(4)\\nqueue.remove()\\nconsole.log(\'队列长度：\' + queue.len)\\nqueue.console()\\nqueue.clear()\\nqueue.console()\\n\\n```","answer":"","biz_type":1,"qid":63,"subject":"","title":"单向链表实现队列"},"tech_tag":["算法"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["腾讯"],"date":"Fri, 19 Jun 2020 16:20:40 GMT","favorite_num":4,"qid":33,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":33,"subject":"```js\\n算法：输入一条polyline，输出polyline的中点\\n绘制：在浏览器中绘制出polyline和中点\\n说明：中点是指沿着polyline，到polyline的起点和终点，距离相等，中点要求在polyline上\\n输入：[[10, 20], [20, 200], [30, 220], [40, 300], [100, 400]]，以[10, 20]举例，10代表x坐标，20代表y坐标，单位是像素\\n要求：提供源代码，用原生JavaScript实现，不使用任何框架、类库、构建工具，本地打开html文件可直接看到效果\\n```\\n","title":"[实操题]输入一条 polyline，输出 polyline 的中点"},"tech_tag":["算法"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":[],"date":"Fri, 19 Jun 2020 16:20:40 GMT","favorite_num":4,"qid":65,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":65,"subject":"```js\\n/*\\n *数组：[{id:1, parentId: 0}, {id:2, parentId:1},{id:3, parentId:1}]\\n *输出结果：[{id:1, parentId: 0,children:[{id:2, parentId:1},{id:3, parentId:1}]}]\\n *说明：parentId为0 的是根节点\\n */\\n```\\n","title":"将给定的数组从顶级分类递归查找子分类，最终构建一个树状数组"},"tech_tag":["算法"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["顺丰"],"date":"Fri, 19 Jun 2020 16:20:40 GMT","favorite_num":4,"qid":123,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":123,"subject":"","title":"实现一个将 52 张牌随机均等的分给四个人，比如输入 [0,1,2,3....51] ，输出[[1,2,16...],[4,3,6..],[....],[....]]"},"tech_tag":["算法"],"uid":0,"uname":""}],"page":1,"pages":1,"uid":4510},"status":0}')}}]);