(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{365:function(n){n.exports=JSON.parse('{"msg":"success","result":{"list":[{"audit_flag":0,"corp_tag":["滴滴"],"date":"Fri, 19 Jun 2020 16:21:40 GMT","favorite_num":14,"qid":5,"qtype":"short_answer","short_answer":{"analysis":"1）Chrome 浏览器提供 4 种发布版本，即稳定版(Stable)、测试版(Beta)、开发者版(Dev)和金丝雀版(Canary)。\\n虽然 Chrome 这几个版本名称各不相同，但都沿用了相同的版本号，只是更新早晚的区别。就好比 iOS 等系统，Beta 版可以率先更新到 iOS 12 并进行测试，不断改进稳定后，正式版才升级到 12 版本。\\nChrome 也是如此，更新最快的 Canary 会领先正式版 1-2 个版本。\\n- 1.Canary（金丝雀） 版\\n  - 只限用于测试，Canary 是 Chrome 的未来版本，是功能、代码最先进的Chrome 版本，一方面软件本身没有足够时间测试，另一方面网页也不一定支持这些全新的功能，因此极不稳定。好在，谷歌将其设定为可独立安装、与其他版本的 Chrome 程序共存，因此适合进阶用户安装备用，尝鲜最新功能。这种不稳定性使得 Canary 版目前并不适合日常使用。\\n  - Chrome Canary 是更新速度最快的 Chrome 版本，几乎每天更新。它相当于支持自动更新、并添加了谷歌自家服务与商业闭源插件（Flash 等）的 Chromium，更加强大好用。\\n\\n- 2.开发者版(Dev)\\n  - Chrome Dev 最初是以 Chromium 为基础、更新最快的 Chrome，后来则被 Canary 取代。Dev 版每周更新一次，虽然仍不太稳定，但已经可以勉强满足日常使用，适合 Web 开发者用来测试新功能和网页。\\n  - 让 IT 人员使用开发者版，开发者可以通过开发者版测试自己公司的应用，确保这些应用能与Chrome 最新的 API 更改及功能更改兼容。注意：开发者版并非百分之百稳定，但开发者可以提前 9 至 12 周体验即将添加到 Chrome 稳定版的功能。\\n\\n- 3.测试版(Beta)\\n  - Chrome Beta 以 Dev 为基础，每月更新一次。它是正式发布前的最后测试版本，所有功能都已在前面几个版本中得到测试并改进，因此已经十分稳定，普通用户也可以用来日常使用\\n  - 让 5% 的用户使用测试版，测试版用户可以提前 4-6 周体验即将在 Chrome 稳定版中推出的功能。测试版用户可以发现特定版本可能存在的问题，让您可以先解决问题，然后再向所有用户推出该版本。\\n\\n- 4.稳定版(Stable)\\n  - 最后的 Chrome Stable 就是我们熟知的正式版，它以 Beta 为基础，几个月更新一次。由于所有的功能都已经过数个月反复测试，是稳定性最高的 Chrome 版本。\\n  - 让大多数用户使用稳定版，稳定版是已进行充分测试的版本，稳定版每 2-3 周会进行一次小幅更新，并且每 6 周会进行一次重大更新。\\n\\n所以要定期下载开发者版，体验Chrome 最新的 API和新功能 ，发现自己的应用跟新API和新功能的是否有兼容问题，找到开发亮点。\\n\\n2）对于Chrome的历史版本测试\\n可以使用Docker Selenium 做分布式自动化测试，部署多个重点关注的版本，进行自动化测试，对比差异。","answer":"","biz_type":1,"qid":5,"subject":"","title":"介绍chrome浏览器几个版本"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["滴滴","头条","网易","易车","脉脉","掌门一对一","虎扑","挖财","爱范儿"],"date":"Fri, 19 Jun 2020 16:21:40 GMT","favorite_num":22,"qid":8,"qtype":"short_answer","short_answer":{"analysis":"**1）浏览器缓存策略**\\n\\n浏览器每次发起请求时，先在本地缓存中查找结果以及缓存标识，根据缓存标识来判断是否使用本地缓存。如果缓存有效，则使\\n用本地缓存；否则，则向服务器发起请求并携带缓存标识。根据是否需向服务器发起HTTP请求，将缓存过程划分为两个部分：\\n强制缓存和协商缓存，强缓优先于协商缓存。\\n\\n- 强缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。\\n- 协商缓存，让客户端与服务器之间能实现缓存文件是否更新的验证、提升缓存的复用率，将缓存信息中的Etag和Last-Modified\\n  通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。\\n\\nHTTP缓存都是从第二次请求开始的：\\n\\n- 第一次请求资源时，服务器返回资源，并在response header中回传资源的缓存策略；\\n- 第二次请求时，浏览器判断这些请求参数，击中强缓存就直接200，否则就把请求参数加到request header头中传给服务器，看是否击中协商缓存，击中则返回304，否则服务器会返回新的资源。这是缓存运作的一个整体流程图：\\n\\n![img](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-8.png)\\n\\n**2）强缓存**\\n\\n- 强缓存命中则直接读取浏览器本地的资源，在network中显示的是from memory或者from disk\\n- 控制强制缓存的字段有：Cache-Control（http1.1）和Expires（http1.0）\\n- Cache-control是一个相对时间，用以表达自上次请求正确的资源之后的多少秒的时间段内缓存有效。\\n- Expires是一个绝对时间。用以表达在这个时间点之前发起请求可以直接从浏览器中读取数据，而无需发起请求\\n- Cache-Control的优先级比Expires的优先级高。前者的出现是为了解决Expires在浏览器时间被手动更改导致缓存判断错误的问题。\\n如果同时存在则使用Cache-control。\\n\\n**3）强缓存-expires**\\n\\n- 该字段是服务器响应消息头字段，告诉浏览器在过期时间之前可以直接从浏览器缓存中存取数据。\\n\\n- Expires 是 HTTP 1.0 的字段，表示缓存到期时间，是一个绝对的时间 (当前时间+缓存时间)。在响应消息头中，设置这个字段之后，就可以告诉浏览器，在未过期之前不需要再次请求。\\n\\n- 由于是绝对时间，用户可能会将客户端本地的时间进行修改，而导致浏览器判断缓存失效，重新请求该资源。此外，即使不考虑修改，时差或者误差等因素也可能造成客户端与服务端的时间不一致，致使缓存失效。\\n\\n- 优势特点  \\n  - 1、HTTP 1.0 产物，可以在HTTP 1.0和1.1中使用，简单易用。\\n  - 2、以时刻标识失效时间。\\n- 劣势问题    \\n  - 1、时间是由服务器发送的(UTC)，如果服务器时间和客户端时间存在不一致，可能会出现问题。\\n  - 2、存在版本问题，到期之前的修改客户端是不可知的。\\n\\n**4）强缓存-cache-control**\\n\\n- 已知Expires的缺点之后，在HTTP/1.1中，增加了一个字段Cache-control，该字段表示资源缓存的最大有效时间，在该时间内，客户端不需要向服务器发送请求。\\n\\n- 这两者的区别就是前者是绝对时间，而后者是相对时间。下面列举一些 `Cache-control` 字段常用的值：(完整的列表可以查看MDN)\\n  - `max-age`：即最大有效时间。\\n  - `must-revalidate`：如果超过了 `max-age` 的时间，浏览器必须向服务器发送请求，验证资源是否还有效。\\n  - `no-cache`：不使用强缓存，需要与服务器验证缓存是否新鲜。\\n  - `no-store`: 真正意义上的“不要缓存”。所有内容都不走缓存，包括强制和对比。\\n  - `public`：所有的内容都可以被缓存 (包括客户端和代理服务器， 如 CDN)\\n  - `private`：所有的内容只有客户端才可以缓存，代理服务器不能缓存。默认值。\\n\\n- **Cache-control 的优先级高于 Expires**，为了兼容 HTTP/1.0 和 HTTP/1.1，实际项目中两个字段都可以设置。\\n\\n- 该字段可以在请求头或者响应头设置，可组合使用多种指令：\\n  - **可缓存性**：\\n    - public：default，浏览器和缓存服务器都可以缓存页面信息\\n    - private：代理服务器不可缓存，只能被单个用户缓存\\n    - no-cache：浏览器器和服务器都不应该缓存页面信息，但仍可缓存，只是在缓存前需要向服务器确认资源是否被更改。可配合private，\\n      过期时间设置为过去时间。\\n    - only-if-cache：客户端只接受已缓存的响应\\n  - **到期**\\n    - max-age=<seconds>：缓存存储的最大周期，超过这个周期被认为过期。\\n    - s-maxage=<seconds>：设置共享缓存，比如can。会覆盖max-age和expires。\\n    - max-stale[=<seconds>]：客户端愿意接收一个已经过期的资源\\n    - min-fresh=<seconds>：客户端希望在指定的时间内获取最新的响应\\n    - stale-while-revalidate=<seconds>：客户端愿意接收陈旧的响应，并且在后台一部检查新的响应。时间代表客户端愿意接收陈旧响应\\n      的时间长度。\\n    - stale-if-error=<seconds>：如新的检测失败，客户端则愿意接收陈旧的响应，时间代表等待时间。\\n  - **重新验证和重新加载**\\n    - must-revalidate：如页面过期，则去服务器进行获取。\\n    - proxy-revalidate：用于共享缓存。\\n    - immutable：响应正文不随时间改变。\\n  - **其他**\\n    - no-store：绝对禁止缓存\\n    - no-transform：不得对资源进行转换和转变。例如，不得对图像格式进行转换。\\n- 优势特点    \\n  - 1、HTTP 1.1 产物，以时间间隔标识失效时间，解决了Expires服务器和客户端相对时间的问题。 \\n  - 2、比Expires多了很多选项设置。\\n- 劣势问题    \\n  - 1、存在版本问题，到期之前的修改客户端是不可知的。\\n\\n**5）协商缓存**\\n\\n- 协商缓存的状态码由服务器决策返回200或者304\\n- 当浏览器的强缓存失效的时候或者请求头中设置了不走强缓存，并且在请求头中设置了If-Modified-Since 或者 If-None-Match 的时候，会将这两个属性值到服务端去验证是否命中协商缓存，如果命中了协商缓存，会返回 304 状态，加载浏览器缓存，并且响应头会设置 Last-Modified 或者 ETag 属性。\\n- 对比缓存在请求数上和没有缓存是一致的，但如果是 304 的话，返回的仅仅是一个状态码而已，并没有实际的文件内容，因此 在响应体体积上的节省是它的优化点。\\n- 协商缓存有 2 组字段(不是两个)，控制协商缓存的字段有：Last-Modified/If-Modified-since（http1.0）和Etag/If-None-match（http1.1）\\n- Last-Modified/If-Modified-since表示的是服务器的资源最后一次修改的时间；Etag/If-None-match表示的是服务器资源的唯一标\\n识，只要资源变化，Etag就会重新生成。\\n- Etag/If-None-match的优先级比Last-Modified/If-Modified-since高。\\n\\n**6）协商缓存-协商缓存-Last-Modified/If-Modified-since**\\n\\n- 1.服务器通过 `Last-Modified` 字段告知客户端，资源最后一次被修改的时间，例如 `Last-Modified: Mon, 10 Nov 2018 09:10:11 GMT`\\n- 2.浏览器将这个值和内容一起记录在缓存数据库中。\\n- 3.下一次请求相同资源时时，浏览器从自己的缓存中找出“不确定是否过期的”缓存。因此在请求头中将上次的 `Last-Modified` 的值写入到请求头的 `If-Modified-Since` 字段\\n- 4.服务器会将 `If-Modified-Since` 的值与 `Last-Modified` 字段进行对比。如果相等，则表示未修改，响应 304；反之，则表示修改了，响应 200 状态码，并返回数据。\\n- 优势特点 \\n  - 1、不存在版本问题，每次请求都会去服务器进行校验。服务器对比最后修改时间如果相同则返回304，不同返回200以及资源内容。\\n- 劣势问题 \\n  - 2、只要资源修改，无论内容是否发生实质性的变化，都会将该资源返回客户端。例如周期性重写，这种情况下该资源包含的数据实际上一样的。 \\n  - 3、以时刻作为标识，无法识别一秒内进行多次修改的情况。 如果资源更新的速度是秒以下单位，那么该缓存是不能被使用的，因为它的时间单位最低是秒。\\n  - 4、某些服务器不能精确的得到文件的最后修改时间。\\n  - 5、如果文件是通过服务器动态生成的，那么该方法的更新时间永远是生成的时间，尽管文件可能没有变化，所以起不到缓存的作用。\\n\\n**7）协商缓存-Etag/If-None-match**\\n\\n- 为了解决上述问题，出现了一组新的字段 `Etag` 和 `If-None-Match`\\n- `Etag` 存储的是文件的特殊标识(一般都是 hash 生成的)，服务器存储着文件的 `Etag` 字段。之后的流程和 `Last-Modified` 一致，只是 `Last-Modified` 字段和它所表示的更新时间改变成了 `Etag` 字段和它所表示的文件 hash，把 `If-Modified-Since` 变成了 `If-None-Match`。服务器同样进行比较，命中返回 304, 不命中返回新资源和 200。\\n- 浏览器在发起请求时，服务器返回在Response header中返回请求资源的唯一标识。在下一次请求时，会将上一次返回的Etag值赋值给If-No-Matched并添加在Request Header中。服务器将浏览器传来的if-no-matched跟自己的本地的资源的ETag做对比，如果匹配，则返回304通知浏览器读取本地缓存，否则返回200和更新后的资源。\\n- **Etag 的优先级高于 Last-Modified**。\\n- 优势特点 \\n  - 1、可以更加精确的判断资源是否被修改，可以识别一秒内多次修改的情况。 \\n  - 2、不存在版本问题，每次请求都回去服务器进行校验。\\n- 劣势问题 \\n  - 1、计算ETag值需要性能损耗。\\n  - 2、分布式服务器存储的情况下，计算ETag的算法如果不一样，会导致浏览器从一台服务器上获得页面内容后到另外一台服务器上进行验证时现ETag不匹配的情况。\\n","answer":"","biz_type":1,"qid":8,"subject":"","title":"说一下 Http 缓存策略，有什么区别，分别解决了什么问题"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["滴滴"],"date":"Fri, 19 Jun 2020 16:21:40 GMT","favorite_num":2,"qid":10,"qtype":"short_answer","short_answer":{"analysis":"####  1）XSS：跨站脚本攻击\\n就是攻击者想尽一切办法将可以执行的代码注入到网页中。\\n##### 存储型（server端）：\\n  - 场景：见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。\\n  - 攻击步骤：\\n    - i）攻击者将恶意代码提交到目标网站的数据库中\\n    - ii）用户打开目标网站时，服务端将恶意代码从数据库中取出来，拼接在HTML中返回给浏览器\\n    - iii）用户浏览器在收到响应后解析执行，混在其中的恶意代码也同时被执行\\n    - iv）恶意代码窃取用户数据，并发送到指定攻击者的网站，或者冒充用户行为，调用目标网站的接口，执行恶意操作\\n##### 反射型（Server端）\\n与存储型的区别在于，存储型的恶意代码存储在数据库中，反射型的恶意代码在URL上\\n- 场景：通过 URL 传递参数的功能，如网站搜索、跳转等。\\n- 攻击步骤：\\n    - i）攻击者构造出特殊的 URL，其中包含恶意代码。\\n    - ii）用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。\\n    - iii）用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。\\n    - iv）恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。\\n##### Dom 型(浏览器端）\\nDOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。\\n- 场景：通过 URL 传递参数的功能，如网站搜索、跳转等。\\n- 攻击步骤：\\n    - i）攻击者构造出特殊的 URL，其中包含恶意代码。\\n    - ii）用户打开带有恶意代码的 URL。\\n    - iii）用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。\\n    - iv）恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。\\n##### 预防方案：（防止攻击者提交恶意代码，防止浏览器执行恶意代码）\\n- i）对数据进行严格的输出编码：如HTML元素的编码，JS编码，CSS编码，URL编码等等\\n  - 避免拼接 HTML；Vue/React 技术栈，避免使用 v-html / dangerouslySetInnerHTML\\n- ii）CSP HTTP Header，即 Content-Security-Policy、X-XSS-Protection\\n  - 增加攻击难度，配置CSP(本质是建立白名单，由浏览器进行拦截)\\n  - `Content-Security-Policy: default-src \'self\' `-所有内容均来自站点的同一个源（不包括其子域名）\\n  -  `Content-Security-Policy: default-src \'self\' *.trusted.com`-允许内容来自信任的域名及其子域名 (域名不必须与CSP设置所在的域名相同)\\n  - `Content-Security-Policy: default-src https://yideng.com`-该服务器仅允许通过HTTPS方式并仅从yideng.com域名来访问文档\\n- iii）输入验证：比如一些常见的数字、URL、电话号码、邮箱地址等等做校验判断\\n- iv）开启浏览器XSS防御：Http Only cookie，禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。\\n- v）验证码\\n\\n#### 2）CSRF：跨站请求伪造\\n攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。\\n##### 攻击流程举例\\n- i）受害者登录 a.com，并保留了登录凭证（Cookie）\\n- ii）攻击者引诱受害者访问了b.com\\n- iii）b.com 向 a.com 发送了一个请求：a.com/act=xx浏览器会默认携带a.com的Cookie\\n- iv）a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求\\n- v）a.com以受害者的名义执行了act=xx\\n- vi）攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作\\n##### 攻击类型\\n- i）GET型：如在页面的某个 img 中发起一个 get 请求\\n- ii）POST型：通过自动提交表单到恶意网站\\n- iii）链接型：需要诱导用户点击链接\\n##### 预防方案：\\nCSRF通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对CSRF的防护能力来提升安全性。）\\n- i）同源检测：通过Header中的Origin Header 、Referer Header 确定，但不同浏览器可能会有不一样的实现，不能完全保证\\n- ii）CSRF Token 校验：将CSRF Token输出到页面中（通常保存在Session中），页面提交的请求携带这个Token，服务器验证Token是否\\n正确\\n- iii）双重cookie验证：\\n  - 流程：\\n    - 步骤1：在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串（例如csrfcookie=v8g9e4ksfhw）\\n    - 步骤2：在前端向后端发起请求时，取出Cookie，并添加到URL的参数中（接上例POST https://www.a.com/comment?csrfcookie=v8g9e4ksfhw）\\n    - 步骤3：后端接口验证Cookie中的字段与URL参数中的字段是否一致，不一致则拒绝。\\n  - 优点：\\n    - 无需使用Session，适用面更广，易于实施。\\n    - Token储存于客户端中，不会给服务器带来压力。\\n    - 相对于Token，实施成本更低，可以在前后端统一拦截校验，而不需要一个个接口和页面添加。\\n  - 缺点：\\n    -Cookie中增加了额外的字段。\\n    -如果有其他漏洞（例如XSS），攻击者可以注入Cookie，那么该防御方式失效。\\n    -难以做到子域名的隔离。\\n    -为了确保Cookie传输安全，采用这种防御方式的最好确保用整站HTTPS的方式，如果还没切HTTPS的使用这种方式也会有风险。\\n- iv）Samesite Cookie属性：Google起草了一份草案来改进HTTP协议，那就是为Set-Cookie响应头新增Samesite属性，它用来标明这个 Cookie是个“同站 Cookie”，同站Cookie只能作为第一方Cookie，不能作为第三方Cookie，Samesite 有两个属性值，Strict 为任何情况下都不可以作为第三方 Cookie ，Lax 为可以作为第三方 Cookie , 但必须是Get请求\\n\\n#### 3）iframe 安全\\n##### 说明：\\n- i）嵌入第三方 iframe 会有很多不可控的问题，同时当第三方 iframe 出现问题或是被劫持之后，也会诱发安全性问题\\n- ii）点击劫持\\n  - 攻击者将目标网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，诱导用户点击。\\n- iii）禁止自己的 iframe 中的链接外部网站的JS\\n##### 预防方案：\\n- i）为 iframe 设置 sandbox 属性，通过它可以对iframe的行为进行各种限制，充分实现“最小权限“原则\\n- ii）服务端设置 X-Frame-Options Header头，拒绝页面被嵌套，X-Frame-Options 是HTTP 响应头中用来告诉浏览器一个页面是否可以嵌入 <iframe> 中\\n  - eg.`X-Frame-Options: SAMEORIGIN`\\n  - SAMEORIGIN: iframe 页面的地址只能为同源域名下的页面\\n  - ALLOW-FROM: 可以嵌套在指定来源的 iframe 里\\n  - DENY: 当前页面不能被嵌套在 iframe 里\\n- iii）设置 CSP 即 Content-Security-Policy 请求头\\n- iv）减少对 iframe 的使用\\n\\n####  4）错误的内容推断\\n##### 说明：\\n文件上传类型校验失败后，导致恶意的JS文件上传后，浏览器 Content-Type Header 的默认解析为可执行的 JS 文件\\n##### 预防方案：\\n设置 X-Content-Type-Options 头\\n\\n####  5）第三方依赖包\\n减少对第三方依赖包的使用，如之前 npm 的包如：event-stream 被爆出恶意攻击数字货币；\\n\\n####  6）HTTPS\\n##### 描述：\\n黑客可以利用SSL Stripping这种攻击手段，强制让HTTPS降级回HTTP，从而继续进行中间人攻击。\\n##### 预防方案：\\n使用HSTS（HTTP Strict Transport Security），它通过下面这个HTTP Header以及一个预加载的清单，来告知浏览器和网站进行通信的时候强制性的使用HTTPS，而不是通过明文的HTTP进行通信。这里的“强制性”表现为浏览器无论在何种情况下都直接向务器端发起HTTPS请求，而不再像以往那样从HTTP跳转到HTTPS。另外，当遇到证书或者链接不安全的时候，则首先警告用户，并且不再\\n用户选择是否继续进行不安全的通信。\\n\\n#### 7）本地存储数据\\n避免重要的用户信息存在浏览器缓存中\\n\\n#### 8）静态资源完整性校验\\n##### 描述\\n使用 内容分发网络 (CDNs) 在多个站点之间共享脚本和样式表等文件可以提高站点性能并节省带宽。然而，使用CDN也存在风险，如果攻击者获得对 CDN 的控制权，则可以将任意恶意内容注入到 CDN 上的文件中 （或完全替换掉文件），因此可能潜在地攻击所有从该 CDN 获取文件的站点。\\n##### 预防方案\\n将使用 base64 编码过后的文件哈希值写入你所引用的 <script> 或 <link> 标签的 integrity 属性值中即可启用子资源完整性能。\\n\\n#### 9）网络劫持\\n##### 描述：\\n- DNS劫持（涉嫌违法）：修改运行商的 DNS 记录，重定向到其他网站。DNS 劫持是违法的行为，目前 DNS 劫持已被监管，现在很少见 DNS 劫持\\n- HTTP劫持：前提有 HTTP 请求。因 HTTP 是明文传输，运营商便可借机修改 HTTP 响应内容（如加广告）。\\n##### 预防方案\\n全站 HTTPS\\n\\n#### 10）中间人攻击：\\n中间人攻击（Man-in-the-middle attack, MITM），指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者窃听、篡改甚至完全控制。没有进行严格的证书校验是中间人攻击着手点。目前大多数加密协议都提供了一些特殊认证方法以阻止中间人攻击。如 SSL （安全套接字层）协议可以验证参与通讯的用户的证书是否有权威、受信任的数字证书认证机构颁发，并且能执行双向身份认证。攻击场景如用户在一个未加密的 WiFi下访问网站。在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容。\\n##### 场景\\n- i）在一个未加密的Wi-Fi 无线接入点的接受范围内的中间人攻击者，可以将自己作为一个中间人插入这个网络\\n- ii）Fiddler / Charles （花瓶）代理工具\\n- iii）12306 之前的自己证书\\n##### 过程\\n- i）客户端发送请求到服务端，请求被中间人截获\\n- ii）服务器向客户端发送公钥\\n- iii）中间人截获公钥，保留在自己手上。然后自己生成一个【伪造的】公钥，发给客户端\\n- iv）客户端收到伪造的公钥后，生成加密hash值发给服务器\\n- v）中间人获得加密hash值，用自己的私钥解密获得真秘钥,同时生成假的加密hash值，发给服务器\\n- vi）服务器用私钥解密获得假密钥,然后加密数据传输给客户端\\n##### 使用抓包工具fiddle来进行举例说明\\n- 1. 首先通过一些途径在客户端安装证书\\n- 2. 然后客户端发送连接请求，fiddle在中间截取请求，并返回自己伪造的证书\\n- 3. 客户端已经安装了攻击者的根证书，所以验证通过\\n- 4. 客户端就会正常和fiddle进行通信，把fiddle当作正确的服务器\\n- 5. 同时fiddle会跟原有的服务器进行通信，获取数据以及加密的密钥，去解密密钥\\n##### 常见攻击方式\\n- 1. 嗅探：嗅探是一种用来捕获流进和流出的网络数据包的技术，就好像是监听电话一样。比如：抓包工具\\n- 2. 数据包注入：在这种，攻击者会将恶意数据包注入到常规数据中的，因为这些恶意数据包是在正常的数据包里面的，用户和系统都很难发现这个内容。\\n- 3. 会话劫持：当我们进行一个网站的登录的时候到退出登录这个时候，会产生一个会话，这个会话是攻击者用来攻击的首要目标，因为这个会话，包含了用户大量的数据和私密信息。\\n- 4. SSL剥离：HTTPS是通过SSL/TLS进行加密过的，在SSL剥离攻击中，会使SSL/TLS连接断开，让受保护的HTTPS，变成不受\\n保护的HTTP（这对于网站非常致命）\\n- 5. DNS欺骗，攻击者往往通过入侵到DNS服务器，或者篡改用户本地hosts文件，然后去劫持用户发送的请求，然后转发到攻击者想要转发到的服务器\\n- 6. ARP欺骗，ARP(address resolution protocol)地址解析协议，攻击者利用APR的漏洞，用当前局域网之间的一台服务器，来冒充客户端想要请求的服务端，向客户端发送自己的MAC地址，客户端无从得到真正的主机的MAC地址，所以，他会把这个地址当作真正\\n的主机来进行通信，将MAC存入ARP缓存表。\\n- 7. 代理服务器\\n##### 预防方案：\\n- i）用可信的第三方CA厂商\\n- ii）不下载未知来源的证书，不要去下载一些不安全的文件\\n- iii）确认你访问的URL是HTTPS的，确保网站使用了SSL，确保禁用一些不安全的SSL，只开启：TLS1.1，TLS1.2\\n- iv）不要使用公用网络发送一些敏感的信息\\n- v）不要去点击一些不安全的连接或者恶意链接或邮件信息\\n\\n#### 11）sql 注入\\n##### 描述\\n就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗数据库服务器执行恶意的SQL命令,从而达到和服务器\\n进行直接的交互\\n##### 预防方案：\\n- i）后台进行输入验证，对敏感字符过滤。\\n- ii）使用参数化查询，能避免拼接SQL，就不要拼接SQL语句。\\n\\n#### 12）前端数据安全：\\n##### 描述\\n反爬虫。如猫眼电影、天眼查等等，以数据内容为核心资产的企业\\n##### 预防方案：\\n- i）font-face拼接方式：猫眼电影、天眼查\\n- ii）background 拼接：美团\\n- iii）伪元素隐藏：汽车之家\\n- iv）元素定位覆盖式：去哪儿\\n- v）iframe 异步加载：网易云音乐\\n\\n#### 13）其他建议\\n- i）定期请第三方机构做安全性测试，漏洞扫描\\n- ii）使用第三方开源库做上线前的安全测试，可以考虑融合到CI中\\n- iii）code review 保证代码质量\\n- iv）默认项目中设置对应的 Header 请求头，如 X-XSS-Protection、 X-Content-Type-Options 、X-Frame-Options Header、Content-Security-Policy 等等\\n- v）对第三方包和库做检测：NSP(Node Security Platform)，Snyk","answer":"","biz_type":1,"qid":10,"subject":"","title":"前端安全、中间人攻击"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["网易"],"date":"Fri, 19 Jun 2020 16:20:44 GMT","favorite_num":3,"qid":695,"qtype":"short_answer","short_answer":{"analysis":"**合理使用HSTS**\\n\\n**什么是HSTS**\\n\\n HSTS（HTTP Strict Transport Security, HTTP严格传输安全协议）表明网站已经实现了TLS，要求浏览器对用户明文访问的Url重写成HTTPS，避免了始终强制302重定向的延时开销。\\n\\n**HSTS的实现原理** \\n\\n当浏览器第一次HTTP请求服务器时，返回的响应头中增加Strict-Transport-Security，告诉浏览器在指定的时间内，这个网站必须通过HTTPS协议来访问。\\n\\n也就是对于这个网站的HTTP地址，浏览器需要现在本地替换为HTTPS之后再发送请求。\\n","answer":"","biz_type":1,"qid":695,"subject":"","title":"301、302 的 https 被挟持怎么办？"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["网易"],"date":"Fri, 19 Jun 2020 16:20:44 GMT","favorite_num":2,"qid":696,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":696,"subject":"","title":"介绍 Http2 特性，Http2 怎么确保文件同时传输不会报错"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["爱范儿","乘法云"],"date":"Fri, 19 Jun 2020 16:20:44 GMT","favorite_num":2,"qid":700,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":700,"subject":"","title":"列举并解释一下 http 的所有请求方法，"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["玄武科技"],"date":"Fri, 19 Jun 2020 16:20:44 GMT","favorite_num":2,"qid":709,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":709,"subject":"","title":"列举出在浏览器中，页面加载过程中发出了哪些事件？并画出这些事件的执行顺序？"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["玄武科技"],"date":"Fri, 19 Jun 2020 16:20:44 GMT","favorite_num":2,"qid":716,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":716,"subject":"","title":"请列出 HTTP/1.1 协议 Response 状态码：20x、30x、40x、50x 等各区间的含义，并说明 Action 在 Restful API 中分别使用哪些 Http 副词(action)表现出 CRUD?"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["58"],"date":"Fri, 19 Jun 2020 16:20:44 GMT","favorite_num":3,"qid":734,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":734,"subject":"","title":"catch-control 有哪些设定值"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":[],"date":"Fri, 19 Jun 2020 16:20:44 GMT","favorite_num":2,"qid":762,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":762,"subject":"","title":"HTTP2.0的多路复⽤和HTTP1.X中的⻓连接复⽤有什么区别？"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":[],"date":"Fri, 19 Jun 2020 16:20:44 GMT","favorite_num":2,"qid":763,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":763,"subject":"","title":"HTTP2.0多路复⽤有多好？"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":[],"date":"Fri, 19 Jun 2020 16:20:44 GMT","favorite_num":2,"qid":771,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":771,"subject":"","title":"http请求由什么组成？"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["寺库"],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":2,"qid":513,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":513,"subject":"","title":"介绍一下网络的五层模型"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["寺库"],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":2,"qid":514,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":514,"subject":"","title":"介绍 SSL 与 TLS"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["宝宝树"],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":2,"qid":520,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":520,"subject":"","title":"服务端怎么做统一的状态处理"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["会小二"],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":2,"qid":606,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":606,"subject":"```js\\nA.HTTP 协议是在 TCP/IP 协议之上的应用层协议\\nB.HTTP 1.1 缺省支持 keep-alive\\nC.WebSocket 是由 Socket 发展而来的新规范\\nD.WebSocket 可以建立持久连接\\n\\n```\\n","title":"以下说法中对协议描述不正确的是？(单选题)"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["会小二"],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":2,"qid":607,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":607,"subject":"```js\\nA.Last-Modified\\nB.Etag\\nC.Referer\\nD.Authorization\\n\\n```\\n","title":"以下哪些是 HTTP 请求中浏览器缓存机制会用到的协议头？(单选题)"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["会小二","58"],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":3,"qid":618,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":618,"subject":"","title":"请写下你对协商缓存和强缓存的理解？"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":[],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":2,"qid":621,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":621,"subject":"","title":"给出页面的加载顺序"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":[],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":2,"qid":630,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":630,"subject":"","title":"详细描述一个 http 请求从发起请求到收到响应的全部过程(越细越好)"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":[],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":2,"qid":631,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":631,"subject":"","title":"简述静态链接和动态链接的区别，并举例说明"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["高思教育"],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":2,"qid":642,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":642,"subject":"","title":"缓存有哪些？前端缓存有哪些？怎么用？如何和后台配合"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":[],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":3,"qid":647,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":647,"subject":"","title":"Dom tree 和 cssdom 是如何合并成 render tree 的"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["快手"],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":2,"qid":667,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":667,"subject":"","title":"cdn 分布式部署，如果处理用户请求最近的资源"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["快手"],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":2,"qid":668,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":668,"subject":"","title":"说一下缓存有哪几种，具体都是怎么实现和比较的，缓存优先级，相互之间的对比"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["头条"],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":2,"qid":670,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":670,"subject":"","title":"说下你对浏览器缓存理解"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["酷狗"],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":2,"qid":678,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":678,"subject":"","title":"Http 连接是如何复用的"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["喜马拉雅","寺库"],"date":"Fri, 19 Jun 2020 16:20:42 GMT","favorite_num":2,"qid":469,"qtype":"short_answer","short_answer":{"analysis":"HTTPS建立安全通道过程及Https 的加密过程和获取加密秘钥的过程，在https使用对称密钥发送报文时，安全通道已建好\\n\\n1. Client发起一个HTTPS（https://www.baidu.com/）的请求，根据RFC2818的规定，Client知道需要连接Server的443（默认）端口。\\n2. Server把事先配置好的公钥证书（public key certificate）返回给客户端。\\n3. Client验证公钥证书：比如是否在有效期内，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的Root证书或者Client内置的Root证书）。如果验证通过则继续，不通过则显示警告信息。\\n4. Client使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给Server。\\n5. Server使用自己的私钥（private key）解密这个消息，得到对称密钥。至此，Client和Server双方都持有了相同的对称密钥。\\n6. Server使用对称密钥加密“明文内容A”，发送给Client。\\n7. Client使用对称密钥解密响应的密文，得到“明文内容A”。\\n8. Client再次发起HTTPS的请求，使用对称密钥加密请求的“明文内容B”，然后Server使用对称密钥解密密文，得到“明文内容B”。\\n\\n","answer":"","biz_type":1,"qid":469,"subject":"","title":"HTTPS 怎么建立安全通道，Https 的加密过程"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":[],"date":"Fri, 19 Jun 2020 16:20:42 GMT","favorite_num":2,"qid":326,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":326,"subject":"","title":"客户端缓存有几种方式？浏览器出现 from disk、from memory 的策略是啥"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":[],"date":"Fri, 19 Jun 2020 16:20:42 GMT","favorite_num":2,"qid":327,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":327,"subject":"","title":"什么是 http？什么是 http2？说下 http 与 http2 的工作流程"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":[],"date":"Fri, 19 Jun 2020 16:20:42 GMT","favorite_num":2,"qid":328,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":328,"subject":"","title":"客户端如何发送 http 请求"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["网易"],"date":"Fri, 19 Jun 2020 16:20:42 GMT","favorite_num":2,"qid":369,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":369,"subject":"","title":"http1.1 时如何复用 tcp 连接"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["网易"],"date":"Fri, 19 Jun 2020 16:20:42 GMT","favorite_num":2,"qid":373,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":373,"subject":"","title":"介绍浏览器事件流向"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["滴滴"],"date":"Fri, 19 Jun 2020 16:20:42 GMT","favorite_num":2,"qid":388,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":388,"subject":"","title":"cookie 放哪里，cookie 能做的事情和存在的价值"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["滴滴"],"date":"Fri, 19 Jun 2020 16:20:42 GMT","favorite_num":2,"qid":389,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":389,"subject":"","title":"cookie 和 token 都存放在 header 里面，为什么只劫持前者"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["寺库"],"date":"Fri, 19 Jun 2020 16:20:42 GMT","favorite_num":2,"qid":424,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":424,"subject":"","title":"cookie 的引用为了解决什么问题"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["喜马拉雅"],"date":"Fri, 19 Jun 2020 16:20:42 GMT","favorite_num":2,"qid":468,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":468,"subject":"","title":"403、301、302 是什么"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["喜马拉雅"],"date":"Fri, 19 Jun 2020 16:20:42 GMT","favorite_num":2,"qid":471,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":471,"subject":"","title":"介绍下数字签名的原理"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["完美世界","网易","脉脉","高思教育"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":2,"qid":144,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":144,"subject":"","title":"Http1 和 Http2 有什么区别，和 http1.1 相比，http2 都有什么特性"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["网易"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":2,"qid":153,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":153,"subject":"","title":"说一下 etag 和 lastmodify 的区别"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["网易","易车"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":2,"qid":154,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":154,"subject":"","title":"强缓存都有哪些方法来控制"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["网易","易车"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":2,"qid":155,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":155,"subject":"","title":"协商缓存都有哪些参数"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["易车"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":2,"qid":166,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":166,"subject":"","title":"请求是异步的为什么会造成阻塞"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["头条"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":2,"qid":181,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":181,"subject":"","title":"CDN 有哪些优化静态资源加载速度的机制"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["高德"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":2,"qid":203,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":203,"subject":"","title":"说一下 Nginx 的缓存策略，强缓存与弱缓存的区别，二者的使用场景"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["自如","挖财","腾讯应用宝","沪江","喜马拉雅"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":2,"qid":234,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":234,"subject":"","title":"请描述 CSRF、XSS 的基本概念、攻击原理和防御措施？"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["自如"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":2,"qid":235,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":235,"subject":"","title":"请描述提升页面性能的方式有哪些，如何进行首页加载优化"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["自如","滴滴"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":2,"qid":237,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":237,"subject":"","title":"Http报文的请求会有几个部分？请写出 HTTP 报文的组成部分"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["自如"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":2,"qid":238,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":238,"subject":"","title":"301，302，304 的区别"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":[],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":2,"qid":256,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":256,"subject":"","title":"说一下 https 获取加密秘钥的过程"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["掌门一对一","滴滴","兑吧","寺库"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":2,"qid":261,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":261,"subject":"","title":"localstorage、sessionStorage、indexDB 和 cookie 的区别"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["虎扑"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":2,"qid":268,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":268,"subject":"","title":"点击一个按钮，浏览器会做些什么"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["腾讯应用宝"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":2,"qid":286,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":286,"subject":"","title":"LocalStorage 加密原理"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["腾讯应用宝","喜马拉雅"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":2,"qid":288,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":288,"subject":"","title":"说一下常见的状态码"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["腾讯应用宝"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":2,"qid":290,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":290,"subject":"","title":"304 页面的原理"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["菜鸟网络","头条"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":2,"qid":277,"qtype":"short_answer","short_answer":{"analysis":"\\n**三次握手详细版**\\n\\n- 第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。\\n- 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；\\n- 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。\\n\\n![三次握手](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-277-tcp.png)\\n\\n**三次握手简洁版**\\n\\n1. 客户端向服务端发送连接请求报文段。\\n2. 服务端收到连接请求报文段后，如果同意连接，则会发送一个应答\\n3. 当客户端收到连接同意的应答后，还要向服务端发送一个确认报文段，表示：服务端发来的连接同意应答已经成功收到。","answer":"","biz_type":1,"qid":277,"subject":"","title":"TCP 三次握手"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["老虎"],"date":"Fri, 19 Jun 2020 16:20:40 GMT","favorite_num":2,"qid":114,"qtype":"short_answer","short_answer":{"analysis":"#### 浏览器渲染流程详细版\\n\\n**1）DOM树构建：** \\n\\n渲染器进程接受到的数据也就是HTML。渲染器进程的核心任务就是把html、css、js、image等资源渲染成用户可以交互的web页面。渲染器进程的主线程将html进行解析，构造DOM数据结构。DOM也就是文档对象模型，是浏览器对页面在其内部的表示形式，是web开发程序员可以通过JS与之交互的数据结构和API。html首先通过tokeniser标记化，通过词法分析将输入的html内容解析成多个标记，根据识别后的标记进行DOM树构造，在DOM树构建过程中会创建document对象，然后以document的为根节点的DOM树，不断进行修改，向其中添加各种元素。\\n\\n**2）渲染阻塞：** \\n\\nhtml代码中往往会引入一些额外的资源，比如图片、CSS、JS脚本等，图片和CSS这些资源需要通过网络下载或从缓存中直接加载，这些资源不会阻塞html的解析，因为他们不会影响DOM树的生成，但当HTML解析过程中遇到script标签，就会停止html解析流程，转而去加载解析并且执行JS。这是因为浏览器并不知道JS执行是否会改变当前页面的HTML结构，如果JS代码里用了document.write方法来修改html，之前的和html解析就没有任何意义了，这也就是为什么我们一直说要把script标签要放在合适的位置，或者使用async或defer属性来异步加载执行JS。\\n\\n**3）Layout Tree：** \\n\\n在html解析完成后，我们就会获得一个DOM Tree（树），但我们还不知道DOM Tree上的每个节点应该长什么样子，主线程需要解析CSS，并确定每个DOM节点的计算样式，即使你没有提供自定义的CSS样式，浏览器会有自己默认的样式表，比如h2的字体要比h3的大。在知道DOM结构和每个节点的样式后，我们接下来需要知道每个节点需要放在页面上的哪个位置，也就是节点的坐标以及该节点需要占用多大的区域，这个阶段被称为layout布局，主线程通过遍历dom和计算好的样式来生成Layout Tree。Layout Tree上的每个节点都记录了x、y坐标和边框尺寸。这需要注意的是DOM Tree和Layout Tree并不是一一对应的，设置了display:none的节点不会出现在Layout Tree上，而在before伪类中添加了content值的元素content中的内容会出现在Layout Tree上，不会出现在DOM树里，这是因为DOM是通过HTML解析获得的，并不关系样式，而Layout Tree是根据DOM和计算好的样式来生成，Layout Tree是和最后展示在屏幕上节点是对应的。\\n\\n**4）绘制（paint）：** \\n\\n现在我们已经知道了元素的大小形状和位置，但还不知道以什么样的顺序绘制（paint）这个节点，例如z-index这个属性会影响节点绘制的层级关系，如果按照dom的层级结构来绘制页面则会导致错误的渲染。所以为了保证在屏幕上展示正确的层级，主线程遍历Layout Tree创建一个绘制记录表（Paint Record），该表记录了绘制的顺序，这个阶段配称为绘制（Paint）。\\n\\n**5）栅格化：** \\n\\n现在知道了文档的绘制顺序，终于到了该把这些信息转化成像素点显示在屏幕上了，这个行为被称为栅格化（Rastering）。chrome最早使用了一种很简单的方式，只栅格化用户可视区域的内容，当用户滚动页面时，再栅格化更多的内容来填充缺失的部分，这种方式带来的问题就是会导致展示延迟。现在chrome进行了优化升级，使用了一种更为复杂的栅格化流程叫做合成（compositing），合成是一种将页面各个部分分成多个图层，分别对其进行栅格化，并在合成器线程（compositor Thread）中单独进行合成页面，简单来说就是页面所有的元素按照某种规则进行分图层，并把图层都栅格化好了，然后只需要把可视区的内容组合成一帧展示给用户即可。\\n\\n**6）layer tree：** \\n\\n主线程遍历Layout Tree生成layer tree，当Layer Tree生成完毕和绘制顺序确定后，主线程将这些信息传递给合成器线程，合成器线程将每个图层栅格化，由于一层可能想页面的整个长度一样大，因此合成器线程将他们切分为许多图块（tiles），然后将每个图块发送给栅格化线程（Raster Thread），栅格化线程栅格化每个图块，并将他们存储在GPU内存中，当图块栅格化完成后，合成器线程将收集成为 draw quads 的图块信息，这些信息里记录了图块字啊内存中的位置和在页面的那个位置绘制图块的信息，根据这些信息合成器线程生成一个合成器帧（Compositor Frame）然后合成器Frame（帧）通过IPC传递给浏览器进程，接着浏览器进程将合成器帧传送到GPU，然后GPU渲染展示到屏幕上。\\n\\n当页面发生变化时，比如滚动了当前的页面，都会生成一个新的合成器帧，新的帧再传给GPU，然后再次渲染到屏幕上。\\n\\n#### 浏览器渲染流程简要版\\n\\n1. html解析生成dom树\\n2. 遇到css时，css解析器将计算并生成cssOM\\n3. 将dom树和cssOM树合成渲染树，此时计算元素布局等信息\\n4. 将渲染树生成合成树\\n5. 渲染主线程生成绘制指令列表提交给合成线程\\n6. 合成线程利用栅格化现成生成位图，此时会用GPU进程来进行加速\\n7. 提交给浏览器主进程进行界面展示\\n\\n#### 什么是重排、重绘，怎样避免？\\n\\n**1）重绘重排：**\\n\\n当我们改变了一个元素的尺寸位置属性时，会重新进行样式计算（computed style）布局（layout）绘制（paint）以及后面的所有流程，这种行为成为**重排**。\\n\\n当改变了某个元素的颜色属性时不会重新触发布局，但还是会触发样式计算和绘制这就是**重绘**。\\n\\n我们可以发现重排和重绘都会占用主线程，还有JS也会运行在主线程，所以就会出现抢占执行时间的问题，如果你写了一个不断导致重排重绘的动画，浏览器则需要在每一帧都运行样式计算布局和绘制的操作。\\n\\n**2）优化：**\\n\\n我们知道当前页面以每秒60帧的刷新率时才不会让用户感觉到页面卡顿，如果在运行动画是还有大量的JS任务需要执行，因为布局、绘制和js执行都是在主线程运行的，当在一帧的时间内布局和绘制结束后，还有剩余时间js就会拿到主线程的使用权，如果js执行时间过长，就会导致在下一帧开始时js没有及时归还主线程，导致下一帧动画没有按时渲染，就会出现页面的卡顿。\\n\\n**第一种优化方式：**\\n\\nrequestAnimationFrame，它会在每一帧被调用，通过回调API的回调，**可以把js运行任务分成一些更小的任务块，在每一帧事件用完前暂停js执行归还主线程**，这样的话在下一帧开始时，主线程就可以按时执行布局和绘制。  \\n\\n**第二种优化方式：** \\n\\n栅格化的整个流程不占用主线程，只在合成器线程和栅格线程中运行，这就意味着它无需和js抢占主线程。如果反复进行重绘和重排可能会导致掉帧，这是因为有可能js执行阻塞了主线程，而CSS中有个动画属性transform，**通过该属性实现的动画不会经过布局和绘制，而是直接运行在合成器线程和栅格线程**，所以不会受到主线程中js执行的影响。更重要的是听过transform实现的动画由于不需要经过布局绘制样式计算等操作，所以节省了很多运算事件（方便实现负责的动画）\\n\\n**3）避免重绘重排具体方案：**\\n\\n**CSS**\\n\\n- 使用 transform 替代 top等位移；\\n- 使用 visibility 替换 display: none\\n- 避免使用table布局\\n- 尽可能在DOM树的最末端改变class\\n- 避免设置多层内联样式，尽量层级扁平\\n- 将动画效果应用到position属性为absolute或fixed的元素上\\n- 避免使用CSS表达式\\n- 将频繁重绘或者回流的节点设置为图层，比如video，iframe\\n- CSS3 硬件加速（GPU加速），可以是transform: translateZ(0)、opacity、filters、will-change,Will-change提前告诉浏览器元素会发生什么变化；\\n\\n**JS**\\n\\n- 避免频繁操作样式，合并操作\\n- 避免频繁操作DOM，合并操作；\\n- 防抖节流控制频率；\\n- 避免频繁读取会引发回流/重绘的属性，比如上面的C、O、S属性\\n- 对具有复杂动画的元素使用绝对定位","answer":"","biz_type":1,"qid":114,"subject":"","title":"说说浏览器渲染流程，分层之后在什么时候合成，什么是重排、重绘，怎样避免"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["阿里","滴滴","老虎","完美世界","沪江","喜马拉雅","兑吧","寺库","玄武科技"],"date":"Fri, 19 Jun 2020 16:20:40 GMT","favorite_num":2,"qid":115,"qtype":"short_answer","short_answer":{"analysis":"#### 什么是同源策略\\n\\n同源策略是浏览器的安全策略，用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介\\n\\n同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。\\n\\n当一个浏览器的两个tab页中分别打开 百度和谷歌的页面，当浏览器的百度tab页执行一个脚本的时候会检查这个脚本是属于哪个页面的，即检查是否同源，只有和百度同源的脚本才会被执行。如果非同源，那么在请求数据时，浏览器会在控制台中报一个异常，提示拒绝访问。\\n\\n同源策略是浏览器的行为，是为了保护本地数据不被JavaScript代码获取回来的数据污染，因此拦截的是客户端发出的请求回来的数据接收，即请求发送了，服务器响应了，但是无法被浏览器接收。\\n\\n#### 什么是跨域\\n\\n跨域指的是非同源的资源之间尝试着进行交互通信，而由于受浏览器同源策略的限制，无法正常进行交互通信\\n\\n浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对JavaScript实施的安全限制。无法跨域是浏览器对于用户安全的考虑，同源策略限制了一下行为：Cookie、LocalStorage 和 IndexDB 无法读取DOM 和 JS 对象无法获取，Ajax请求发送不出去\\n\\n#### 哪些方式会造成跨域\\n\\n非同源请求，服务端设置cors限制。\\n\\n#### 解决跨域有什么手段\\n\\n**1）通过jsonp跨域**\\n\\n由于浏览器同源策略是允许 类似script 有src属性的标签这样的跨域资源嵌套的，所以 script 标签的资源不受同源策略的限制。\\n\\n**2）document.domin**\\n\\n两个域名必须属于同一基础域名，并且所有的协议端口完全一致，否则无法跨域；例：beijing.58.com\\ntianjing.58.com ；\\n\\n**3）iframe、hash**\\n\\n父页面向子页面传输数据：将要传递的数据添加到子页面的url的hash值上，子页面通过location.hash并添加定时器实时地动态父页面传来的数据；子页面向父页面传输数据：利window.name的特性，及页面重新加载但当前页的name值不变，即使换了一个页面。需要三个页面配合使用。一个应用页面，一个数据页面，一个代理文件。代理文件一般是一个没有任何内容的html页面，需要和应用页面在同一域下。将数据页面的窗口换成代理页面，代理页面通过window.name获取数据页面留下的数据，应用页面再访问和它同源的代理页面获取数据，就完成了跨域；\\n\\n**4）CORS(Cross-Origin-Resource-Sharing)**\\n\\n在服务器端设置的,不需要客户端进行操作。Cors背后的思想是使用自定义的http头部让浏览器和服务器进行沟通，从而决定请求或响应是否应该成功，还是应该失败。浏览器向服务器发送请求，如果服务器认为这个请求可以接受，就在Access-Control-Allow-Origin头部中回发相同的源信息（如果是公共资源，可以回发*）;如果没有这个头部，或者有这个头部但信息源不匹配，浏览器就会驳回请求。正常情况下，浏览器会处理请求。（请求和响应都不包含cookie信息）；\\n\\n**5）服务器跨域，服务器中转代理**\\n\\n前端向本地服务器发送请求，本地服务器代替前端再向服务器接口发送请求进行服务器间通信，本地服务器是个中转站的角色，再将响应的数据返回给前端。\\n\\n**5）其它一些方式**\\n\\n- postMessage和onmessage\\n- nodejs中间件代理跨域\\n- WebSocket协议跨域\\n- link、script、img、background:url()、@font-face()等均不受跨域限制\\n","answer":"","biz_type":1,"qid":115,"subject":"","title":"什么是同源策略？什么是跨域？都有哪些方式会造成跨域？解决跨域都有什么手段？"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["边锋","老虎","脉脉","掌门一对一","喜马拉雅","寺库","腾讯应用宝","快手"],"date":"Fri, 19 Jun 2020 16:20:40 GMT","favorite_num":2,"qid":101,"qtype":"short_answer","short_answer":{"analysis":"#### 一、Https和 http 的区别\\n\\n1. https协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。\\n2. http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl/tls加密传输协议。\\n3. http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。\\n4. http的连接很简单，是无状态的；HTTPS协议是由SSL/TLS+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。\\n\\n#### 二、https 为什么比 http 安全？\\n\\n1）在交换密钥环节使用非对称加密方式，防止秘钥被非法获取；建立通信后，交换报文阶段则使用对称加密方式，防止报文被窃听\\n\\n2）通过数字签名解决了报文可能被篡改问题\\n\\n数字签名有两种功效：\\n\\n- 能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。\\n- 数字签名能确定消息的完整性,证明数据是否未被篡改过。\\n\\n3）通过数字证书解决了通信方身份可能被伪装的问题\\n\\n#### 三、如何进行配置？\\n\\n> tomcat部署\\n\\n**1）申请证书**\\n\\n证书由第三方 CA 认证机构颁发，网站所有者向 CA 机构申请证书，证书中包含了公钥、颁证机构、网址、失效日期。如果网站使用假冒证书，浏览器向 CA 认证机构发送证书是否合法的请求，如果检测非法证书，浏览器可以直接断开请求。\\n\\n**2）证书部署到 Tomcat**\\n\\n配置SSL连接器，将www.domain.com.jks文件存放到conf目录下，然后配置同目录下的server.xml文件：\\n\\n```xml\\n <Connector \\n    port=\\"443\\" \\n    protocol=\\"HTTP/1.1\\" \\n    SSLEnabled=\\"true\\"\\n    maxThreads=\\"150\\" \\n    scheme=\\"https\\" \\n    secure=\\"true\\"\\n    keystoreFile=\\"conf/www.domain.com.jks\\"\\n    keystorePass=\\"changeit\\"\\n    clientAuth=\\"false\\" \\n    sslProtocol=\\"TLS\\" />\\n```\\n\\nhttp自动跳转https的安全配置到conf目录下的web.xml。在</welcome-file-list>后面，</web-app>，也就是倒数第二段里，加上这样一段\\n\\n```xml\\n <login-config>\\n   \x3c!-- Authorization setting for SSL --\x3e\\n   <auth-method>CLIENT-CERT</auth-method>\\n   <realm-name>Client Cert Users-only Area</realm-name>\\n </login-config>\\n <security-constraint>\\n   \x3c!-- Authorization setting for SSL --\x3e\\n   <web-resource-collection>\\n       <web-resource-name>SSL</web-resource-name>\\n       <url-pattern>/*</url-pattern>\\n   </web-resource-collection>\\n   <user-data-constraint>\\n        <transport-guarantee>CONFIDENTIAL</transport-guarantee>\\n   </user-data-constraint>\\n </security-constraint>\\n```\\n\\n这步目的是让非ssl的connector跳转到ssl的connector去。所以还需要前往server.xml进行配置：\\n\\n```xml\\n<Connector \\n    port=\\"8080\\" \\n    protocol=\\"HTTP/1.1\\"\\n    connectionTimeout=\\"20000\\"\\n    redirectPort=\\"443\\" />\\n```\\n\\n重启 Tomcat，输入 HTTPS 网址,测试能否访问成功。\\n\\n------\\n\\n> Nginx配置HTTPS\\n\\n**1）申请证书**\\n\\n**2）确保具有ssl模块，如果没有进行安装**\\n\\n①安装基础支持包\\n\\n`yum -y install openssl openssl-devel`\\n\\n②备份原nginx.conf文件为nginx.conf.bak以防万一\\n\\n③安装ssl模块\\n\\n```bash\\ncd /home/nginx-1.10.2    \\n../configure --with-http_ssl_module\\nmake\\nmake install\\n```\\n\\n**3）配置服务器**\\n\\n配置Nginx.conf，将下载的证书和Key的所在位置配置到配置文件上。具体配置如下：\\n\\n```bash\\nserver {    \\n    listen 443;#监听443端口（https默认端口）\\n    server_name www.xxx.com; #填写绑定证书的域名\\n    ssl on;\\n    ssl_certificate xxx.crt;#填写你的证书所在的位置\\n    ssl_certificate_key xxx.key;#填写你的key所在的位置\\n    ssl_session_timeout 5m;\\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置\\n    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置\\n    ssl_prefer_server_ciphers on;\\n    location / {\\n            root  xxx ; #填写你的你的站点目录\\n            index index.php index.html index.htm;\\n    }\\n}\\n```\\n\\n**4）进行http80端口的访问重定向配置**\\n\\n```bash\\nserver {\\n    listen       80;\\n    server_name  www.xxx.com;#填写绑定证书的域名\\n    rewrite ^ https://$http_host$request_uri? permanent;    # 将http转到https\\n}\\n```\\n\\n**5）重启服务器**\\n\\n下面我们进行服务器的重启，在重启之前先检验配置文件是否有错误\\n\\n```bash\\nnginx -t #如果没有错误进行服务器重启\\nservice nginx restart\\n```\\n\\n\\n\\n\\n","answer":"","biz_type":1,"qid":101,"subject":"","title":"介绍下 Https，和 http 的区别是什么？https 为什么比 http 安全？如何进行配置？"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["边锋"],"date":"Fri, 19 Jun 2020 16:20:40 GMT","favorite_num":2,"qid":98,"qtype":"short_answer","short_answer":{"analysis":"#### UTF-8\\n\\n1. UTF-8 是一种 Unicode 的一种实现方式，还包括 UTF-16 和 UTF-32。\\n2. 可变长度编码，使用 1~4 个字节表示一个符号，根据不同的符号变化字节长度。\\n3. 对于单字节，字节第一位设为0，后面7位这个符号的 Unicode 码。\\n4. 对于 n 字节，第一字节的前 n 位都设为1， 第 n+1 位设为 0 ，后面字节的前两位一律设为 10，剩下的没有提及的二进制位全部为这个符号的 Unicode 码。\\n5. UTF-8 兼容 ASCII 。\\n\\n#### ASC码\\n\\n1. 仅用于英语，是美国信息交换标准代码。\\n2. 使用 7位 二进制数组合来表示 127 个字符（0 是为 null，不算字符 ），包含 大小写字母，数字 0-9，标点符号。\\n3. ASCII 使用 1个字节或者 8位二进制数，表示 255 个字符。\\n4. ACSII 第 8位 来奇偶校验，前 7位 和 ACS 一样。\\n5. ASCII 是非标准，具有许多本地化的版本，并且是 Unicode 的子集。\\n","answer":"","biz_type":1,"qid":98,"subject":"","title":"utf-8 和 asc 码有什么区别"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["边锋"],"date":"Fri, 19 Jun 2020 16:20:40 GMT","favorite_num":2,"qid":97,"qtype":"short_answer","short_answer":{"analysis":"#### encoding 头部编码方式\\n\\n1. **ASCII：** 美国 19世纪60年代 建立英文和二进制的关系时定制的编码规范，仅用于英文。\\n2. **Unicode：** 通用字符集，包含了所有的字符。\\n3. **UTF-8：** 是互联网上使用最广的一种 Unicode 的实现方式。\\n4. **GBK/GB2312/GB18030：** GBK和GB2312是针对简体字的编码。GB2312只支持六千多个汉字的编码，而GBK支持1万多个汉字编码。GB18030是用于繁体字的编码。汉字存储时都使用两个字节来储存。","answer":"","biz_type":1,"qid":97,"subject":"","title":"encoding 头都有哪些编码方式"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["边锋"],"date":"Fri, 19 Jun 2020 16:20:40 GMT","favorite_num":2,"qid":104,"qtype":"short_answer","short_answer":{"analysis":"#### 1.对称加密 \\n\\n对称加密采⽤了对称密码编码技术，它的特点是⽂件加密和解密使⽤相同的密钥加密，也就是密钥也可以⽤作解密密钥，这种⽅法在密码学中叫做对称加密算法，对称加密算法使⽤起来简单快捷，密钥较短，且破译困难，除了数据加密标准（DES），另⼀个对称密钥加密系统是国际数据加密算法（IDEA），它⽐ DES的加密性好，⽽且对计算机功能要求也没有那么⾼。 \\n\\n**简要概括**\\n\\n对称加密：收发双方规定密钥，比如字母偏移5位加密；\\n\\n- 加密的人也能解密，这就是对称；\\n- 问题：密钥需要传递，传递的过程中，可能被窃听和篡改\\n\\n\\n#### 2.⾮对称加密\\n\\n与对称加密算法不同，⾮对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥 （privatekey）。 公开密钥与私有密钥是⼀对，如果⽤公开密钥对数据进⾏加密，只有⽤对应的私有密钥才能解密；如果⽤私有密钥对数据进⾏加密，那么只有⽤对应的公开密钥才能解密。因为加密和解密使⽤的是两个不同的密钥，所以这种算法叫作⾮对称加密算法。 \\n\\n⾮对称加密算法实现机密信息交换的基本过程是：甲⽅⽣成⼀对密钥并将其中的⼀把作为公⽤密钥向其它⽅公开；得到该公⽤密钥的⼄⽅使⽤该密钥对机密信息进⾏加密后再发送给甲⽅；甲⽅再⽤⾃⼰保存的另⼀把专⽤密钥对加密后的信息进⾏解密。甲⽅只能⽤其专⽤密钥解密由其公⽤密钥加密后的任何信息。\\n\\n⾮对称加密的典型应⽤是数字签名。 常⻅的⾮对称加密算法有：RSA、ECC（移动设备⽤）、Diffie-Hellman、El Gamal、DSA（数字签名 ⽤）\\n\\n**简要概括**\\n\\n- 发送人留着钥匙，把带锁的盒子传过去，加密的人锁上，但是解不开，就是非对称；\\n- 问题：可能被窃听更换掉盒子\\n- 认证机构来给盒子做签名，也就是我们HTTPS需要的网站证书；\\n\\n#### 3.区别\\n\\n- 对称加密只需要⼀把密钥，⾮对称加密需要⼀对密钥（公钥和私钥） \\n- 对称加密 算法简单，加密解密容易，效率⾼，执⾏快；只有⼀把钥匙，密⽂如果被拦截，且密钥也被劫持，那么，信息很容易被破译，安全性能低； ⾮对称加密算法及其复杂，安全性依赖算法与密钥，⽽且加密和解密效率很低；即使密⽂被拦截、公钥被获取，但是⽆法获取到私钥，也就⽆法破译密⽂，安全性能⾼\\n\\n#### 4.总结\\n\\n- 非对称可靠但慢，对称的高效性但不可靠；\\n- 配合使用，非对称加密进行身份验证和密钥交换，对称加密进行数据的加密；","answer":"","biz_type":1,"qid":104,"subject":"","title":"对称加密和非对称加密的区别和用处"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["头条","滴滴","网易"],"date":"Fri, 19 Jun 2020 16:20:40 GMT","favorite_num":3,"qid":59,"qtype":"short_answer","short_answer":{"analysis":"### 答案\\n\\n#### 什么是CDN\\n\\nCDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。(百度百科)\\n\\n简单地说，CDN是一个经策略性部署的整体系统，包括分布式存储、负载均衡、网络请求的重定向和内容管理4个要件，而内容管理和全局的网络流量管理(Traffic Management)是CDN的核心所在。\\n\\n通过用户就近性和服务器负载的判断，CDN确保内容以一种极为高效的方式为用户的请求提供服务。\\n\\n**举例说明：**\\n\\n国内访问量较高的网站、直播、视频平台，均使用CDN网络加速技术，虽然网站的访问巨大，但无论在什么地方访问都会感觉速度很快。而一般的网站如果服务器在网通，电信用户访问很慢，如果服务器在电信，网通用户访问又很慢。\\n\\n通过在现有的Internet中增加一层新的网络架构，将网站的内容发布到最接近用户的cache服务器内，通过DNS负载均衡的技术，判断用户来源就近访问cache服务器取得所需的内容，解决Internet网络拥塞状况，提高用户访问网站的响应速度，如同提供了多个分布在各地的加速器，以达到快速、可冗余的为多个网站加速的目的。\\n\\n#### CDN原理\\n\\n在描述CDN的实现原理之前，让我们先看传统的未加缓存服务的访问过程，以便了解CDN缓存访问方式与未加缓存访问方式的差别：\\n\\n用户提交域名→浏览器对域名进行解释→得到目的主机的IP地址→根据IP地址访问发出请求→得到请求数据并回复\\n\\n由上可见，用户访问未使用CDN缓存网站的过程为:\\n\\n- 1)、用户向浏览器提供要访问的域名；\\n- 2)、浏览器调用域名解析函数库对域名进行解析，以得到此域名对应的IP地址；\\n- 3)、浏览器使用所得到的IP地址，向域名的服务主机发出数据访问请求；\\n- 4)、浏览器根据域名主机返回的数据显示网页的内容。\\n\\n  通过以上四个步骤，浏览器完成从用户处接收用户要访问的域名到从域名服务主机处获取数据的整个过程。\\n\\n***CDN网络是在 用户和服务器之间增加Cache层***，如何将用户的请求引导到Cache上获得源服务器的数据，主要是通过接管DNS实现，下面让我们看看访问使用CDN缓 存后的网站的过程：\\n\\n![](http://img-static.yidengxuetang.com/wxapp/issue-img/cdn.png)\\n\\n**看个通俗的例子**\\n\\n1.  客户端向服务器请求一个静态资源，如请求cdn服务器的jquery文件，（http://code.jquery.com/jquery-migrate-1.2.1.min.js）\\n首先会进行dns域名解析，但这里解析出来不是直接返回源站ip，而是解析到一个智能dns服务器。\\n2. 这个智能dns服务器会将离用户最近的cdn服务器的ip返回给客户端。\\n3. 客户端向cdn服务器获取jquery文件，如果改服务器有这个静态资源并且未过期，这个jquery文件将直接返回给客户端\\n4. 如果cdn服务器有该静态资源，但已过期，会向源站询问是否更改，未变更则直接返回该文件并延长有效期，如果源站文件变更，重新从源站获取并缓存到自己的cnd服务器。\\n5. 源站也可以主动更新cdn网络下的静态资源以确保客户端最快的获取到最新的资源。\\n\\n![](http://img-static.yidengxuetang.com/wxapp/issue-img/cdn2.png)\\n\\n#### 为什么用\\n\\n1. 解决因分布、带宽、服务器性能带来的访问延迟问题。使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度和成功率。\\n2. 控制时延无疑是现代信息科技的重要指标，CDN的意图就是尽可能的减少资源在转发、传输、链路抖动等情况下顺利保障信息的连贯性。\\n3. 可以保护网站安全,CDN的负载均衡和分布式存储技术，可以加强网站的可靠性，相当无无形中给你的网站添加了一把保护伞，应对绝大部分的互联网攻击事件。防攻击系统也能避免网站遭到恶意攻击。\\n\\n#### 哪些情况推荐使用CDN\\n\\n一般来说以资讯、内容等为主的网站，具有一定访问体量的网站资讯网站、政府机构网站、行业平台网站、商城等以动态内容为主的网站论坛、博客、交友、SNS、网络游戏、搜索/查询、金融等。提供http下载的网站软件开发商、内容服务提供商、网络游戏运行商、源码下载等有大量流媒体点播应用的网站拥有视频点播平台的电信运营商、内容服务提供商、体育频道、宽频频道、在线教育、视频博客等\\n\\n#### 哪些情况不适用于CDN\\n\\n1. 适度的用户群：针对性、特定性服务少数用户\\n2. 极端本地化用户群：给定地理区域本地化\\n3. 监管和复杂的治理要求：用户数据敏感、数据管辖范围限制\\n","answer":"","biz_type":1,"qid":59,"subject":"","title":"CDN 是什么？描述下 CDN 原理？为什么要用 CDN?"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["头条","喜马拉雅"],"date":"Fri, 19 Jun 2020 16:20:40 GMT","favorite_num":2,"qid":60,"qtype":"short_answer","short_answer":{"analysis":"### 答案\\n\\n#### PWA介绍\\n\\nPWA（Progressive web apps，渐进式 Web 应用）运用现代的 Web API 以及传统的渐进式增强策略来创建跨平台 Web 应用程序。\\n\\n**什么是PWA应用**？\\n\\nPWA应用是指那些使用指定技术和标准模式来开发的web应用，这将同时赋予它们web应用和原生应用的特性。\\n\\n举例：PWA既能像网站那么快捷，又能像QQ、微信一样离线在本地运行\\n\\n**什么使应用成为PWA**\\n\\n总体依据：当应用程序满足某些要求时，可以将其视为PWA，或者实现一组给定的功能：离线工作，可安装，易于同步，可以发送推送通知等。\\n\\n辨别工具：还有一些工具可以按百分比衡量应用的完整性。(Lighthouse目前是最受欢迎的工具）通过实施各种技术优势，我们可以使应用程序更加渐进式，从而最终获得更高的Lighthouse 得分。但这只是一个粗略的指标。\\n\\n辨别原则：这里有一些关键的原则来辨别一个web应用是否是一个PWA应用。它应该具有以下特点:\\n\\n- Discoverable, 内容可以通过搜索引擎发现。\\n- Installable, 可以出现在设备的主屏幕。\\n- Linkable, 你可以简单地通过一个URL来分享它。 \\n- Network independent, 它可以在离线状态或者是在网速很差的情况下运行。\\n- Progressive, 它在老版本的浏览器仍旧可以使用，在新版本的浏览器上可以使用全部功能。\\n- Re-engageable, 无论何时有新的内容它都可以发送通知。\\n- Responsive, 它在任何具有屏幕和浏览器的设备上可以正常使用——包括手机，平板电脑，笔记本，电视，冰箱，等。\\n- Safe, 在你和应用之间的连接是安全的，可以阻止第三方访问你的敏感数据。\\n\\n**PWA优势**\\n\\n我们需要在设计网站时时刻记住PWA的优势。app shell允许网站：\\n\\n- 可访问：即使看起来像个本地应用，请记住它仍然是个网站——你可以点击页面中的连接并分享给你的朋友。\\n- 渐进式：先从“好用的，旧式的网站”出发，一步步渐进式的增加新特性，记住要随时侦测浏览器是否可用这些新增加的特性，同时注意处理任何由于浏览器不支持而导致的error。例如，service workers可以让离线工作成为可能，同时提高网站的体验，但是记住就算没有service worker网站也应该能运行良好。\\n- 响应式：响应式页面设计也适用于渐进式web应用，主要是针对移动端设备。有许多不同的设备配置有浏览器——你需要让网站支持不同的屏幕尺寸，视窗（viewport）或者是不同的像素密度（pixel density），常用的技术有viewport meta tag，CSS media queries，Flexbox。\\n\\n**PWA存在的问题**\\n\\n- 支持率不高:现在ios手机端不支持pwa，IE也暂时不支持\\n- Chrome在中国桌面版占有率还是不错的，安卓移动端上的占有率却很低\\n- 各大厂商还未明确支持pwa\\n- 依赖的GCM服务在国内无法使用\\n- 微信小程序的竞争\\n\\n\\n#### PWA关键技术\\n\\n- **Manifest**\\n- **service worker**\\n\\n**1）Manifest实现添加至主屏幕**\\n\\n- index.html\\n\\n```html\\n<head>\\n  <title>Minimal PWA</title>\\n  <meta name=\\"viewport\\" content=\\"width=device-width, user-scalable=no\\" />\\n  <link rel=\\"manifest\\" href=\\"manifest.json\\" />\\n  <link rel=\\"stylesheet\\" type=\\"text/css\\" href=\\"main.css\\">\\n  <link rel=\\"icon\\" href=\\"/e.png\\" type=\\"image/png\\" />\\n</head>\\n```\\n\\n- manifest.json\\n\\n```json\\n{\\n  \\"name\\": \\"Minimal PWA\\", // 必填 显示的插件名称\\n  \\"short_name\\": \\"PWA Demo\\", // 可选  在APP launcher和新的tab页显示，如果没有设置，则使用name\\n  \\"description\\": \\"The app that helps you understand PWA\\", //用于描述应用\\n  \\"display\\": \\"standalone\\", // 定义开发人员对Web应用程序的首选显示模式。standalone模式会有单独的\\n  \\"start_url\\": \\"/\\", // 应用启动时的url\\n  \\"theme_color\\": \\"#313131\\", // 桌面图标的背景色\\n  \\"background_color\\": \\"#313131\\", // 为web应用程序预定义的背景颜色。在启动web应用程序和加载应用程序的内容之间创建了一个平滑的过渡。\\n  \\"icons\\": [ // 桌面图标，是一个数组\\n    {\\n    \\"src\\": \\"icon/lowres.webp\\",\\n    \\"sizes\\": \\"48x48\\",  // 以空格分隔的图片尺寸\\n    \\"type\\": \\"image/webp\\"  // 帮助userAgent快速排除不支持的类型\\n  },\\n  {\\n    \\"src\\": \\"icon/lowres\\",\\n    \\"sizes\\": \\"48x48\\"\\n  },\\n  {\\n    \\"src\\": \\"icon/hd_hi.ico\\",\\n    \\"sizes\\": \\"72x72 96x96 128x128 256x256\\"\\n  },\\n  {\\n    \\"src\\": \\"icon/hd_hi.svg\\",\\n    \\"sizes\\": \\"72x72\\"\\n  }\\n  ]\\n}\\n```\\n\\n**2）service worker实现离线缓存**\\n\\nService Worker 是 Chrome 团队提出和力推的一个 WEB API，用于给 web 应用提供高级的可持续的后台处理能力。\\n\\nService Workers 就像介于服务器和网页之间的拦截器，能够拦截进出的HTTP 请求，从而完全控制你的网站。\\n\\n**最主要的特点**\\n\\n- 在页面中注册并安装成功后，运行于浏览器后台，不受页面刷新的影响，可以监听和截拦作用域范围内所有页面的 HTTP 请求。\\n- 网站必须使用 HTTPS。除了使用本地开发环境调试时(如域名使用 localhost)\\n- 运行于浏览器后台，可以控制打开的作用域范围下所有的页面请求\\n- 单独的作用域范围，单独的运行环境和执行线程\\n- 不能操作页面 DOM。但可以通过事件机制来处理\\n- 事件驱动型服务线程\\n","answer":"","biz_type":1,"qid":60,"subject":"","title":"PWA 是什么？对 PWA 有什么了解"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":[],"date":"Fri, 19 Jun 2020 16:20:40 GMT","favorite_num":2,"qid":43,"qtype":"short_answer","short_answer":{"analysis":"### 答案\\n\\n#### 1.v8引擎出现的原因\\n\\n先了解什么是编译型语言和解释性语言：\\n\\n**编译型语言**： \\n\\n在程序执行之前必须进行专门的编译过程，有如下特点：\\n\\n- 只须编译一次就可以把源代码编译成机器语言，后面的执行无须重新编译，直接使用之前的编译结果就可以；因此其执行的效率比较高；\\n- 编译性语言代表：C、C++、Java、Pascal/Object Pascal（Delphi）；\\n- 程序执行效率比较高，但比较依赖编译器，因此跨平台性差一些；\\n- 不同平台对编译器影响较大。\\n  - 16位系统下int是2个字节（16位），而32位系统下int占4个字节（32位）；\\n  - 32位系统下long类型占4字节，而64位系统下long类型占8个字节；\\n\\n**解释性语言** \\n\\n解释行语言，支持动态类型，弱类型，在程序运行的时候才进行编译，而编译前需要确定变量的类型，效率比较低，对不同系统平台有较大的兼容性.\\n\\n- 源代码不能直接翻译成机器语言，而是先翻译成中间代码，再由解释器对中间代码进行解释运行；\\n  - 源代码—>中间代码—>机器语言\\n- 程序不需要编译，程序在运行时才翻译成机器语言，每执行一次都要翻译一次；\\n- 解释性语言代表：Python、JavaScript、Shell、Ruby、MATLAB等；\\n- 运行效率一般相对比较低，依赖解释器，跨平台性好；\\n\\n**比较**\\n\\n- 一般，编译性语言的运行效率比解释性语言更高；但是不能一概而论，部分解释性语言的解释器通过在运行时动态优化代码，甚至能使解释性语言的性能超过编译性语言；\\n\\n- 编译性语言的跨平台特性比解释性语言差一些；\\n\\n**结论**\\n\\n以上说明，解释性语言，运行效率低，随着Web相关技术的发展，JavaScript所要承担的工作也越来越多，早就超越了“表单验证”的范畴，这就更需要快速的解析和执行JavaScript脚本。\\n\\nV8引擎就是为解决这一问题而生，在node中也是采用该引擎来解析JavaScript。\\n\\n#### 2.V8引擎\\n\\nV8引擎是一个JavaScript引擎实现，最初由一些语言方面专家设计，后被谷歌收购，随后谷歌对其进行了开源。\\n\\nV8引擎使用 C++ 开发，在运行 JavaScript 之前，相比其它的 JavaScript 的引擎转换成字节码或解释执行，V8将其编译成原生机器码（IA-32，x86-64，ARM，or MIPS CPUs），并且使用了如内联缓存（ inline caching ）等方法来提高性能。\\n\\n有了这些功能， JavaScript 程序在 V8 引擎下的运行速度媲美二进制程序。\\n\\nV8支持众多操作系统，如 windows、linux、android 等，也支持其他硬件架构，如 IA32，X64，ARM 等，具有很好的可移植和跨平台特性。\\n\\n#### 3.垃圾回收机制\\n\\nV8的垃圾回收策略主要基于分代式的垃圾回收机制\\n\\n**1）V8主要将内存分为新生代和老生代**\\n\\n新生代中的对象为存活时间较短的对象、老生代中的对象为存活时间较长或常驻内存的对象\\n\\n**新生代**\\n\\n①Scavenge算法\\n\\n在分代的基础上，新生代对象，主要通过Scavenge算法进行垃圾回收，在算法实现中，主要采用Cheney算法。\\n\\n②Cheney算法\\n\\nCheney算法是采用一种复制的方式实现垃圾回收算法。它将内存一分为二，每一部分空间称为semispace。在两个每一部分空间称为semispace中，只用一个处于使用状态，另一个处于闲置状态。处于使用状态的semispace称为From空间，处于闲置状态的semispace称为To空间。\\n\\n③内存分配过程\\n\\n- 当我们分配对象时，先是在From空间中分配。\\n- 当开始进行垃圾回收时，会检查From空间中存活对象，这些存活的对象将被复制到To空间中，而非存活对象占用的空间将会被释放。\\n- 复制完成后，From空间和To空间的角色发生对换，简而言之，在垃圾回收的过程中，就是通过将存活的对象在两个semispace空间之间进行复制。\\n\\n④Scavenge的优缺点\\n\\nScavenge的缺点是只能使用堆内存中的一半，这是由划分空间和复制机制所决定的。但 Scavenge由于只复制存活的对象，并且对于生命同期短的场景存活对象只占少部分，所以它在时 间效率上有优异的表现。由于Scavenge是典型的牺牲空间换取时间的算法，所以无法大规模地应用到所有的垃圾回收 中。但可以发现，Scavenged常适合应用在新生代中，因为新生代中对象的生命周期较短，恰恰适合这个算法。\\n\\n⑤晋升\\n\\n实际使用的堆内存是新生往中的两个semispac建向大小和老生代所用内存大小之和。\\n\\n当一个对象经过多次复制依然存活时，它将会被认为是生命周期较长的对象。这种较长生命周期的对象随后会被移动到老生代中，采用新的算法进行管理。对象从新生代中移动到老生代中 的过程称为晋升。\\n\\n**老生代**\\n\\n①和新生代的对比\\n\\n对于老生代中的对象，由于存活对象占较大比重，再采用Scavenge的方式会有两个问题：\\n\\n- 一个是存活对象较多，复制存活对象的效率将会很低；\\n- 另一个问题依然是浪费一半空间的冋题。\\n\\n**2）V8在老生代中主要采用了Mark-Sweep和Mark-Compact调结合的方式进行垃圾回收。**\\n\\n**Mark-Sweep**\\n\\n- Maik-Sweep是标记清除的意思，它分为标记和清除两个阶段。与Scavenge相比，Mark-Sweep并不将内存空间划分为两半，所以不存在浪费一半空间的行为。与Scwenge复制活着的对象不同，Mark-Sweep在标记阶段遍历堆中的所有对象，并标记活着的对象，在随后的清除阶段中，只清除没有被标记的对象。Scavenge中只复制活着的对象，而Mark-Sweep只清理死亡对象。\\n- 活对象在新生代中只占较小部分，死对象在老生代中只占较小部分，这是两种回收方式能高效处理的原因\\n- Mark-Sweep最大的问题是在进行一次标记清除回收后，内存空间会出现不连续的状态。这种内存碎片会对后续的内存分配造成问题，因为很可能出现需要分配一个大对象的情况，这时所有的碎片空间都无法完成此次分配，就会提前触发垃圾回收，而这次回收是不必要的。\\n\\n**Mark-Compact**\\n\\n为了解决Mark-Sweep冲的内存碎片问题，Mark-Compact被提出来。Mark-Contact是标记整理 的意思，是在Mark-Sweep的基础上演变而来的。它们的差别在于对象在标记为死亡后，在整理理的过程中,将活着的对象往一端移动，移动完成后,直接清理掉边界外的内存。\\n\\n**3）两者结合**\\n\\n在V8的回收策略中，Mark-Sweep和Mark-Conpact两者是结合使用的。\\n\\n由于Mark-Conpact需要移动对象，所以它的执行速度不可能很快，在取舍上，V8主要使用Mark-Sweep，在空间不足以对从新生代中晋升过来的对象进行分配时，才使用Mark-Compact。\\n\\n","answer":"","biz_type":1,"qid":43,"subject":"","title":"V8 机制讲解"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["伴鱼"],"date":"Fri, 19 Jun 2020 16:20:40 GMT","favorite_num":2,"qid":84,"qtype":"short_answer","short_answer":{"analysis":"### 一、详细过程分析\\n\\n#### 1）构建 DOM 树\\n\\n将HTML 转换为浏览器能够理解的结构——DOM 树\\n\\n**①HTML词法、语法的解析**\\n\\n- 词法分析：把字符流初步解析成我们可理解的\\"词\\"，学名叫token。\\n- 语法分析：把开始结束标签配对、属性赋值好、父子关系连接好、构成dom树。\\n\\n**②请求js，css**\\n\\n#### 2）样式计算（Recalculate Style）\\n\\n- 把 CSS 转换为浏览器能够理解的结构—styleSheets；\\n- 转换样式表中的属性值，使其标准化；\\n- 计算出 DOM 树中每个节点的具体样式\\n  - CSS 继承，包含父节点的样式；\\n  - 样式层叠的规则：!important 无限高 > 内联 1000> id 100> class 10> tag > 继承 >浏览器默认\\n\\n#### 3）布局阶段\\n\\n- 创建布局树Layout tree，构建一棵只包含可见元素布局树; head标签，不可见元素都不包含；\\n- 布局计算\\n\\n#### 4）分层\\n\\n页面中有复杂效果，如 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。\\n\\n图层树和布局树的关系，每一个节点自己没有单独的图层，就属于父节点的图层，反正所有的节点都会直接或者间接地从属于一个层，\\n\\n**哪些节点会创建新的图层**\\n\\n- 拥有层叠上下文属性的元素会被提升为单独的一层。比如：明确定位属性position：fixed、定义透明属性opacity、使用 CSS 滤镜filter的元素、z-index\\n- 需要剪裁（clip）的地方也会被创建为图层。比如div内容的文字超出div范围，会被裁剪，渲染引擎单独为文字部分单独创建一个层；如果出现滚动条，滚动条也会被提升为单独的层；\\n\\n#### 5）图层绘制\\n\\n图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表；\\n\\n可以在开发者工具的Layers点击document的profiler查看到绘制列表；\\n\\n#### 6）合成线程进行分块\\n\\n- 主线程会把该绘制列表提交（commit）给合成线程，进行真正的绘制；\\n- 合成线程会将图层划分为图块（tile），这些图块的大小通常是 256x256 或者 512x512\\n\\n\\n#### 7）栅格化\\n\\n- 栅格化，是指将图块转换为位图。图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的；\\n- 按照视口附近的图块来优先生成位图;\\n- 栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中；\\n\\n#### 8）合成和显示\\n\\n- 一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。\\n- 浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。\\n\\n\\n### 二、通俗理解\\n\\n1. 解析html：通过字节流把内容传到html解析引擎，解析引擎首先会调用解析器处理标签，处理没闭合或者使用不规范的标签，处理完毕后交给分词器处理。分词器将标签转换为token，并交给dom构建器处理。在解析过程中遇到script会暂停解析，直到script加载完成并执行完，html才会继续解析。\\n2. 构建dom树。将 token 解析为 dom节点，并将 dom 节点添加到 dom树中。通过压栈出栈方式构建dom树。这个过程就是逐行解析代码，包括html标签和js动态生成的标签，最终生成dom树。\\n3. css树。在解析的过程中，遇到css资源需要加载时，html解析不会暂停。当css资源下载好，会调用css解析引擎去解析CSS代码，计算出最终的样式数据。对CSS代码中非法的语法她会直接忽略掉。解析CSS的时候会按照如下顺序来定义优先级：浏览器默认设置，用户设置，外链样式，内联样式，html中的style。在解析css的同时，渲染树构建被暂停，直到css树解析完成。\\n4. 渲染树。把之前构建好的css树以及dom树按照一定的规则以及依赖关系生成渲染树，写到内存，等待进一步生成界面。渲染树和dom树是有区别的。dom树完全和html标签一一对应，但是渲染树会忽略掉不需要渲染的元素，比如head、display:none的元素等。\\n5. 布局。从渲染树的根节点开始遍历，然后确定每个节点对象在页面上的确切大小与位置，布局阶段的输出是一个盒子模型，它会精确地捕获每个元素在屏幕内的确切位置与大小。同时把每个节点做成一个纹理，放在gpu寄存器中管理\\n6. 绘制。遍历渲染树，调用渲染器的paint()方法在屏幕上显示。\\n\\n","answer":"","biz_type":1,"qid":84,"subject":"","title":"说一下浏览器解析 Html 文件的过程"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["头条","边锋"],"date":"Fri, 19 Jun 2020 16:20:40 GMT","favorite_num":2,"qid":99,"qtype":"short_answer","short_answer":{"analysis":"### 一、tcp 和 udp 区别\\n\\n1. TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接\\n2. TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保   证可靠交付\\n3. TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）\\n4. 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信\\n5. TCP首部开销20字节;UDP的首部开销小，只有8个字节\\n6. TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道\\n\\n### 二、tcp 怎样确保数据正确性\\n\\n1. 校验和: 发送的数据包的二进制相加然后取反，检测数据在传输过程中的任何变化, 如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。 \\n2. 确认应答 + 序列号:  TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 \\n3. 超时重传: 当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 \\n4. 流量控制: TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。\\n5. 拥塞控制: 当网络拥塞时，减少数据的发送。发送方有拥塞窗口，发送数据前比对接收方发过来的计时窗口, 取小(慢启动、拥塞避免、拥塞发送、快速恢复);\\n\\n### 三、TCP头包含什么\\n\\n1. 16位端口号: 告知主机该报文段是来自哪里, 传给哪个上层协议/应用;\\n2. 32位序列号: 一次TCP通信过程中某一个传输方向上的字节流的每个字节的编号;\\n3. 32位确认号: 用作对另一方发送来的TCP报文段的响应, 其值是收到的TCP报文段的序号值加1;\\n4. 4位头部长度: 标识该TCP头部有多少个32bit字;\\n5. 6位标志位;\\n6. 16位窗口大小: 流量控制;\\n7. 16位校验和: TCP可靠传输的一个重要保障;\\n8. 16位紧急指针: 它和序号字段的值相加表示最后一个紧急数据的下一字节的序号, 是发送端向接收端发送紧急数据的方法;\\n9. TCP头部选项: 可变长的可选信息, 第一个字段kind说明选项的类型, 第二个字段length指定该选项的总长度, 第三个字段info是选项的具体信息;\\n\\n### 四、Tcp 属于哪一层？\\n\\n传输层\\n\\n","answer":"","biz_type":1,"qid":99,"subject":"","title":"tcp 和 udp 有什么区别？tcp 怎样确保数据正确性？tcp 头包含什么？tcp 属于那一层？"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["头条","边锋","菜鸟网络","爱范儿","心娱"],"date":"Fri, 19 Jun 2020 16:20:40 GMT","favorite_num":2,"qid":93,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":93,"subject":"","title":"从输入 URL 到页面加载全过程"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["边锋","寺库"],"date":"Fri, 19 Jun 2020 16:20:40 GMT","favorite_num":2,"qid":95,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":95,"subject":"","title":"DNS 解析的具体过程"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["阿里","边锋","喜马拉雅","玄武科技"],"date":"Fri, 19 Jun 2020 16:20:40 GMT","favorite_num":2,"qid":96,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":96,"subject":"","title":"常见的 http 请求头都有哪些，以及它们的作用"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["边锋"],"date":"Fri, 19 Jun 2020 16:20:40 GMT","favorite_num":2,"qid":100,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":100,"subject":"","title":"传输层和网络层分别负责什么，端口在什么层标记"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["边锋","老虎"],"date":"Fri, 19 Jun 2020 16:20:40 GMT","favorite_num":2,"qid":102,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":102,"subject":"","title":"说一下加密握手的过程"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["酷狗"],"date":"Fri, 19 Jun 2020 16:20:40 GMT","favorite_num":2,"qid":116,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":116,"subject":"","title":"什么是 CORS，CORS 需要前端配置还是后端配置？"},"tech_tag":["网络&安全"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["老虎"],"date":"Fri, 19 Jun 2020 16:20:40 GMT","favorite_num":2,"qid":113,"qtype":"short_answer","short_answer":{"analysis":"\\n#### 浏览器组成\\n\\n1. 早期浏览器是单进程架构，由于单进程会导致卡死，容易奔溃等原因。现代浏览器就有了多进程架构，将来会是面向服务架构。\\n2. 基本的多进程架构进程有：浏览器主进程，渲染进程，GPU进程，网络进程，其他插件进程等。\\n3. 每个页面或者同站点将分配一个渲染进程。渲染进程是由多个线程相互协同。\\n4. 渲染进程组成：渲染主线程，js引擎线程，io线程，定时器线程，事件触发线程等\\n\\n#### 浏览器进程\\n\\n**1）浏览器主进程**\\n\\n负责包括地址栏，书签栏，前进后退按钮等部分的工作；\\n\\n**2）渲染进程**\\n\\n负责一个 tab 内关于网页呈现的所有事情\\n\\n**3）GPU进程**\\n\\n负责处理 GPU 相关的任务\\n\\n**4）网络进程**\\n\\n负责处理浏览器的一些不可见的底层操作，比如网络请求和文件访问；\\n\\n**5）其他插件进程**\\n\\n负责控制一个网页用到的所有插件，如 flash\\n\\n#### 渲染进程中都有什么线程？\\n\\n**1）GUI渲染线程**\\n\\n- 负责渲染浏览器界面，解析HTML、CSS、构建DOM树和RenderObject树、布局和绘制等；\\n- 当界面需要重绘（Repaint）或由于某种操作引发回流（reflow）时，该线程就会执行；\\n- 注意：**GUI渲染线程和JS引擎线程是互斥的，JS引擎线程优先级高于GUI渲染线程**，当JS引擎执行时GUI线程会被挂起，GUI更新会保存在一个队列中等到JS引擎空闲时间立即被执行。\\n\\n**2）JS引擎线程**\\n\\n- 也称为JS内核，负责处理和解析JavaScript脚本程序，运行代码，如V8引擎；\\n- JS引擎一直等待这任务队列中的任务，然后加以处理，render进程中永远只有一个JS线程在运行js程序\\n- 同样注意：**GUI渲染线程和JS引擎线程是互斥的，**JS执行时间过长，就会造成页面的渲染不连贯，导致页面渲染加载阻塞。\\n\\n**3）事件触发线程**\\n\\n- 归属于浏览器而不是JS引擎，用来控制事件循环；\\n- 当JS引擎执行代码块如：setTimeout、鼠标点击、Ajax异步请求，会将对应的任务添加到事件线程中；\\n- 当对应的时间服务触发条件时，该线程会把事件添加到待处理队列的队尾，等到JS引擎来处理。\\n\\n**4）定时处理线程**\\n\\n- setInterval与setTimeout所在的线程；\\n- 浏览器定时计数器并不是有JavaScript引擎计数的，它是通过单独线程来计时并触发定时；\\n- 注意：W3C在HTML标准中规定，要求setTimeout中低于4ms的时间间隔算为4ms。\\n\\n**5）异步http请求线程**\\n\\n- 在XMLHttpRequest在连接后通过浏览器新开一个线程请求\\n- 将检测到状态变更时，如果设置有回调函数，异步线程就会产生状态变更事件，将这个回调再放入事件队列中，再由JavaScript引擎执行。","answer":"","biz_type":1,"qid":113,"subject":"","title":"浏览器都有哪些进程，渲染进程中都有什么线程"},"tech_tag":["网络&安全"],"uid":0,"uname":""}],"page":1,"pages":1,"uid":4510},"status":0}')}}]);