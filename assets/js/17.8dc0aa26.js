(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{352:function(n){n.exports=JSON.parse('{"msg":"success","result":{"list":[{"audit_flag":0,"corp_tag":["滴滴","酷狗"],"date":"Fri, 19 Jun 2020 16:21:40 GMT","favorite_num":8,"qid":21,"qtype":"short_answer","short_answer":{"analysis":"在NodeJS中，中间件主要是指封装所有Http请求细节处理的方法。一次Http请求通常包含很多工作，如记录日志、ip过滤、查询字符串、请求体解析、Cookie处理、权限验证、参数验证、异常处理等，但对于Web应用而言，并不希望接触到这么多细节性的处理，因此引入中间件来简化和隔离这些基础设施与业务逻辑之间的细节，让开发者能够关注在业务的开发上，以达到提升开发效率的目的。\\n\\n中间件的行为比较类似Java中过滤器的工作原理，就是在进入具体的业务处理之前，先让过滤器处理。\\n\\n```js\\nconst http = require(\'http\')\\nfunction compose(middlewareList) {\\n  return function (ctx) {\\n    function dispatch (i) {\\n      const fn = middlewareList[i]\\n      try {\\n        return Promise.resolve(fn(ctx, dispatch.bind(null, i + 1)))\\n      } catch (err) {\\n        Promise.reject(err)\\n      }\\n    } \\n    return dispatch(0)\\n  }\\n}\\nclass App {\\n  constructor(){\\n    this.middlewares = []\\n  }\\n  use(fn){\\n    this.middlewares.push(fn)\\n    return this\\n  }\\n  handleRequest(ctx, middleware) {\\n    return middleware(ctx)\\n  }\\n  createContext (req, res) {\\n    const ctx = {\\n      req,\\n      res\\n    }\\n    return ctx\\n  }\\n  callback () {\\n    const fn = compose(this.middlewares)\\n    return (req, res) => {\\n      const ctx = this.createContext(req, res)\\n      return this.handleRequest(ctx, fn)\\n    }\\n  }\\n  listen(...args) {\\n    const server = http.createServer(this.callback())\\n    return server.listen(...args)\\n  }\\n}\\nmodule.exports = App\\n```","answer":"","biz_type":1,"qid":21,"subject":"","title":"如何封装 node 中间件"},"tech_tag":["Node"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["易车"],"date":"Fri, 19 Jun 2020 16:21:40 GMT","favorite_num":12,"qid":22,"qtype":"short_answer","short_answer":{"analysis":"1） 什么是中间层\\n\\n- 就是前端---请求---\x3e nodejs ----请求----\x3e后端 ----响应---\x3enodejs--数据处理---响应----\x3e前端。这么一个流程，这个流程的好处就是当业务逻辑过多，或者业务需求在不断变更的时候，前端不需要过多当去改变业务逻辑，与后端低耦合。前端即显示，渲染。后端获取和存储数据。中间层处理数据结构，返回给前端可用可渲染的数据结构。\\n- nodejs是起中间层的作用，即根据客户端不同请求来做相应的处理或渲染页面，处理时可以是把获取的数据做简单的处理交由底层java那边做真正的数据持久化或数据更新，也可以是从底层获取数据做简单的处理返回给客户端。\\n- 通常我们把Web领域分为客户端和服务端，也就是前端和后端，这里的后端就包含了网关，静态资源，接口，缓存，数据库等。而中间层呢，就是在后端这里再抽离一层出来，在业务上处理和客户端衔接更紧密的部分，比如页面渲染（SSR），数据聚合，接口转发等等。\\n- 以SSR来说，在服务端将页面渲染好，可以加快用户的首屏加载速度，避免请求时白屏，还有利于网站做SEO，他的好处是比较好理解的。\\n\\n2）中间层可以做的事情\\n\\n- 代理：在开发环境下，我们可以利用代理来，解决最常见的跨域问题；在线上环境下，我们可以利用代理，转发请求到多个服务端。\\n- 缓存：缓存其实是更靠近前端的需求，用户的动作触发数据的更新，node中间层可以直接处理一部分缓存需求。\\n- 限流：node中间层，可以针对接口或者路由做响应的限流。\\n- 日志：相比其他服务端语言，node中间层的日志记录，能更方便快捷的定位问题（是在浏览器端还是服务端）。\\n- 监控：擅长高并发的请求处理，做监控也是合适的选项。\\n- 鉴权：有一个中间层去鉴权，也是一种单一职责的实现。\\n- 路由：前端更需要掌握页面路由的权限和逻辑。\\n- 服务端渲染：node中间层的解决方案更灵活，比如SSR、模板直出、利用一些JS库做预渲染等等。\\n\\n\\n3）node转发API（node中间层）的优势\\n- 可以在中间层把java|php的数据，处理成对前端更友好的格式\\n- 可以解决前端的跨域问题，因为服务器端的请求是不涉及跨域的，跨域是浏览器的同源策略导致的\\n- 可以将多个请求在通过中间层合并，减少前端的请求\\n\\n4）如何做请求合并转发\\n- 使用express中间件multifetch可以将请求批量合并\\n- 使用express+http-proxy-middleware实现接口代理转发\\n\\n5）不使用用第三方模块手动实现一个nodejs代理服务器，实现请求合并转发\\n\\n1.实现思路\\n\\n- ①搭建http服务器，使用Node的http模块的createServer方法\\n- ②接收客户端发送的请求，就是请求报文，请求报文中包括请求行、请求头、请求体\\n- ③将请求报文发送到目标服务器，使用http模块的request方法\\n\\n2.实现步骤\\n\\n- 第一步：http服务器搭建\\n\\n```js\\nconst http = require(\\"http\\");\\nconst server = http.createServer();\\nserver.on(\'request\',(req,res)=>{\\n    res.end(\\"hello world\\")\\n})\\nserver.listen(3000,()=>{\\n    console.log(\\"running\\");\\n})\\n```\\n- 第二步：接收客户端发送到代理服务器的请求报文\\n\\n```js\\nconst http = require(\\"http\\");\\nconst server = http.createServer();\\nserver.on(\'request\',(req,res)=>{\\n    // 通过req的data事件和end事件接收客户端发送的数据\\n    // 并用Buffer.concat处理一下\\n    //\\n    let postbody = [];\\n    req.on(\\"data\\", chunk => {\\n        postbody.push(chunk);\\n    })\\n    req.on(\'end\', () => {\\n        let postbodyBuffer = Buffer.concat(postbody);\\n        res.end(postbodyBuffer)\\n    })\\n})\\nserver.listen(3000,()=>{\\n    console.log(\\"running\\");\\n})\\n```\\n这一步主要数据在客户端到服务器端进行传输时在nodejs中需要用到buffer来处理一下。处理过程就是将所有接收的数据片段chunk塞到一个数组中，然后将其合并到一起还原出源数据。合并方法需要用到Buffer.concat，这里不能使用加号，加号会隐式的将buffer转化为字符串，这种转化不安全。\\n\\n\\n- 第三步：使用http模块的request方法，将请求报文发送到目标服务器\\n  - 第二步已经得到了客户端上传的数据，但是缺少请求头，所以在这一步根据客户端发送的请求需要构造请求头，然后发送\\n\\n```js\\nconst http = require(\\"http\\");\\nconst server = http.createServer();\\n\\nserver.on(\\"request\\", (req, res) => {\\n    var { connection, host, ...originHeaders } = req.headers;\\n    var options = {\\n        \\"method\\": req.method,\\n        // 随表找了一个网站做测试，被代理网站修改这里\\n        \\"hostname\\": \\"www.nanjingmb.com\\",\\n        \\"port\\": \\"80\\",\\n        \\"path\\": req.url,\\n        \\"headers\\": { originHeaders }\\n    }\\n    //接收客户端发送的数据\\n    var p = new Promise((resolve,reject)=>{\\n        let postbody = [];\\n        req.on(\\"data\\", chunk => {\\n            postbody.push(chunk);\\n        })\\n        req.on(\'end\', () => {\\n            let postbodyBuffer = Buffer.concat(postbody);\\n            resolve(postbodyBuffer)\\n        })\\n    });\\n    //将数据转发，并接收目标服务器返回的数据，然后转发给客户端\\n    p.then((postbodyBuffer)=>{\\n        let responsebody=[]\\n        var request = http.request(options, (response) => {\\n            response.on(\'data\', (chunk) => {\\n                responsebody.push(chunk)\\n            })\\n            response.on(\\"end\\", () => {\\n                responsebodyBuffer = Buffer.concat(responsebody)\\n                res.end(responsebodyBuffer);\\n            })\\n        })\\n        // 使用request的write方法传递请求体\\n        request.write(postbodyBuffer)\\n        // 使用end方法将请求发出去\\n        request.end();\\n    })\\n});\\nserver.listen(3000, () => {\\n    console.log(\\"runnng\\");\\n})\\n```","answer":"","biz_type":1,"qid":22,"subject":"","title":"node 中间层怎样做的请求合并转发"},"tech_tag":["Node"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["滴滴","伴鱼","高德","自如","虎扑","58"],"date":"Fri, 19 Jun 2020 16:21:40 GMT","favorite_num":22,"qid":20,"qtype":"short_answer","short_answer":{"analysis":"#### 1）为什么会有Event Loop\\n\\n​    JavaScript的任务分为两种`同步`和`异步`，它们的处理方式也各自不同，**同步任务**是直接放在主线程上排队依次执行，**异步任务**会放在任务队列中，若有多个异步任务则需要在任务队列中排队等待，任务队列类似于缓冲区，任务下一步会被移到**调用栈**然后主线程执行调用栈的任务。\\n\\n> **调用栈**：调用栈是一个栈结构，函数调用会形成一个栈帧，帧中包含了当前执行函数的参数和局部变量等上下文信息，函数执行完后，它的执行上下文会从栈中弹出。\\n\\n​    JavaScript是`单线程`的，单线程是指 js引擎中解析和执行js代码的线程只有一个（主线程），每次只能做一件事情，然而`ajax`请求中，主线程在等待响应的过程中回去做其他事情，浏览器先在事件表注册ajax的回调函数，响应回来后回调函数被添加到任务队列中等待执行，不会造成线程阻塞，所以说js处理ajax请求的方式是异步的。\\n\\n​    综上所述，检查调用栈是否为空以及讲某个任务添加到调用栈中的个过程就是event loop，这就是JavaScript实现异步的核心。\\n\\n\\n\\n#### 2）浏览器中的 Event Loop\\n\\n##### Micro-Task 与 Macro-Task\\n\\n浏览器端事件循环中的异步队列有两种：macro（宏任务）队列和 micro（微任务）队列。\\n\\n常见的 macro-task：`setTimeout`、`setInterval`、`script（整体代码）`、` I/O 操作`、`UI 渲染`等。\\n\\n常见的 micro-task: `new Promise().then(回调)`、`MutationObserve `等。\\n\\n\\n\\n##### requestAnimationFrame\\n\\nrequestAnimationFrame也属于异步执行的方法，但该方法既不属于宏任务，也不属于微任务。按照MDN中的定义：\\n\\n> `window.requestAnimationFrame()` 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行\\n\\nrequestAnimationFrame是GUI渲染之前执行，但在`Micro-Task`之后，不过requestAnimationFrame不一定会在当前帧必须执行，由浏览器根据当前的策略自行决定在哪一帧执行。\\n\\n\\n\\n##### event loop过程\\n\\n![](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-20-1.jpg)\\n\\n1. 检查macrotask队列是否为空，非空则到2，为空则到3\\n2. 执行macrotask中的一个任务\\n3. 继续检查microtask队列是否为空，若有则到4，否则到5\\n4. 取出microtask中的任务执行，执行完成返回到步骤3\\n5. 执行视图更新\\n\\n> 当某个宏任务执行完后,会查看是否有微任务队列。如果有，先执行微任务队列中的所有任务，如果没有，会读取宏任务队列中排在最前的任务，执行宏任务的过程中，遇到微任务，依次加入微任务队列。栈空后，再次读取微任务队列里的任务，依次类推。\\n\\n\\n\\n#### 3）node中的 Event Loop\\n\\nNode 中的 Event Loop 和浏览器中的是完全不相同的东西。Node.js采用V8作为js的解析引擎，而I/O处理方面使用了自己设计的libuv，libuv是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的API，事件循环机制也是它里面的实现\\n\\n![](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-20-2.png)\\n\\n根据上图node的运行机制如下\\n\\n1. V8引擎解析JavaScript脚本。\\n2. 解析后的代码，调用Node API。\\n3. libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。\\n4. V8引擎再将结果返回给用户。\\n\\n\\n\\n##### 六大阶段\\n\\n其中libuv引擎中的事件循环分为 6 个阶段，它们会按照顺序反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。\\n\\n![](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-20-3.png)\\n\\n1. `timers` 阶段：这个阶段执行timer（setTimeout、setInterval）的回调，并且是由 poll 阶段控制的。\\n2. `I/O callbacks` 阶段：处理一些上一轮循环中的少数未执行的 I/O 回调\\n3. `idle, prepare` 阶段：仅node内部使用\\n4. `poll` 阶段：获取新的I/O事件, 适当的条件下node将阻塞在这里\\n5. `check` 阶段：执行 setImmediate() 的回调\\n6. `close callbacks` 阶段：执行 socket 的 close 事件回调\\n\\n\\n\\n#####  poll阶段\\n\\npoll 是一个至关重要的阶段，这一阶段中，系统会做两件事情\\n\\n1.回到 timer 阶段执行回调\\n\\n2.执行 I/O 回调\\n\\n并且在进入该阶段时如果没有设定了 timer 的话，会发生以下两件事情\\n\\n- 如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制\\n- 如果 poll 队列为空时，会有两件事发生\\n  - 如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调\\n  - 如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去\\n\\n当然设定了 timer 的话且 poll 队列为空，则会判断是否有 timer 超时，如果有的话会回到 timer 阶段执行回调。\\n\\n\\n\\n##### Micro-Task 与 Macro-Task\\n\\nNode端事件循环中的异步队列也是这两种：macro（宏任务）队列和 micro（微任务）队列。\\n\\n- 常见的 macro-task 比如：`setTimeout`、`setInterval`、 `setImmediate`、`script（整体代码`）、` I/O 操作等`。\\n- 常见的 micro-task 比如: `process.nextTick`、`new Promise().then(回调)`等。\\n\\n\\n\\n##### setTimeout 和 setImmediate\\n\\n二者非常相似，区别主要在于调用时机不同。\\n\\n- setImmediate 设计在poll阶段完成时执行，即check阶段；\\n- setTimeout 设计在poll阶段为空闲时，且设定时间到达后执行，但它在timer阶段执行\\n\\n```javascript\\nsetTimeout(function timeout () {\\n  console.log(\'timeout\');\\n},0);\\nsetImmediate(function immediate () {\\n  console.log(\'immediate\');\\n});\\n```\\n\\n1. 对于以上代码来说，setTimeout 可能执行在前，也可能执行在后。\\n2. 首先 setTimeout(fn, 0) === setTimeout(fn, 1)，这是由源码决定的 进入事件循环也是需要成本的，如果在准备时候花费了大于 1ms 的时间，那么在 timer 阶段就会直接执行 setTimeout 回调\\n3. 如果准备时间花费小于 1ms，那么就是 setImmediate 回调先执行了\\n\\n\\n\\n#####  process.nextTick\\n\\n这个函数其实是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行\\n\\n\\n\\n#### 4）Node与浏览器的 Event Loop 差异\\n\\n![](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-20-4.png)\\n\\n- Node端，microtask 在事件循环的各个阶段之间执行\\n- 浏览器端，microtask 在事件循环的 macrotask 执行完之后执行\\n","answer":"","biz_type":1,"qid":20,"subject":"","title":"说一下事件循环机制(node、浏览器)"},"tech_tag":["Node","JavaScript"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":[],"date":"Fri, 19 Jun 2020 16:20:44 GMT","favorite_num":6,"qid":770,"qtype":"short_answer","short_answer":{"analysis":"### 一、分类\\n\\nnode 应用监控主要分为两类：\\n\\n- 一种是业务逻辑型的监控\\n- 一种是硬件行的监控\\n\\n### 二、性能监控\\n\\nnode 性能监控主要分为以下几点：\\n\\n#### 1）日志监控\\n\\n可以通过监控异常日志的变动，将新增的异常类型和数量反映出来。\\n\\n监控日志可以实现 PV 和 UV 的的监控，通过 PV/UV 的监控，可以知道应用使用者们的使用习惯，预知访问高峰\\n\\n#### 2）响应时间\\n\\n响应时间也是一个需要监控的点。一旦系统的某个子系统出现异常或者性能瓶颈将会导致\\n\\n系统的响应时间变长。响应时间可以在 Nginx 一类的反向代理上监控，也可以通过应用自行产生\\n的访问日志来监控。\\n\\n#### 3）进程监控\\n\\n监控日志和响应时间都能较好地监控到系统的状态，但是它们的前提是系统是运行状态的，\\n\\n所以监控进程是比前两者更为紧要的任务。监控进程一般是检査操作系统中运行的应用进程数，\\n\\n比如对于采用多进程架构的 Web 应用，就需要检査工作进程的数,如果低于预估值，就应当发出报警。\\n\\n#### 4）磁盘监控\\n\\n磁盘监控主要是监控磁盘的用量。\\n\\n由于日志频繁写的缘故，磁盘空间渐渐被用光。一且磁盘不够用，将会引发系统的各种问题 给豪盘的使用量设置一个上限，一旦磁盘用量超过警戒值，服务器的管理者就应诙整理日志或清理磁盘。\\n\\n#### 5）内存监控\\n\\n对于 Node 而言，一旦出现内存泄漏，不是那么容易排査的。监控服务器的内存使用状况，可以检査应用中是否存在内存泄漏的状况。如果内存只升不降，那么铁定存在内存泄漏问题。\\n\\n健康的内存使用应当是有升有降，在访问量大的时候上升，在访问量回落的时候，占用量也随之回落。\\n\\n监控内存异常时间也是防止系统出现异常的好方法。如果突然岀现内存异常，也能够追踪到是近期的那些代码改动导致的问题。\\n\\n#### 6）cpu 占用监控\\n\\n服务器的 CPU 占用监控也是必不可少的项，CPU 的使用分为用户态、内核态、IOWait 等。\\n\\n如果用户态 CPU 使用率较高，说明服务器上的应用需要大量的 CPU 开销；\\n\\n如果内核态 CPU 使用率较高，说明服务器花费大量时间进行进程调度或者系统调用；IOWait 使用率则反应的是 CPU 等待磁盘I/O 操作。\\n\\nCPU 的使用率中，用户态小于 70%、内核态小于 35%且整体小于 70%时，处于健康状态。\\n\\n监控CPU占用情况，可以帮助分析应用程序在实际业务中的状况。合理设置监控阈值能够很好地预警。\\n\\n#### 7）CUP load 监控\\n\\nCPU load 又称 CPU 平均负载，它用来描述操作系统当前的繁忙程度，可以简单地理解为 CPU在单位时间内正在使用和等待使用 CPU 的平均任务数。\\n\\n它有 3 个指标，即 1 分钟的平均负载、5 分钟的平均负载、15 分钟的平均负载。CPU load 过高说明进程数量过多，这在 Node 中可能体现在用于进程模块反复启动新的进程。监控该值可以防止意外产生。\\n\\n#### 8）I/O 负载\\n\\nI/O 负载指的主要是磁盘 I/O。反应的是磁盘上的读写情况，对于 Node 编写的应用，主要是面向网络务，是不太可能出现 I/O 负载过高的情况，大多数的 I/O 压力来自于数据库。不管 Node进程是否与数据库或其他 I/O 密集的应用共处相同的服务器，我们都应监控该值以防万一。\\n\\n#### 9）网络监控\\n\\n虽然网络流量监控的优先级没有上述项目那么高，但还是需要对流量进行监控并设量上限值。即便应用突然受到用户的青昧，流量暴涨时也能通过数值感知到网站的宣传是否有效。\\n\\n一旦流量超过警戒值，开发者就应当找出流量增长的原因。对于正常増长，应当评估是否该增加硬件设备来为更多用户提供服务。\\n\\n网络流量监控的两个主要指标是流入流量和流出流量。\\n\\n#### 10）应用状态监控\\n\\n除了这些硬性需要检测的指标外，应用还应当提供一种机制来反馈其自身的状态信息，外部监控将会持续性地调用应用的反馈接口来检査它的健康状态。\\n\\n#### 11）DNS 监控\\n\\nDNS 是网络应用的基础，在实际的对外服务产品中.多数都对域名有依賴。DNS 故障导致产品出现大面积影响的事件并不少见。由于 DNS 服务通常是稳定的，容易让人忽略，但一旦出现故障，就可能是史无前例的故障。\\n\\n对于产品的稳定性，域名 DNS 状态也需要加入监控。\\n\\n### 三、性能优化\\n\\n#### 1）web 应用层的优化\\n\\n对于 web 应用主要以下几个提升性能的方法：\\n\\n**1.动静分离**\\n\\n在普通的 Web 应用中，Node 尽管也能通过中间件实现静态文件服务，但是 Node 处理静态文件的能力并不算突出。\\n\\n将图片、字体、样式表和多媒体等静态文件都引导到专业的静态文件服务器上，让 Node 只处理动态请求即可。这个过程可以用 Nginx 或者专业的 CDN 来处理。\\n\\n将动态请求和静态请求分离后，服务器可以专注在动态服务方面，专业的 CDN 会将靜态文件与用户尽可能靠近，同时能够有更精确和高效的缓存机制。\\n\\n静态文件请求分离后，对动态请求使用不同的域名或多个域名还能消除掉不必要的 Cookie 传输和浏览器对下载线程数的限制。\\n\\n**2.启用缓存**\\n\\n提升性能其实羞不多只有两个途经，一是提升服务的速度，二是避免不必要的计算。前者提升的性能在海量流量面前终有瓶颈，但后者却能够在访问量越大是收益越多。避免不必要的计算，应用场景最多的就是缓存。\\n\\n尽管同步 I/O 在 CPU 等待时浪费的时间较为严重,但是在缓存的帮助下，却能消减同步 I/O带来的时间浪费。但不管是同步哄是异步 I/O,遇免不必要的计算这条原则如果遵循得较好，性能提升是显著的。\\n\\n**3.多进程架构**\\n\\n通过多进程架构,不仅可以充分利用多核 CPU, 更是可以建立机制让 Node 进程更加健壮，以保障 Web 应用持续服务。如：pm2 这样的模块用于进程管理\\n\\n**4.读写分离**\\n\\n除了动静分离外，另一个较为重要的分离是读写分离，这主要针对数据库而言。就任意数据库而言，读取的速度远远高于写入的速度。而某些数据库在写入时为了保证数据一致性，会进行锁表操作，这同时会彩响到读取的速度。某些系统为了提升性能,通常会进行数据库的读写分离, 将地库进行主从设计，这样读数据操作不再受到写入的影响，降低了性能的彩响。\\n\\n#### 2）代码层的优化\\n\\n**1.使用最新版版的 node.js**\\n\\n仅仅使用最新版本的 node.js 就能提升性能的提升，node 每个版本的性能提升来自两个方面\\n\\n- V8 的版本更新；\\n- Node.js 内部代码的更新优化。\\n\\n**2.使用 fast-json-stringify 加速 JSON 序列化**\\n\\n在 JSON 序列化时，我们需要识别大量的字段类型。比如对于string 类型，我们就需要在两边加上 \\"，对于数组类型，我们需要遍历数组，把每个对象序列化后，用 `,` 隔开，然后在两边加上 `[` 和 `]`\\n\\n如果已经提前通过 Schema 知道每个字段的类型，那么就不需要遍历、识别字段类型，而可以直接用序列化对应的字段，这就大大减少了计算开销，这就是 fast-json-stringfy 的原理。\\n\\n**3.正确的编写异步代码**\\n\\n使用 Promise.all()\\n\\n```js\\n// bad\\nasync function getDatas(params) {\\n  const data1 = await getData1(params);\\n  const data2 = await getData2(params)\\n  return { data1, data2 }\\n}\\n\\n// good\\nasync function getDatas(params) {\\n  const [data1, data2] = await Promise.all([\\n      getData1(params),\\n      getData2(params)\\n  ])\\nreturn { profile, repo }\\n```\\n\\n### 四、如何做错误监控\\n\\n#### 1）错误类型\\n\\n- 当出现语法错误或运行时错误时，会触发 JavaScript 错误\\n- 当试图试访问一个不存在或没有访问的文件时，会触发系统错误；\\n- 除 JavaScript 错误和系统错误错误外，用户还可以自定义错误。\\n\\n#### 2）监控异常日志\\n\\n异常日志通常用来记录那些意外产生的异常错误。通过日志的记录，可以根据异常信息，去定位 bug 出现的具体位置，以快速修复问题。\\n\\n**1.如何生成日志**\\n\\n使用日志中间件，日志中间件可以将关键数据按一定格式输出到日志文件中。如：\\n\\n- log4js\\n- connect\\n\\n错误监控平台\\n\\n- sentry，sentry 是一个开源的实时错误报告工具，支持 web 前后端\\n\\n**2）异常日志分级**\\n\\nnode 中提供的 console 对象简单划分：\\n\\n- console.logt 普通日志。\\n- console.info 普通信息。\\n- console.warn 警告值息。\\n- console.error 错误值息。\\n- console 块在具体实现时，log 与 info 方法标将侑息输出给标准输出 pxocess.stdout, warn 与 error 方法则将信真输出到标准错误 process.stderr, 而 info 和 error 分别是 log 和 warn 的别名。","answer":"","biz_type":1,"qid":770,"subject":"","title":"Node性能如何进监控以及优化？"},"tech_tag":["Node"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["高思教育"],"date":"Fri, 19 Jun 2020 16:20:44 GMT","favorite_num":5,"qid":723,"qtype":"short_answer","short_answer":{"analysis":"### 一、使用socket.io 实现PC端、移动端跨域通信\\n\\n#### 创建服务\\n\\n```js\\nconst server = http.createServer((req,res)=>{\\n    // 允许所有跨域请求\\n    res.setHeader(\'Access-Control-Allow-Origin\', \'*\');\\n    req.writeHead(200,{\'Content-Type\':\'text/html\'})\\n    res.end(\'\')\\n}).listen(8001)\\n\\nlet mobile = null,pc = null , mobileReady = false , pcReady = false;\\n\\n// 连接socket.io\\nsocket.listen(server).on(\'connection\',(conn)=>{\\n    conn.on(\'message\',(str)=>{\\n        if(str===\\"Mobile\\"){\\n            mobile = conn;\\n            mobileReady = true;\\n            conn.send(\'连接成功\');\\n        }\\n        if(str===\\"PC\\"){\\n            pc = conn;\\n            pcReady = true;\\n        }\\n\\n        if(mobileReady&&pcReady){\\n            if(str===\'PC\') str=\'PC\'\\n            pc.send(str);\\n        }\\n    })\\n    \\n    conn.on(\\"disconnection\\",(code, reason) => {\\n        console.log(\\"关闭连接\\")\\n    });\\n})\\n```\\n\\n#### pc端\\n\\n```js\\n// 跨域地址\\n// 这里注意一下 不能写127.0.0.1 或者localhost 不然其他客户端访问不到\\nconst socket = io(\'192.168.1.115:8001\')\\n\\nsocket.on(\'connect\', () => {\\n    // 连接成功\\n    socket.send(\'PC\')\\n    // 监听连接\\n    socket.on(\'message\', (msg) => {\\n        \\n        // console.log(msg)\\n    })\\n    // 关闭连接\\n    socket.on(\'disconnect\', () => {\\n\\n    })\\n})\\n```\\n\\n#### 移动端\\n\\n```js\\nconst socket = io(\'192.168.1.115:8001\')\\n\\nsocket.on(\'connect\', () => {\\n    // 连接成功\\n    socket.send(\'Mobile\')\\n    // 监听连接\\n    socket.on(\'message\', (msg) => {\\n        // console.log(msg)\\n    })\\n    // 关闭连接\\n    socket.on(\'disconnect\', () => {\\n\\n    })\\n    socket.send();\\n})\\n```\\n\\n### 二、设置Node服务端\\n\\n```js\\nvar app = express();\\n//设置跨域访问\\napp.all(\'*\', function(req, response, next) {\\n    //设置允许跨域的域名，*代表允许任意域名跨域\\n    response.header(\\"Access-Control-Allow-Origin\\", \\"*\\");\\n    //允许的header类型\\n    response.header(\\"Access-Control-Allow-Headers\\", \\"X-Requested-With\\");\\n    //跨域允许的请求方式\\n    response.header(\\"Access-Control-Allow-Methods\\",\\"PUT,POST,GET,DELETE,OPTIONS\\");\\n    //设置响应头信息\\n    response.header(\\"X-Powered-By\\",\' 3.2.1\')\\n    response.header(\\"Content-Type\\", \\"application/json;charset=utf-8\\");\\n    next();\\n});\\n```\\n\\n#### 设置允许指定域名“http://www.XXX.com”跨域：\\n\\n```js\\nres.header(\\"Access-Control-Allow-Origin\\",\\"http://www.XXX.com\\");\\n```\\n\\n#### 设置允许多个域名跨域：\\n\\n```js\\nif( req.headers.origin.toLowerCase() == \\"http://www.xxxx.com\\"  ||  req.headers.origin.toLowerCase() ==\\"http://127.0.0.1\\" ) {\\n    //设置允许跨域的域名\\n    res.header(\\"Access-Control-Allow-Origin\\", req.headers.origin);\\n}\\n```\\n\\n#### 如果允许的域名较多，可以将允许跨域的域名放到数组当中：\\n\\n```js\\nvar orginList=[\\n    \\"http://www.xxx.com\\",\\n    \\"http://www.alibaba.com\\",\\n    \\"http://www.qq.com\\",\\n    \\"http://www.baidu.com\\"\\n]\\nif(orginList.includes(req.headers.origin.toLowerCase())){\\n    //设置允许跨域的域名\\n    res.header(\\"Access-Control-Allow-Origin\\",req.headers.origin);\\n}\\n```","answer":"","biz_type":1,"qid":723,"subject":"","title":"node 如何进行跨域通信"},"tech_tag":["Node"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":[],"date":"Fri, 19 Jun 2020 16:20:44 GMT","favorite_num":5,"qid":769,"qtype":"short_answer","short_answer":{"analysis":"### 一、Stack算法原理\\n\\n假如有A、B、C、D四个组件，层级结构为：\\n\\n![Stack](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-765-stach.png)\\n\\n**组件的生命周期为:**\\n\\n- 挂载阶段：constructor()、componentWillMount()、render()、componentDidMount()\\n- 更新阶段为componentWillReceiveProps()、shouldComponentUpdate()、componentWillUpdate()、render()、componentDidUpdate\\n\\n**在挂载阶段，A,B,C,D的生命周期渲染顺序是**\\n\\n![组件生成周期](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-765-lifcycle.png)\\n\\n以render()函数为分界线。从顶层组件开始，一直往下，直至最底层子组件。然后再往上，组件update阶段同理。\\n\\n**Stack存在的问题**\\n\\n底层使用递归，递归并不好中途被打断，如果这是一个很大，层级很深的组件，react渲染它需要几十甚至几百毫秒，在这期间，react会一直占用浏览器主线程，任何其他的操作（包括用户的点击，鼠标移动等操作）都无法执行。这种情况下，页面就会出现卡顿甚至假死的现象。\\n\\n### 二、Fiber算法原理\\n\\nFiber架构用了分片的方式解决上面的问题，就是把一个任务分成很多小片，当分配给这个小片的时间用尽的时候，就检查任务列表中有没有新的、优先级更高的任务，有就做这个新任务，没有就继续做原来的任务。这种方式被叫做异步渲染(Async Rendering)。如下图所示：\\n\\n![异步渲染](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-654-fiber-arch.png)\\n\\n加入fiber的react将组件更新分为两个时期：phase1和phase2，这两个时期以render为分界，render前的生命周期为phase1,render后的生命周期为phase2。\\n\\n**phase1的生命周期是可以被打断的**，每隔一段时间它会跳出当前渲染进程，去确定是否有其他更重要的任务。此过程，React 在 workingProgressTree （并不是真实的virtualDomTree）上复用 current 上的 Fiber 数据结构来一步地（通过requestIdleCallback）来构建新的 tree，标记出需要更新的节点，放入队列中。\\n\\n**phase2的生命周期是不可被打断的**，React 将其所有的变更一次性更新到DOM上。这里最重要的是phase1这是时期所做的事。因此我们需要具体了解phase1的机制。如果不被打断，那么phase1执行完会直接进入render函数，构建真实的virtualDomTree。如果组件再phase1过程中被打断，即当前组件只渲染到一半（也许是在willMount,也许是willUpdate~反正是在render之前的生命周期），那么react会怎么干呢？ react会放弃当前组件所有干到一半的事情，去做更高优先级更重要的任务（当然，也可能是用户鼠标移动，或者其他react监听之外的任务），当所有高优先级任务执行完之后，react通过callback回到之前渲染到一半的组件，从头开始渲染。（看起来放弃已经渲染完的生命周期，会有点不合理，反而会增加渲染时长，但是react确实是这么干的）。也就是 所有phase1的生命周期函数都可能被执行多次，因为可能会被打断重来。因为可能会被执行多次，那么我们最好就得保证phase1的生命周期每一次执行的结果都是一样的，否则就会有问题，因此，最好都是纯函数。\\n\\n### 三、fiber数据结构\\n\\nfiber本质是个链表，有child和sibing属性，指向第一个子节点和相邻的兄弟节点，从而构成fiber tree。return属性指向其父节点。\\n\\n更新队列，updateQueue，是一个链表，有first和last两个属性，指向第一个和最后一个update对象。每个fiber有一个属性updateQueue指向其对应的更新队列。\\n\\n每个fiber（当前fiber可以称为current）有一个属性alternate，开始时指向一个自己的clone体，update的变化会先更新到alternate上，当更新完毕，alternate替换current。\\n\\n结构如下图所示：\\n\\n![fiber数据结构](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-654-fiberprinciple.png)\\n\\n由上图可以看出：通过链表，每个节点都可以找到它的父节点、兄弟节点、子节点。这里需要注意的是，父节点只指向它的第一个子节点，而不是全部，兄弟节点也是指向下一个兄弟节点，不是全部。\\n\\n### 四、关键API：requestIdleCallback\\n\\nMDN对该api描述如下：`window.requestIdleCallback()`方法将在浏览器的空闲时段内调用的函数排队。这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应。函数一般会按先进先调用的顺序执行，然而，如果回调函数指定了执行超时时间timeout，则有可能为了在超时前执行函数而打乱执行顺序。你可以在空闲回调函数中调用requestIdleCallback()，以便在下一次通过事件循环之前调度另一个回调。\\n\\n使用该方法，fiber实现了分片\\n\\n### 五、fiber 架构的本质\\n\\n1. 循环条件：利用 requestIdeCallback 空闲时间递减。\\n2. 遍历过程：利用链表，找孩子找兄弟找父亲。\\n3. React Fiber 是一种基于浏览器的单线程调度算法.React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使用了循环来代替之前的递归。\\n\\n`fiber`是React16的新特性，是对之前`diff`算法的重写，主要是把一次计算，改变为多次计算，在浏览器有高级任务时，暂停计算。`fiber`的问世就是为了解决之前大量计算导致浏览器掉帧的现象。\\n\\n相对于之前`stack`，源码上核心的变化就是讲原先递归改为循环。\\n\\n旧版`stack`算法是一条路走到黑，运作的过程是不能被打断的，通过递归的方式进行渲染，使用的是JS引擎自身的函数调用栈，它会一直执行到栈空为止，由于JS是单线程的，所以大量计算会导致主线程长时间被占用。\\n\\n新版`fiber`实现了自己的调用栈，它以链表的形式遍历组件树，可以灵活的暂停、继续和丢弃执行的任务。实现方式是使用了浏览器的`requestIdleCallback`这一 API，在主线程空闲时计算。\\n\\n1）为了达到这种效果，就需要有一个调度器 (Scheduler) 来进行任务分配。\\n\\n任务的优先级有六种：\\n\\n- synchronous，与之前的Stack Reconciler操作一样，同步执行\\n- task，在next tick之前执行\\n- animation，下一帧之前执行\\t\\n- high，在不久的将来立即执行\\n- low，稍微延迟执行也没关系\\n- offscreen，下一次render时或scroll时才执行\\n\\n2）优先级高的任务（如键盘输入）可以打断优先级低的任务（如Diff）的执行，从而更快的生效\\n\\n`fiber`实际上是一种数据结构，用`js`对象表示就是：\\n\\n```js\\nconst fiber = {\\n    stateNode,    // 节点实例\\t\\n    child,        // 子节点\\n    sibling,      // 兄弟节点\\n    return,       // 父节点\\n}\\n```\\n\\n3）Fiber Reconciler 在执行过程中，会分为 2 个阶段。\\n\\n- 阶段一，生成`Fiber tree`，得出需要更新的节点信息。这一步是一个渐进的过程，可以被打断。\\n- 阶段二，将需要更新的节点一次过批量更新，这个过程不能被打断。\\n\\n阶段一可被打断的特性，让优先级更高的任务先执行，从框架层面大大降低了页面掉帧的概率。\\n\\n### 六、fiber与stack比较\\n\\n**1）数据结构的调整**\\n\\n- 现在使用扁平化的 链表 的数据存储结构，使用循环迭代来代替之前的递归；\\n- 每个 VirtualDOM 节点内部现在使用 Fiber node表示,模拟函数调用栈，保存了节点处理的上下文信息，方便中断和恢复；\\n\\n```js\\n export type Fiber = {\\n    ...\\n    //  链表结构\\n    return: Fiber | null,  // 指向父节点，或者render该节点的组件\\n    child: Fiber | null, // 指向第一个子节点\\n    sibling: Fiber | null, // 指向下一个兄弟节点\\n    ...\\n}\\n```\\n\\n**2）两个阶段的拆分**\\n\\n之前是一边Diff一边commit提交的, 现在分为两个阶段\\n\\n**①reconciliation 协调阶段** \\n\\n协调阶段是可以被打断的\\n\\n- constructor\\n- componentWillMount 废弃\\n- componentWillReceiveProps 废弃\\n- static getDerivedStateFromProps\\n- shouldComponentUpdate\\n- componentWillUpdate 废弃\\n- render\\n\\n因为Reconciliation阶段能被打断，所以会出现多次调用的情况，所以这些生命周期函数应该避免使用，16版之后标记为不安全的；\\n\\n**②commit 提交阶段**\\n\\n不能暂停，一直到界面更新完成；\\n\\n- getSnapshotBeforeUpdate()\\n- componentDidMount\\n- componentDidUpdate\\n- componentWillUnmount\\n\\n该阶段为了正确地处理各种副作用，包括DOM变更、还有你在componentDidMount中发起的异步请求、useEffect 中定义的副作用等等。\\n\\n因为有副作用，所以必须保证按照次序只调用一次，况且会有用户可以察觉到的变更, 所以不能中断；\\n\\n### 七、总结\\n\\n旧版React在一些响应体验要求较高的场景不适用，比如动画，布局和手势。\\n\\n根本原因是渲染/更新过程一旦开始无法中断，持续占用主线程，主线程忙于执行JS，无暇他顾（布局、动画），造成掉帧、延迟响应（甚至无响应）等不佳体验。`Fiber`就是用来解决这类问题的，把渲染/更新过程拆分为小块任务，通过合理的调度机制来控制时间，更细粒度、更强的控制力。\\n\\nFiber：一种将 recocilation （递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。这种算法并没有减少渲染时间，相反，由于某些函数中途中断，再从头开始执行，时间反而有可能会增加。但是通过把重要的任务提前，空间时间执行非重要任务，解决了那些组件深层递归的页面的卡顿和假死现象，提升了用户体验。\\n\\n\\n\\n\\n","answer":"","biz_type":1,"qid":769,"subject":"","title":"React SSR实现过程？原理是什么？有什么注意事项？"},"tech_tag":["Node"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":[],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":4,"qid":591,"qtype":"short_answer","short_answer":{"analysis":"### 通过工具检查不支持的ES6语法\\n\\nnode版本不同，对es6语法的支持也会不同，可以安装 **es-checker** 检查对es6语法的支持程度。\\n\\n```js\\nnpm install -g es-checker\\nes-checker\\n```\\n\\n不支持的语法会显示出来\\n\\n```js\\nECMAScript 6 Feature Detection (v1.4.2)\\n\\nVariables\\n  √ let and const\\n  √ TDZ error for too-early access of let or const declarations\\n  √ Redefinition of const declarations not allowed\\n  √ destructuring assignments/declarations for arrays and objects\\n  √ ... operator\\n\\nData Types\\n  √ For...of loop\\n  √ Map, Set, WeakMap, WeakSet\\n  √ Symbol\\n  √ Symbols cannot be implicitly coerced\\n\\nNumber\\n  √ Octal (e.g. 0o1 ) and binary (e.g. 0b10 ) literal forms\\n  √ Old octal literal invalid now (e.g. 01 )\\n  √ Static functions added to Math (e.g. Math.hypot(), Math.acosh(), Math.imul() )\\n  √ Static functions added to Number (Number.isNaN(), Number.isInteger() )\\n\\nString\\n  √ Methods added to String.prototype (String.prototype.includes(), String.prototype.repeat() )\\n  √ Unicode code-point escape form in string literals (e.g. \\\\u{20BB7} )\\n  √ Unicode code-point escape form in identifier names (e.g. var \\\\u{20BB7} = 42; )\\n  √ Unicode code-point escape form in regular expressions (e.g. var regexp = /\\\\u{20BB7}/u; )\\n  √ y flag for sticky regular expressions (e.g. /b/y )\\n  √ Template String Literals\\n\\nFunction\\n  √ arrow function\\n  √ default function parameter values\\n  √ destructuring for function parameters\\n  √ Inferences for function name property for anonymous functions\\n  × Tail-call optimization for function calls and recursion\\n\\nArray\\n  √ Methods added to Array.prototype ([].fill(), [].find(), [].findIndex(), [].entries(), [].keys(), [].values() )\\n  √ Static functions added to Array (Array.from(), Array.of() )\\n  √ TypedArrays like Uint8Array, ArrayBuffer, Int8Array(), Int32Array(), Float64Array()\\n  √ Some Array methods (e.g. Int8Array.prototype.slice(), Int8Array.prototype.join(), Int8Array.prototype.forEach() ) added to the TypedArray prototypes\\n  √ Some Array statics (e.g. Uint32Array.from(), Uint32Array.of() ) added to the TypedArray constructors\\n\\nObject\\n  √ __proto__ in object literal definition sets [[Prototype]] link\\n  √ Static functions added to Object (Object.getOwnPropertySymbols(), Object.assign() )\\n  √ Object Literal Computed Property\\n  √ Object Literal Property Shorthands\\n  √ Proxies\\n  √ Reflect\\n\\nGenerator and Promise\\n  √ Generator function\\n  √ Promises\\n\\nClass\\n  √ Class\\n  √ super allowed in object methods\\n  √ class ABC extends Array { .. }\\n\\nModule\\n  × Module export command\\n  × Module import command\\n\\n\\n=========================================\\nPasses 39 feature Detections\\nYour runtime supports 92% of ECMAScript 6\\n=========================================\\n```\\n\\n**可以看出目前不支持尾递归调用、`esmodule`**\\n\\n解决办法可以通过`babel`将ES6代码转换为Node支持的语法。\\n\\n```js\\nnpm install --save-dev babel-cli babel-preset-es2015 babel-preset-es2017\\n```\\n\\n其中babel-cli使我们可以在终端中使用babel命令，如同webpack对应的webpack-cli包，而 `babel-preset-*` 是babel转换代码时所依赖的前置规则的插件集合,安装完成后，在同目录下配置使用babel,新建 `.babelrc` 文件，其中presets字段里添加我们的转换规则，可以只写前边提到的 `babel-preset-*`中 `*`  对应的关键字作为缩写，plugins中可以配置一些定义转换规则的插件。配置完成后，就可以在我的终端中用babel对我的代码进行转换了。","answer":"","biz_type":1,"qid":591,"subject":"","title":"Node 不支持哪些 ES6 语法"},"tech_tag":["Node"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["宝宝树"],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":4,"qid":523,"qtype":"short_answer","short_answer":{"analysis":"### 区别\\n\\n**npm2和npm3最主要的区别在依赖的处理**\\n\\nnpm2所有项目依赖是嵌套关系，\\n\\n而npm3为了改进嵌套过多、套路过深的情况，会将所有依赖放在第二层依赖中（所有依赖只嵌套一次，彼此平行，也就是平铺的结构）\\n\\nnpm2依赖安装的时候比较简单直接，直接按照包依赖的树形结构下载填充本地目录结构，也就是说每个包都会将该包的依赖组织到当前包所在的node_modules目录中。\\n\\nnpm3则对依赖安装进行了改造，采用”扁平结构“的思路来组织依赖包的目录结构。具体的就是`npm install`时：\\n\\n按照 package.json 里依赖的顺序依次解析，遇到新的包就把它放在第一级目录，后面如果遇到一级目录已经存在的包，会先判断版本，如果版本一样则忽略，否则会按照 npm2 的方式依次挂在依赖包目录下。\\n\\n![](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-523-npmdiff.png)","answer":"","biz_type":1,"qid":523,"subject":"","title":"npm2 和 npm3+有什么区别"},"tech_tag":["Node"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["宝宝树"],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":5,"qid":522,"qtype":"short_answer","short_answer":{"analysis":"### 一、Node文件查找流程\\n\\n![path-search](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-522-path.png)\\n\\n#### 1.node文件查找优先级\\n\\n**1.1从文件模块缓存中加载**\\n\\n尽管原生模块与文件模块的优先级不同，但是都不会优先于从文件模块的缓存中加载已经存在的模块。\\n\\n**1.2从原生模块加载**\\n\\n原生模块的优先级仅次于文件模块缓存的优先级。require方法在解析文件名之后，优先检查模块是否在原生模块列表中。以http模块为例，尽管在目录下存在一个 `http/http.js/http.node/http.json` 文件，`require(“http”)` 都不会从这些文件中加载，而是从原生模块中加载。\\n\\n原生模块也有一个缓存区，同样也是优先从缓存区加载。如果缓存区没有被加载过，则调用原生模块的加载方式进行加载和执行。\\n\\n**1.3从文件加载**\\n\\n当文件模块缓存中不存在，而且不是原生模块的时候，Node.js会解析require方法传入的参数，并从文件系统中加载实际的文件，加载过程中的包装和编译细节在前一节中已经介绍过，这里我们将详细描述查找文件模块的过程，其中，也有一些细节值得知晓。\\n\\nrequire方法接受以下几种参数的传递：\\n\\n1. http、fs、path等，原生模块。 \\n2. ./mod或../mod，相对路径的文件模块。 \\n3. /pathtomodule/mod，绝对路径的文件模块。 \\n4. mod，非原生模块的文件模块。\\n\\n在进入路径查找之前有必要描述一下module path这个Node.js中的概念。对于每一个被加载的文件模块，创建这个模块对象的时候，这个模块便会有一个paths属性，其值根据当前文件的路径计算得到。我们创建modulepath.js这样一个文件，其内容为：\\n\\n```js\\nconsole.log(module.paths);\\n```\\n\\n我们将其放到任意一个目录中执行node modulepath.js命令，将得到以下的输出结果。\\n\\n```javascript\\n[\\n    \'/home/jackson/research/node_modules\', \\n    \'/home/jackson/node_modules\', \\n    \'/home/node_modules\', \\n    \'/node_modules\'\\n]\\n```\\n\\n可以看出module path的生成规则为：从当前文件目录开始查找node_modules目录；然后依次进入父目录，查找父目录下的node_modules目录；依次迭代，直到根目录下的node_modules目录。\\n\\n除此之外还有一个全局module path，是当前node执行文件的相对目录（`../../lib/node`）。如果在环境变量中设置了HOME目录和NODE_PATH目录的话，整个路径还包含NODE_PATH和HOME目录下的.`node_libraries`与`.node_modules`。其最终值大致如下：\\n\\n```javascript\\n[NODE_PATH，HOME/.node_modules，HOME/.node_libraries，execPath/../../lib/node]\\n```\\n\\n#### 2.require方法中的文件查找策略\\n\\n由于Node.js中存在4类模块（原生模块和3种文件模块），尽管require方法极其简单，但是内部的加载却是十分复杂的，其加载优先级也各自不同。\\n\\n简而言之，如果require绝对路径的文件，查找时不会去遍历每一个node_modules目录，其速度最快。其余流程如下：\\n\\n1. 从module path数组中取出第一个目录作为查找基准。 \\n2. 直接从目录中查找该文件，如果存在，则结束查找。如果不存在，则进行下一条查找。 \\n3. 尝试添加.js、.json、.node后缀后查找，如果存在文件，则结束查找。如果不存在，则进行下一条。 \\n4. 尝试将require的参数作为一个包来进行查找，读取目录下的package.json文件，取得main参数指定的文件。 \\n5. 尝试查找该文件，如果存在，则结束查找。如果不存在，则进行第3条查找。 \\n6. 如果继续失败，则取出module path数组中的下一个目录作为基准查找，循环第1至5个步骤。 \\n7. 如果继续失败，循环第1至6个步骤，直到module path中的最后一个值。 \\n8. 如果仍然失败，则抛出异常。\\n\\n流程图如下：\\n\\n![流程图](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-522-handle.png)\\n\\n### 3.总结\\n\\n整个查找过程十分类似原型链的查找和作用域的查找。所幸Node.js对路径查找实现了缓存机制，否则由于每次判断路径都是同步阻塞式进行，会导致严重的性能消耗\\n\\n","answer":"","biz_type":1,"qid":522,"subject":"","title":"介绍 node 文件查找优先级"},"tech_tag":["Node"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["微医"],"date":"Fri, 19 Jun 2020 16:20:43 GMT","favorite_num":5,"qid":507,"qtype":"short_answer","short_answer":{"analysis":"### 一、Node做接口转发\\n\\n- api削减，可去除后端接口无用的数据\\n- 做缓存\\n- 接口代理，解决跨域问题\\n\\n常见的错误出现在http请求层，所以我们可以利用KOA2 Next()的核心特性来编写5xx和4xx的错误处理，这样至少用户不会看见错误的页面。同时我们可以对 Request等专用请求库进行二次封装，来最小化的降低错误出现的概率，同时一旦出现错误要及时采用 log4js进行日志记录。最后我们也可以使用全局错误监听 uncaughtExcetion进行终极的解决。开发阶段采用PM2进程守护工具，出现错误能够达到0秒热启动。\\n\\n### 一、node服务的稳定性\\n\\n对于稳定性,可以分为 **开发, 测试, 代码部署, 正式上线, 回归测试, hotfix处理阶段**\\n\\n#### 1.开发过程\\n\\n![](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-507-dev.png)\\n\\n#### 2.测试阶段\\n\\n主要分为sql接口测试和接口压力测试\\n\\n1. **sql接口测试** , 这里通过sql的测试用例, 从业务原型抽取测试逻辑, 设置边界值, 重复循环的测试, 当然这里也是测试对应的sql表是否达到上线标准\\n2. **接口压测测试验收** , 主要测的是 ***TPS、QPS和系统吞吐量***, 简单来说就是将测试服务压力提升到100%, 找到瓶颈处, 对于不同环境的接口的吞吐量, 接口压力降级等, 主要使用的jmeter测试工具进行; 设置好线程数, 线程启动时间, 压测时间(可以设置超长时间的测试), 由于本人是做电商的, 所以对于电商的吞吐量达到, 每秒的处理request数在2000个基本就可以了\\n\\n**1）QPS**\\n\\nQueries Per Second意思是“每秒查询率”，是一台服务器每秒能够相应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。\\n**2）TPS**\\n\\nTPS：是TransactionsPerSecond的缩写，也就是事务数/秒。它是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。\\n\\nTps即每秒处理事务数，包括了\\n\\n- 用户请求服务器\\n- 服务器自己的内部处理\\n- 服务器返回给用户\\n\\n这三个过程，每秒能够完成N个这三个过程，TPS也就是N；\\n\\nQPS基本类似于TPS，但是不同的是，对于一个页面的一次访问，形成一个TPS；但一次页面请求，可能产生多次对服务器的请求，服务器对这些请求，就可计入“QPS”之中。\\n\\n例如：访问一个页面会请求服务器3次，一次放，产生一个“TPS”，产生3个“QPS” \\n\\n**3）系统吞吐量**\\n\\n一个系统的吞度量（承压能力）与request对CPU的消耗、外部接口、IO等等紧密关联。单个reqeust 对CPU消耗越高，外部系统接口、IO影响速度越慢，系统吞吐能力越低，反之越高。\\n\\n系统吞吐量几个重要参数：QPS（TPS）、并发数、响应时间\\n\\n- QPS（TPS）：每秒钟request/事务 数量\\n- 并发数： 系统同时处理的request/事务数\\n- 响应时间：  一般取平均响应时间\\n\\n理解了上面三个要素的意义之后，就能推算出它们之间的关系：\\n\\nQPS（TPS）= 并发数/平均响应时间    或者   并发数 = QPS*平均响应时间\\n\\n当我们吞吐量不理想时, 这时需要降低一个请求的响应时间, 就算是毫秒级的处理也会给服务性能带来十分大的正向影响;\\n\\n#### 3.部署阶段\\n\\n- 网络方面网络均衡方面选用Nginx对我们的服务进行反向代理以及负载均衡\\n- 部署方式: 分布式部署不同节点的服务器\\n- 部署容器: 使用docker + k8s搭建node服务运行环境, 在大吞吐量下可做到伸缩扩容\\n- 多node服务器下, 使用中心指挥官, 对node服务快速部署启动进行管理, 可选用zookeeper和携程的Apollo进行node集群管理\\n\\n#### 4.正式上线\\n\\n上线准备主要好日志服务的运行稳定, 因为很多报错信息以及服务复盘资料的来源, 完善的日志服务和日志打点是完善一个服务很好的工具\\n\\n流量调优以及服务器调优\\n\\n#### 5.hotfix\\n\\nhotfix, 是系统出现了问题, 需要紧急处理的一个方案; 下面就是对于master处理的流程, 如果经过了5次修复依然存在bug, 则将出现问题的模块剔除出来, 作为下一次迭代任务的前置任务, 下一次上线\\n\\n![hotfix处理.png](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-507-hotfix.png)\\n\\n在服务监控方面\\n\\n1. 错误日志的监控\\n2. 心跳监控\\n3. 监控预警系统\\n...等等\\n\\n上面只是简单的叙述了node服务稳定运行的一部分基础措施, 还有很多工作需要根据实际情况再去做方案\\n\\n### 二、node平缓降级与重启\\n\\nnode天生就是单线程, 在多线程语言对于服务重启, 以及服务降级, 都可以使用其他线程进行监控, 当主线程的服务发送服务退出命令后, 其他线程就会立即启动进行服务平滑切换和降级, 但是node却因为天生单线程, 所以无法开启多线程去监听服务退出任务\\n\\n然而node本身的cluster模块就专门这方面的任务\\n\\ncluster可以做下面的事情\\n\\n1. 发送重启信号给Master线程\\n2. 可以根据cpu核心数起对应的n个新服务并开始监听服务, 理论上可以无数个服务, 但是, 一般来说还是根据os的核心数去起服务\\n3. master线程可以等待旧服务\\n4. 同时还能杀掉旧服务\\n\\n```js\\n// 一个简单带有cluster自动重启的app.js\\nconst cluster = require(\'cluster\');\\nconst cpuNums = require(\'os\').cpus().length;\\nconst http = require(\'http\');\\n\\nif(cluster.isMaster){ // 是否在主线程\\n  for(var i = 0; i < cpuNums; i++){\\n    cluster.fork(); // 有多少个cpu就分多少个cluster出来\\n    \\n    cluster.on(\'exit\', function(worker, code, signal) {\\n        console.log(`线程id为 ${worker.process.pid} 退出`);\\n    });\\n    cluster.on(\'listening\', function(worker, code, signal) {\\n        console.log(`线程id为 ${worker.process.pid} 开始服务`);\\n    });\\n    cluster.on(\'disconnect\', function(worker, code, signal) {\\n        console.log(`线程id为 ${worker.process.pid} 停止服务`);\\n    });\\n    process.on(\'SIGUSR2\', function () { // 接收kill -SIGUSR2 $pid\\n      // 保存旧 worker 的列表，cluster.workers 是个 map\\n      var oldWorkers = Object.keys(cluster.workers).map(function (idx) {\\n          return cluster.workers[idx];\\n      });\\n      // 重新起服务\\n      cluster.fork();\\n\\n      // 当新服务起起来之后，关闭所有的旧 worker\\n      cluster.once(\'listening\', function (worker) {\\n        oldWorkers.forEach(function (worker) {\\n            // disconnect 会停止接收新请求，等待旧请求结束后再结束进程\\n            worker.disconnect();\\n        });\\n      });\\n    });\\n  }\\n}else{\\n  http.createServer(function(req, res){\\n    res.end(123);\\n  }).listen(8080);\\n\\n  console.log(`你的线程id为 ${process.pid}`);\\n}\\n```\\n\\n上面是一个简易的线程关闭自动重启的一个过程\\n\\n但是工程上面可以使用pm2进行服务切换降级, 以及对服务进行更新;\\n我们还可以接在全局捕错中间件进行 `process.exit()` 事件, 进行发送-SIGUSR2事件, 可以自定义启动参数;\\n\\n这个平缓降级主要的两个点: 一个是当主线程死掉的时候, 正在进来的request和正在出去的response如何切换, 但是这些pm2都帮我们做了, 另外我们在工程还需要对线程进行自定义的捕错, 不然, 会遗漏一些不可预知的错误的","answer":"","biz_type":1,"qid":507,"subject":"","title":"node 接口转发有无做什么优化？node 起服务如何保证稳定性，平缓降级，重启等"},"tech_tag":["Node"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":[],"date":"Fri, 19 Jun 2020 16:20:42 GMT","favorite_num":4,"qid":308,"qtype":"short_answer","short_answer":{"analysis":"#### 上传文件的Content_type\\n\\n使用multipart/form-data\\n\\n#### 如何拿到上传的文件内容\\n\\nhttp模块的 `createServer(request, response)` ,\\n\\n传入请求对象的 request 其实实现了 `ReadableStream` 接口， 这个信息流可以被监听，或者与其它流进行对接。我们可以通过监听 \'data\' 和 \'end\' 事件从而把 数据给取出来。\\n\\n文件的内容不是一次性的传过来，是以流的方式传输\\n\\n获取到上传文件的内容伪代码如下\\n\\n```js\\nconst http = require(\'http\');\\nlet fileData = \'\'\\nhttp.createServer((request, response) => {\\n  request.on(\'error\', (err) => {\\n    console.error(err);\\n  }).on(\'data\', (chunk) => {\\n    fileData += data\\n  }).on(\'end\', () => {\\n    console.log(fileData)\\n  });\\n}).listen(8080)\\n```\\n\\n\\n","answer":"","biz_type":1,"qid":308,"subject":"","title":"上传文件的 Content_Type 什么，node 如何拿到上传的文件内容(不适用第三方插件)？文件内容是一次行传输过去的么"},"tech_tag":["Node"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["阿里"],"date":"Fri, 19 Jun 2020 16:20:42 GMT","favorite_num":4,"qid":334,"qtype":"short_answer","short_answer":{"analysis":"### PM2\\n\\nPM2 是一个带有负载均衡功能的 Node 应用的进程管理器。我们都知道nodejs是单进程执行的，当程序出现错误死掉之后需要能够自动，这时候就需要PM2了。当然进程管理工具有很多，例如forever等等；\\n\\n#### 1.主要特性\\n\\n- 启动多子进程，充分使用CPU\\n- 子进程之间负载均衡\\n- 0秒重启\\n- 界面友好\\n- 提供进程交互（例如：监控）接口\\n\\n#### 2.架构图\\n\\n![架构](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-334-manager.png)\\n\\npm2包括 Satan进程、God Deamon守护进程、进程间的远程调用rpc、cluster等几个概念.pm2中采用God Deamon守护进程，God进程启动后一直运行，它相当于cluster中的Master进程，守护者worker进程的正常运行。\\n\\n#### 3.执行流程\\n\\n![执行流程](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-334-process.jpeg)\\n\\n每次命令行的输入都会执行一次satan程序。如果God进程不在运行，首先需要启动God进程。然后根据指令，satan通过rpc调用God中对应的方法执行相应的逻辑。\\n\\n#### 4.依据什么重启服务\\n\\npm2采用心跳检测查看子进程是否处于活跃状态\\n\\n每隔数秒向子进程发送心跳包，子进程如果不回复，那么调用kill杀死这个进程，然后再重新cluster.fork()一个新的进程，子进程可以监听到错误事件，这时候可以发送消息给主进程，请求杀死自己，并且主进程此时重新调用cluster.fork一个新的子进程\\n\\n#### 5.拥有的能力\\n\\n- **⽇志管理** 两种⽇志，pm2系统⽇志与管理的进程⽇志，默认会把进程的控制台输出记录到⽇志中；\\n- **负载均衡** PM2可以通过创建共享同⼀服务器端⼝的多个⼦进程来扩展您的应⽤程序。这样做还允许以零秒停机时间重新启动应⽤程序。\\n- **终端监控** 可以在终端中监控应⽤程序并检查应⽤程序运⾏状况（CPU使⽤率，使⽤的内存，请求/分钟等）。\\n- **SSH部署** ⾃动部署，避免逐个在所有服务器中进⾏ssh。\\n- **静态服务** ⽀持静态服务器功能\\n- **⽀持开发调试模式** ，⾮后台运⾏，`pm2-dev start <appName>`；\\n\\n#### 6.常用命令\\n\\n启动服务pm2 start <script_file|config_file> [options] 启动指定应⽤\\n\\n- 启动⼀个node程序\\n  - `pm2 start app.js`  启动app.js应⽤\\n- 启动进程并指定应⽤的程序名\\n  - `pm2 start app.js --name 程序名` 启动应⽤并设置name\\n- 添加进程监视\\n  - 监听模式启动，当⽂件发⽣变化，⾃动重启\\n  - `pm2 start app.js --name 程序名 --watch（指定程序名的情况下）`\\n  - `pm2 start app.js --watch （未指定程序名的情况下）`\\n- 列出所有进程\\n  - `pm2 list`\\n  - `pm2 ls`  简写\\n- 从进程列表中删除进程\\n  - `pm2 delete [appname] | id`\\n  - `pm2 delete app` 指定进程名删除\\n  - `pm2 delete 0` 指定进程id删除\\n  - 如果修改了应⽤配置⾏为，需要先删除应⽤，重新启动后⽅才会⽣效，如修改脚本⼊⼝⽂件；\\n- 删除进程列表中所有进程\\n  - `pm2 delete all`（关闭并删除应⽤）\\n- 查看某个进程具体情况\\n  - `pm2 describe app`\\n- 查看进程的资源消耗情况\\n  - `pm2 monit`（ 监控各个应⽤进程cpu和memory使⽤情况）\\n- 重启进程\\n  - `pm2 restart app.js` 同时杀死并重启所有进程，短时间内服务不可⽤,⽣成环境慎⽤\\n  - `pm2 restart all` 重启所有进程\\n  - `pm2 reload app.js` 重新启动所有进程，0秒重启，始终保持⾄少⼀个进程在运⾏　　\\n  - `pm2 gracefulReload all`  以群集模式重新加载所有应⽤程序\\n- 查看进程⽇志\\n  - `pm2 logs [Name]`  根据指定应⽤名查看应⽤⽇志\\n  - `pm2 logs [ID]`  根据指定应⽤ID查看应⽤⽇志\\n  - `pm2 logs all`  查看所有进程的⽇志\\n- 显示应⽤程序详细信息 `pm2 show <appName> [options]` 显示指定应⽤详情\\n  - `pm2 show [Name]` 根据name查看\\n  - `pm2 show [ID]` 根据id查看\\n- 停⽌指定应⽤ `pm2 stop <appName> [options]` 停⽌指定应⽤\\n  - `pm2 stop all`  停⽌所有应⽤\\n  - `pm2 stop [AppName]` 根据应⽤名停⽌指定应⽤\\n  - `pm2 stop [ID]` 根据应⽤id停⽌指定应⽤\\n- `pm2 kill` 杀掉pm2管理的所有进程\\n- 启动静态服务器 `pm2 serve ./dist 8080` 将⽬录dist作为静态服务器根⽬录，端⼝为8080\\n- 集群模式启动\\n  - -i 表示 number-instances 实例数量\\n  - max 表示 PM2将⾃动检测可⽤CPU的数量 可以⾃⼰指定数量\\n  - `pm2 start app.js -i max` 启⽤群集模式（⾃动负载均衡）\\n- `pm2-dev start ...`  开发模式启动，即不启⽤后台运⾏\\n- 设置pm2开机⾃启\\n  - 开启启动设置，此处是CentOS系统，其他系统替换最后⼀个选项（可选项：ubuntu, centos, redhat, gentoo, systemd, darwin, amazon）\\n  - `pm2 startup centos`\\n  - 然后按照提示需要输⼊的命令进⾏输⼊\\n  - 最后保存设置\\n  - `pm2 save`\\n\\n\\n","answer":"","biz_type":1,"qid":334,"subject":"","title":"介绍下 pm2，pm2 依据什么重启服务"},"tech_tag":["Node"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":[],"date":"Fri, 19 Jun 2020 16:20:42 GMT","favorite_num":4,"qid":335,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":335,"subject":"","title":"什么是微服务，微服务跟单体应用的区别是啥，用微服务有啥好处？"},"tech_tag":["Node"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["阿里","宝宝树"],"date":"Fri, 19 Jun 2020 16:20:42 GMT","favorite_num":4,"qid":340,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":340,"subject":"","title":"使用过的 koa2 中间件，中间价的原理是什么"},"tech_tag":["Node"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["阿里"],"date":"Fri, 19 Jun 2020 16:20:42 GMT","favorite_num":5,"qid":341,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":341,"subject":"","title":"koa-body 原理"},"tech_tag":["Node"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["阿里"],"date":"Fri, 19 Jun 2020 16:20:42 GMT","favorite_num":4,"qid":342,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":342,"subject":"","title":"有没有写过中间件，介绍下自己写过的中间件"},"tech_tag":["Node"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["阿里"],"date":"Fri, 19 Jun 2020 16:20:42 GMT","favorite_num":4,"qid":345,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":345,"subject":"","title":"master 挂了的话 pm2 怎么处理"},"tech_tag":["Node"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["阿里"],"date":"Fri, 19 Jun 2020 16:20:42 GMT","favorite_num":4,"qid":346,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":346,"subject":"","title":"Node 如何和 MySQL 进行通信"},"tech_tag":["Node"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["阿里"],"date":"Fri, 19 Jun 2020 16:20:42 GMT","favorite_num":4,"qid":348,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":348,"subject":"","title":"服务端渲染 SSR"},"tech_tag":["Node"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["滴滴"],"date":"Fri, 19 Jun 2020 16:20:42 GMT","favorite_num":4,"qid":397,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":397,"subject":"","title":"koa 中 response.send、response.rounded、response.json 发生了什么事，浏览器为什么能识别到它是一个 json 结构或是 html"},"tech_tag":["Node"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["滴滴"],"date":"Fri, 19 Jun 2020 16:20:42 GMT","favorite_num":4,"qid":398,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":398,"subject":"","title":"koa-bodyparser 如何解析 request"},"tech_tag":["Node"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["挖财"],"date":"Fri, 19 Jun 2020 16:20:42 GMT","favorite_num":4,"qid":438,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":438,"subject":"","title":"pm2 怎么做进程管理，进程挂掉怎么处理"},"tech_tag":["Node"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["挖财"],"date":"Fri, 19 Jun 2020 16:20:42 GMT","favorite_num":4,"qid":439,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":439,"subject":"","title":"不用 pm2 怎么做进程管理"},"tech_tag":["Node"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["沪江"],"date":"Fri, 19 Jun 2020 16:20:42 GMT","favorite_num":4,"qid":440,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":440,"subject":"","title":"jsonp 方案需要服务端怎么配合"},"tech_tag":["Node"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["兑吧"],"date":"Fri, 19 Jun 2020 16:20:42 GMT","favorite_num":4,"qid":477,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":477,"subject":"","title":"prototype 和**proto**区别"},"tech_tag":["Node"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["道一云"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":4,"qid":248,"qtype":"short_answer","short_answer":{"analysis":"### 一、Node\\n\\nNode.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时，Node.js 使用一个事件驱动、非阻塞 I/O 模型，使其轻量、高效，让并发编程更简单，适用于以网络编程为主的 I/O 密集型应用。\\n\\nNode.js内部结构图\\n\\n![Node内部结构图](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-248-clipboard.png)\\n\\n自下而上，最底层是 Node.js 依赖的各种库，Chrome V8解释并执行 JavaScript 代码。Libuv 提供的事件循环、线程池管理、异步网络 I/O、文件系统 I/O 等能力，负责 I/O 任务的分布和执行。c-ares（DNS解析）、crypto、http、zlib（压缩）等，提供了对系统底层功能的访问，如网络、加密、压缩等。\\n\\n中间是桥接层，连接 JavaScript 和 C/C++ 的桥梁。Bindings 把底层 Node.js 核心依赖库暴露的 C/C++ 库接口转接给 JavaScript 环境。Addons 用于 C/C++ 扩展。\\n最上层是应用层，可以调用 Node.js 的各种API。\\n\\n![system](http://img-static.yidengxuetang.com/wxapp/issue-img/qid-248-event.png)\\n\\n### 二、适用场景\\n\\n**1）RESTful API**\\n\\n这是NodeJS最理想的应用场景，可以处理数万条连接，本身没有太多的逻辑，只需要请求API，组织数据进行返回即可。它本质上只是从某个数据库中查找一些值并将它们组成一个响应。由于响应是少量文本，入站请求也是少量的文本，因此流量不高，一台机器甚至也可以处理最繁忙的公司的API需求。\\n\\n**2）统一Web应用的UI层**\\n\\n目前MVC的架构，在某种意义上来说，Web开发有两个UI层，一个是在浏览器里面我们最终看到的，另一个在server端，负责生成和拼接页面。\\n不讨论这种架构是好是坏，但是有另外一种实践，面向服务的架构，更好的做前后端的依赖分离。如果所有的关键业务逻辑都封装成REST调用，就意味着在上层只需要考虑如何用这些REST接口构建具体的应用。那些后端程序员们根本不操心具体数据是如何从一个页面传递到另一个页面的，他们也不用管用户数据更新是通过Ajax异步获取的还是通过刷新页面。\\n\\n**3）大量Ajax请求的应用**\\n\\n例如个性化应用，每个用户看到的页面都不一样，缓存失效，需要在页面加载的时候发起Ajax请求，NodeJS能响应大量的并发请求。　　\\n\\n总而言之，**NodeJS适合运用在高并发、I/O密集、少量业务逻辑的场景**\\n\\n例如：\\n\\n- 用户表单收集\\n- 考试系统\\n- 聊天室\\n- web论坛\\n- 图文直播\\n\\n其实NodeJS能实现几乎一切的应用，NodeJS适合运用在高并发、I/O密集、少量业务逻辑的场景，我们考虑的点只是适不适合用它来做。\\n\\n### 三、优缺点\\n\\n#### 优点\\n\\n1. 是 JavaScript 运行环境，让JavaScript 也可以开发后端程序\\n2. 事件驱动。通过单线程维护事件循环队列，没有多线程的资源占用和上下文切换，高效可扩展性强，能充分利用系统资源。\\n3. 非阻塞 I/O，能处理高并发（最重要的优点）\\n4. 单线程（主线程为单线程）\\n5. 可伸缩\\n6. 跨平台，可以应用在 PC Web端、PC客户端 nw.js/electron 、移动端 cordova、HTML5、react-native、weex，硬件 ruff.io 等。\\n7. npm 上的各种包模块\\n8. 配合前端做接口转发 合并请求 削减JSON大小 可以独立控制路由（做SSR同构）让前端更有主动性 可以独立部署上线\\n\\n#### 缺点\\n\\n**1）不适合 CPU 密集型应用**\\n\\nCPU密集型应用给Node带来的挑战主要是：由于JavaScript单线程的原因，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I/O无法发起；\\n\\n解决方案:分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞I/O调用的发起；\\n\\n**2）不适合大内存的应用**\\n\\nV8 的内存管理机制限制（64位约1.4G，32位约0.7G）\\n\\n**3）不适合大量同步的应用**\\n\\n**4）只支持单核CPU，不能充分利用CPU**\\n\\n**5）可靠性低**\\n\\n一旦代码某个环节崩溃，整个系统都崩溃\\n\\n原因：\\n\\n- 单进程，单线程\\n\\n解决方案：\\n\\n- Nnigx反向代理，负载均衡，开多个进程，绑定多个端口；\\n- 开多个进程监听同一个端口，使用cluster模块；\\n\\n**6）开源组件库质量参差不齐，更新快，向下不兼容**\\n\\n**7）Debug不方便，错误没有stack trace**","answer":"","biz_type":1,"qid":248,"subject":"","title":"Node 的适用场景以及优缺点是什么？"},"tech_tag":["Node"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["高德"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":4,"qid":201,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":201,"subject":"","title":"手动实现一个 Promisify 函数"},"tech_tag":["Node"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["自如","菜鸟网络"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":4,"qid":242,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":242,"subject":"","title":"介绍一下 node 核心模块（主要是 stream）"},"tech_tag":["Node"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["自如"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":4,"qid":247,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":247,"subject":"","title":"node 如何做错误监控（运行时与其他）如何生成日志，日志等级"},"tech_tag":["Node"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["菜鸟网络","海风教育"],"date":"Fri, 19 Jun 2020 16:20:41 GMT","favorite_num":4,"qid":278,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":278,"subject":"","title":"koa2 和 express 区别"},"tech_tag":["Node"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["快手"],"date":"Fri, 19 Jun 2020 16:20:40 GMT","favorite_num":4,"qid":70,"qtype":"short_answer","short_answer":{"analysis":"#### glob库\\n\\n**1）简介**\\n\\n程序需要对磁盘文件进行管理，就需要读取磁盘上的文件列表，然后可能会需要判断文件夹或文件名，还可能需要递归扫描子目录。库Glob专门用来扫描磁盘文件，并返回我们需要的文件类型。\\n\\nglob 工具基于 javascript . 它使用了 minimatch 库来进行匹配。\\n\\nnode 的 glob 模块允许你使用 * 等符号, 来写一个 glob 规则,像在 shell 里一样,获取匹配对应规则的文件.\\n\\n```js\\nconst glob = require(\\"glob\\")\\nglob(\\"**/*.js\\", function (error, files) {\\n  // files 就是我们得到的文件的列表\\n})\\n```\\n\\n上述代码中，我们会递归查找当前目录下的所有.js 文件，因为我们使用了 **/*.js 通配符做查找条件。\\n\\n**2）glob 支持的通配符模式**\\n\\nglob 支持强大的匹配规则，但是要注意glob的匹配规则并不是正则表达式，详细支持如下：\\n\\n- `*` 匹配0到多个字符\\n- `?` 匹配一个字符\\n- `[...]` 匹配一个字符列表，类似正则表达式的字符列表\\n- `!(pattern|pattern|pattern)` 反向匹配括号内的模式\\n- `?(pattern|pattern|pattern)` 匹配0或1个括号内的模式\\n- `+(pattern|pattern|pattern)` 匹配至少1个括号内的模式\\n- `*(pattern|pattern|pattern)` 匹配0到多个括号内的模式\\n- `@(pattern|pat*|pat?erN)` 精确匹配括号内的模式\\n- `**` 匹配0到多个子目录，递归匹配子目录\\n\\n**3）其它特性**\\n\\n除下上文中的异步接口，glob还支持 glob.sync() 同步接口，另外，glob还支持大量的参数选项，比如cwd,root 等等\\n\\n\\n#### Node进行文件处理的几种方式\\n\\n在使用node开发过程中很多时候会遇到对文件系统做各种处理操纵\\n\\n**1）文件处理开发中常用的内置模块**\\n\\n- path：处理文件路径\\n- fs：操作文件系统\\n- child_process：新建子进程\\n- process: 进程\\n\\n**2）比较好用的第三方模块**\\n\\n- glob: 使用shell命令的模式匹配文件\\n- trash: 文件放到回收站\\n\\n\\n\\n\\n\\n\\n","answer":"","biz_type":1,"qid":70,"subject":"","title":"是否了解 glob，glob 是如何处理文件的，业界是否还有其它解决方案"},"tech_tag":["Node"],"uid":0,"uname":""},{"audit_flag":0,"corp_tag":["快手"],"date":"Fri, 19 Jun 2020 16:20:40 GMT","favorite_num":4,"qid":69,"qtype":"short_answer","short_answer":{"analysis":"","answer":"","biz_type":1,"qid":69,"subject":"","title":"是否熟悉 Node，主要做过哪些业务，平时用过什么包？"},"tech_tag":["Node"],"uid":0,"uname":""}],"page":1,"pages":1,"uid":4510},"status":0}')}}]);