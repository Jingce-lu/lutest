<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>浏览器 | Lu notes</title>
    <meta name="generator" content="VuePress 1.5.2">
    <link rel=" " href=" ">
    <meta name="description" content=" ">
    <link rel="preload" href="/lutest/assets/css/0.styles.cce74b5b.css" as="style"><link rel="preload" href="/lutest/assets/js/app.f0f4e5ba.js" as="script"><link rel="preload" href="/lutest/assets/js/2.9740266b.js" as="script"><link rel="preload" href="/lutest/assets/js/3.fe54688f.js" as="script"><link rel="preload" href="/lutest/assets/js/37.d850614d.js" as="script"><link rel="prefetch" href="/lutest/assets/js/10.c0084733.js"><link rel="prefetch" href="/lutest/assets/js/11.ff336b65.js"><link rel="prefetch" href="/lutest/assets/js/12.07393465.js"><link rel="prefetch" href="/lutest/assets/js/13.1b627efa.js"><link rel="prefetch" href="/lutest/assets/js/14.a5bc101a.js"><link rel="prefetch" href="/lutest/assets/js/15.ef66f59a.js"><link rel="prefetch" href="/lutest/assets/js/16.a55a09ef.js"><link rel="prefetch" href="/lutest/assets/js/17.6775709b.js"><link rel="prefetch" href="/lutest/assets/js/18.0a78dd83.js"><link rel="prefetch" href="/lutest/assets/js/19.8c2ff2a8.js"><link rel="prefetch" href="/lutest/assets/js/20.9592ba28.js"><link rel="prefetch" href="/lutest/assets/js/21.28692ff4.js"><link rel="prefetch" href="/lutest/assets/js/22.fb4b712d.js"><link rel="prefetch" href="/lutest/assets/js/23.0b076270.js"><link rel="prefetch" href="/lutest/assets/js/24.6c2493c5.js"><link rel="prefetch" href="/lutest/assets/js/25.4182f127.js"><link rel="prefetch" href="/lutest/assets/js/26.78709dde.js"><link rel="prefetch" href="/lutest/assets/js/27.ab0e00d0.js"><link rel="prefetch" href="/lutest/assets/js/28.f90969f0.js"><link rel="prefetch" href="/lutest/assets/js/29.039eff68.js"><link rel="prefetch" href="/lutest/assets/js/30.5486c133.js"><link rel="prefetch" href="/lutest/assets/js/31.25b74c31.js"><link rel="prefetch" href="/lutest/assets/js/32.46b3916a.js"><link rel="prefetch" href="/lutest/assets/js/33.6aabb721.js"><link rel="prefetch" href="/lutest/assets/js/34.2ec3408c.js"><link rel="prefetch" href="/lutest/assets/js/35.4e2ba109.js"><link rel="prefetch" href="/lutest/assets/js/36.05c8ca29.js"><link rel="prefetch" href="/lutest/assets/js/38.fdab2a24.js"><link rel="prefetch" href="/lutest/assets/js/39.8170e822.js"><link rel="prefetch" href="/lutest/assets/js/4.4dc286c5.js"><link rel="prefetch" href="/lutest/assets/js/40.270097a2.js"><link rel="prefetch" href="/lutest/assets/js/41.76dbc777.js"><link rel="prefetch" href="/lutest/assets/js/42.8d4531b3.js"><link rel="prefetch" href="/lutest/assets/js/43.fdce52bd.js"><link rel="prefetch" href="/lutest/assets/js/44.ecad952b.js"><link rel="prefetch" href="/lutest/assets/js/45.ce594d99.js"><link rel="prefetch" href="/lutest/assets/js/46.a62e422c.js"><link rel="prefetch" href="/lutest/assets/js/47.61d9aac4.js"><link rel="prefetch" href="/lutest/assets/js/48.c893d435.js"><link rel="prefetch" href="/lutest/assets/js/49.dfff70fb.js"><link rel="prefetch" href="/lutest/assets/js/5.c729589a.js"><link rel="prefetch" href="/lutest/assets/js/50.473844db.js"><link rel="prefetch" href="/lutest/assets/js/6.166d06bb.js"><link rel="prefetch" href="/lutest/assets/js/7.34421d12.js"><link rel="prefetch" href="/lutest/assets/js/8.ea335d0b.js"><link rel="prefetch" href="/lutest/assets/js/9.6d40df77.js">
    <link rel="stylesheet" href="/lutest/assets/css/0.styles.cce74b5b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/lutest/" class="home-link router-link-active"><!----> <span class="site-name">Lu notes</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/lutest/" class="nav-link">首页</a></div><div class="nav-item"><a href="/lutest/prepare/" class="nav-link router-link-active">Prepare</a></div><div class="nav-item"><a href="/lutest/js/" class="nav-link">Js</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/lutest/" class="nav-link">首页</a></div><div class="nav-item"><a href="/lutest/prepare/" class="nav-link router-link-active">Prepare</a></div><div class="nav-item"><a href="/lutest/js/" class="nav-link">Js</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><a href="/lutest/prepare/Collection/" class="sidebar-heading clickable"><span>Collection</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/lutest/prepare/Engineering/" class="sidebar-heading clickable"><span>Engineering</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/lutest/prepare/Mobile/" class="sidebar-heading clickable"><span>Mobile</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/lutest/prepare/Require/" class="sidebar-heading clickable router-link-active open"><span>Require</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/lutest/prepare/Require/01-CSS.html" class="sidebar-link">01-CSS</a></li><li><a href="/lutest/prepare/Require/02-Html.html" class="sidebar-link">02-Html</a></li><li><a href="/lutest/prepare/Require/03-Js.html" class="sidebar-link">03-Js</a></li><li><a href="/lutest/prepare/Require/04-ES6.html" class="sidebar-link">04-ES6</a></li><li><a href="/lutest/prepare/Require/05-浏览器.html" class="active sidebar-link">05-浏览器</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/lutest/prepare/Require/05-浏览器.html#_1-在浏览器中输入-url-到页面显示出来的过程发生了什么？" class="sidebar-link">1. 在浏览器中输入 url 到页面显示出来的过程发生了什么？</a></li><li class="sidebar-sub-header"><a href="/lutest/prepare/Require/05-浏览器.html#_2-浏览器的渲染机制" class="sidebar-link">2. 浏览器的渲染机制</a></li><li class="sidebar-sub-header"><a href="/lutest/prepare/Require/05-浏览器.html#_3-浏览器允许的并发请求资源数" class="sidebar-link">3. 浏览器允许的并发请求资源数</a></li><li class="sidebar-sub-header"><a href="/lutest/prepare/Require/05-浏览器.html#_4-浏览器的机制你了解多少" class="sidebar-link">4. 浏览器的机制你了解多少</a></li><li class="sidebar-sub-header"><a href="/lutest/prepare/Require/05-浏览器.html#_5-浏览器内核" class="sidebar-link">5. 浏览器内核</a></li><li class="sidebar-sub-header"><a href="/lutest/prepare/Require/05-浏览器.html#_6-浏览器内核中线程之间的关系" class="sidebar-link">6. 浏览器内核中线程之间的关系</a></li><li class="sidebar-sub-header"><a href="/lutest/prepare/Require/05-浏览器.html#_7-webwork" class="sidebar-link">7. webwork</a></li><li class="sidebar-sub-header"><a href="/lutest/prepare/Require/05-浏览器.html#_8-load-和-domcontentloaded-区别" class="sidebar-link">8. Load 和 DOMContentLoaded 区别</a></li><li class="sidebar-sub-header"><a href="/lutest/prepare/Require/05-浏览器.html#_9-重绘（repaint）和回流（reflow）" class="sidebar-link">9. 重绘（Repaint）和回流（Reflow）</a></li><li class="sidebar-sub-header"><a href="/lutest/prepare/Require/05-浏览器.html#_10-减少重绘和回流" class="sidebar-link">10. 减少重绘和回流</a></li><li class="sidebar-sub-header"><a href="/lutest/prepare/Require/05-浏览器.html#_11-事件触发三阶段" class="sidebar-link">11. 事件触发三阶段</a></li><li class="sidebar-sub-header"><a href="/lutest/prepare/Require/05-浏览器.html#_12-注册事件" class="sidebar-link">12. 注册事件</a></li><li class="sidebar-sub-header"><a href="/lutest/prepare/Require/05-浏览器.html#_13-事件代理" class="sidebar-link">13. 事件代理</a></li><li class="sidebar-sub-header"><a href="/lutest/prepare/Require/05-浏览器.html#_14-预加载、预渲染" class="sidebar-link">14. 预加载、预渲染</a></li><li class="sidebar-sub-header"><a href="/lutest/prepare/Require/05-浏览器.html#_15-介绍下-http1-0、1-1、2-0-协议的区别？" class="sidebar-link">15. 介绍下 http1.0、1.1、2.0 协议的区别？</a></li><li class="sidebar-sub-header"><a href="/lutest/prepare/Require/05-浏览器.html#_16-简单讲解一下-http2-的多路复用" class="sidebar-link">16. 简单讲解一下 http2 的多路复用</a></li><li class="sidebar-sub-header"><a href="/lutest/prepare/Require/05-浏览器.html#_17-http-状态码" class="sidebar-link">17. HTTP 状态码</a></li><li class="sidebar-sub-header"><a href="/lutest/prepare/Require/05-浏览器.html#_18-http-相关" class="sidebar-link">18 HTTP 相关</a></li><li class="sidebar-sub-header"><a href="/lutest/prepare/Require/05-浏览器.html#_19-tcp-三次握手和四次挥手" class="sidebar-link">19. TCP 三次握手和四次挥手</a></li><li class="sidebar-sub-header"><a href="/lutest/prepare/Require/05-浏览器.html#_20-tcp-怎么保证可靠性" class="sidebar-link">20. tcp 怎么保证可靠性</a></li><li class="sidebar-sub-header"><a href="/lutest/prepare/Require/05-浏览器.html#_21-tcp-和-udp-区别" class="sidebar-link">21. tcp 和 udp 区别</a></li><li class="sidebar-sub-header"><a href="/lutest/prepare/Require/05-浏览器.html#_22-https-的传输过程" class="sidebar-link">22. https 的传输过程</a></li><li class="sidebar-sub-header"><a href="/lutest/prepare/Require/05-浏览器.html#_23-http-连接请求与线程" class="sidebar-link">23. HTTP 连接请求与线程</a></li><li class="sidebar-sub-header"><a href="/lutest/prepare/Require/05-浏览器.html#_24-介绍下-https-中间人攻击" class="sidebar-link">24. 介绍下 HTTPS 中间人攻击</a></li><li class="sidebar-sub-header"><a href="/lutest/prepare/Require/05-浏览器.html#_25-跨域时如何处理-cookie" class="sidebar-link">25. 跨域时如何处理 cookie</a></li><li class="sidebar-sub-header"><a href="/lutest/prepare/Require/05-浏览器.html#_26-垃圾回收机制" class="sidebar-link">26. 垃圾回收机制</a></li><li class="sidebar-sub-header"><a href="/lutest/prepare/Require/05-浏览器.html#_27-开发过程中遇到的内存泄露情况" class="sidebar-link">27. 开发过程中遇到的内存泄露情况</a></li><li class="sidebar-sub-header"><a href="/lutest/prepare/Require/05-浏览器.html#_28-js-事件轮询、微任务和宏任务" class="sidebar-link">28. js 事件轮询、微任务和宏任务</a></li><li class="sidebar-sub-header"><a href="/lutest/prepare/Require/05-浏览器.html#_29-微信网页版登录机制" class="sidebar-link">29. 微信网页版登录机制</a></li><li class="sidebar-sub-header"><a href="/lutest/prepare/Require/05-浏览器.html#_30-unicode-utf8-utf16-有什么区别" class="sidebar-link">30. unicode utf8 utf16 有什么区别</a></li><li class="sidebar-sub-header"><a href="/lutest/prepare/Require/05-浏览器.html#_31-缓存以键值形式存在浏览器，键是什么，值是什么" class="sidebar-link">31. 缓存以键值形式存在浏览器，键是什么，值是什么</a></li><li class="sidebar-sub-header"><a href="/lutest/prepare/Require/05-浏览器.html#_32-讲解一下-https-对称加密和非对称加密" class="sidebar-link">32. 讲解一下 https 对称加密和非对称加密</a></li><li class="sidebar-sub-header"><a href="/lutest/prepare/Require/05-浏览器.html#_33-如何优化网页上需要展示的超大图片，从请求和性能来解释" class="sidebar-link">33. 如何优化网页上需要展示的超大图片，从请求和性能来解释</a></li><li class="sidebar-sub-header"><a href="/lutest/prepare/Require/05-浏览器.html#_34-实现-adblock-的策略" class="sidebar-link">34. 实现 Adblock 的策略</a></li><li class="sidebar-sub-header"><a href="/lutest/prepare/Require/05-浏览器.html#_35-dom0、dom2、dom3-事件" class="sidebar-link">35. dom0、dom2、dom3 事件</a></li><li class="sidebar-sub-header"><a href="/lutest/prepare/Require/05-浏览器.html#_36-如何刷新浏览器的应用缓存？" class="sidebar-link">36. 如何刷新浏览器的应用缓存？</a></li><li class="sidebar-sub-header"><a href="/lutest/prepare/Require/05-浏览器.html#_37-浏览器缓存" class="sidebar-link">37. 浏览器缓存</a></li><li class="sidebar-sub-header"><a href="/lutest/prepare/Require/05-浏览器.html#_38-cdn-缓存" class="sidebar-link">38. CDN 缓存</a></li><li class="sidebar-sub-header"><a href="/lutest/prepare/Require/05-浏览器.html#_39-本地存储的生命周期是什么？" class="sidebar-link">39. 本地存储的生命周期是什么？</a></li><li class="sidebar-sub-header"><a href="/lutest/prepare/Require/05-浏览器.html#_40-如何防止-cookie-被盗用？" class="sidebar-link">40. 如何防止 cookie 被盗用？</a></li><li class="sidebar-sub-header"><a href="/lutest/prepare/Require/05-浏览器.html#_41-举例说明什么是-decodeuri-和-encodeuri-是什么？" class="sidebar-link">41. 举例说明什么是 decodeURI()和 encodeURI()是什么？</a></li><li class="sidebar-sub-header"><a href="/lutest/prepare/Require/05-浏览器.html#_42-请说说-escape、encodeuri、decodeuri、encodeuricomponent-和-decodeuricomponent-的区别？" class="sidebar-link">42. 请说说 escape、encodeURI、decodeURI、encodeURIComponent 和 decodeURIComponent 的区别？</a></li><li class="sidebar-sub-header"><a href="/lutest/prepare/Require/05-浏览器.html#_43-如何实现文件拖动上传？" class="sidebar-link">43. 如何实现文件拖动上传？</a></li><li class="sidebar-sub-header"><a href="/lutest/prepare/Require/05-浏览器.html#_44-通过-useragent-是否包含-micromessenger-来判断是否在微信内置浏览器打开网页" class="sidebar-link">44. 通过 userAgent 是否包含 MicroMessenger 来判断是否在微信内置浏览器打开网页</a></li><li class="sidebar-sub-header"><a href="/lutest/prepare/Require/05-浏览器.html#_45-ajax-请求中-get-和-post-方式有什么区别呢？分别在哪些场景下使用？" class="sidebar-link">45. Ajax 请求中 get 和 post 方式有什么区别呢？分别在哪些场景下使用？</a></li><li class="sidebar-sub-header"><a href="/lutest/prepare/Require/05-浏览器.html#_46-get-和-post-区别" class="sidebar-link">46. get 和 post 区别</a></li><li class="sidebar-sub-header"><a href="/lutest/prepare/Require/05-浏览器.html#_47-简单请求和复杂请求的区别" class="sidebar-link">47. 简单请求和复杂请求的区别</a></li><li class="sidebar-sub-header"><a href="/lutest/prepare/Require/05-浏览器.html#_48-js-的异步加载" class="sidebar-link">48. js 的异步加载</a></li><li class="sidebar-sub-header"><a href="/lutest/prepare/Require/05-浏览器.html#_49-localstorage-与-sessionstorage-与-cookie-的区别总结" class="sidebar-link">49. localStorage 与 sessionStorage 与 cookie 的区别总结</a></li><li class="sidebar-sub-header"><a href="/lutest/prepare/Require/05-浏览器.html#_50-axios、fetch-的区别" class="sidebar-link">50. axios、fetch 的区别</a></li></ul></li><li><a href="/lutest/prepare/Require/06-服务端与网络.html" class="sidebar-link">06-服务端与网络</a></li><li><a href="/lutest/prepare/Require/07-Vue.html" class="sidebar-link">07-Vue</a></li><li><a href="/lutest/prepare/Require/08-React.html" class="sidebar-link">08-React</a></li><li><a href="/lutest/prepare/Require/09-webpack.html" class="sidebar-link">09-webpack</a></li><li><a href="/lutest/prepare/Require/10-性能优化.html" class="sidebar-link">10-性能优化</a></li><li><a href="/lutest/prepare/Require/11-算法.html" class="sidebar-link">11-算法</a></li><li><a href="/lutest/prepare/Require/12-常用八种继承方案.html" class="sidebar-link">12-常用八种继承方案</a></li><li><a href="/lutest/prepare/Require/13-开发中遇到的坑.html" class="sidebar-link">13-开发中遇到的坑</a></li><li><a href="/lutest/prepare/Require/14-React开发项目过程遇到的问题.html" class="sidebar-link">14-React开发项目过程遇到的问题</a></li><li><a href="/lutest/prepare/Require/15-js基础.html" class="sidebar-link">15-js基础</a></li><li><a href="/lutest/prepare/Require/16-兼容.html" class="sidebar-link">16-兼容</a></li><li><a href="/lutest/prepare/Require/17-js-questions.html" class="sidebar-link">17-js-questions</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="浏览器"><a href="#浏览器" class="header-anchor">#</a> 浏览器</h1> <p></p><div class="table-of-contents"><ul><li><a href="#_1-在浏览器中输入-url-到页面显示出来的过程发生了什么？">1. 在浏览器中输入 url 到页面显示出来的过程发生了什么？</a></li><li><a href="#_2-浏览器的渲染机制">2. 浏览器的渲染机制</a></li><li><a href="#_3-浏览器允许的并发请求资源数">3. 浏览器允许的并发请求资源数</a></li><li><a href="#_4-浏览器的机制你了解多少">4. 浏览器的机制你了解多少</a></li><li><a href="#_5-浏览器内核">5. 浏览器内核</a></li><li><a href="#_6-浏览器内核中线程之间的关系">6. 浏览器内核中线程之间的关系</a></li><li><a href="#_7-webwork">7. webwork</a></li><li><a href="#_8-load-和-domcontentloaded-区别">8. Load 和 DOMContentLoaded 区别</a></li><li><a href="#_9-重绘（repaint）和回流（reflow）">9. 重绘（Repaint）和回流（Reflow）</a></li><li><a href="#_10-减少重绘和回流">10. 减少重绘和回流</a></li><li><a href="#_11-事件触发三阶段">11. 事件触发三阶段</a></li><li><a href="#_12-注册事件">12. 注册事件</a></li><li><a href="#_13-事件代理">13. 事件代理</a></li><li><a href="#_14-预加载、预渲染">14. 预加载、预渲染</a><ul><li><a href="#预加载">预加载</a></li><li><a href="#预渲染">预渲染</a></li></ul></li><li><a href="#_15-介绍下-http1-0、1-1、2-0-协议的区别？">15. 介绍下 http1.0、1.1、2.0 协议的区别？</a><ul><li><a href="#http-0-9">HTTP/0.9</a></li><li><a href="#http-1-0">HTTP/1.0</a></li><li><a href="#http-1-1">HTTP/1.1</a></li><li><a href="#http-2">HTTP/2</a></li><li><a href="#帧、消息、流和-tcp-连接">帧、消息、流和 TCP 连接</a></li><li><a href="#hpack-算法">HPACK 算法</a></li><li><a href="#服务器推送">服务器推送</a></li></ul></li><li><a href="#_16-简单讲解一下-http2-的多路复用">16. 简单讲解一下 http2 的多路复用</a></li><li><a href="#_17-http-状态码">17. HTTP 状态码</a></li><li><a href="#_18-http-相关">18 HTTP 相关</a></li><li><a href="#_19-tcp-三次握手和四次挥手">19. TCP 三次握手和四次挥手</a></li><li><a href="#_20-tcp-怎么保证可靠性">20. tcp 怎么保证可靠性</a></li><li><a href="#_21-tcp-和-udp-区别">21. tcp 和 udp 区别</a></li><li><a href="#_22-https-的传输过程">22. https 的传输过程</a></li><li><a href="#_23-http-连接请求与线程">23. HTTP 连接请求与线程</a></li><li><a href="#_24-介绍下-https-中间人攻击">24. 介绍下 HTTPS 中间人攻击</a></li><li><a href="#_25-跨域时如何处理-cookie">25. 跨域时如何处理 cookie</a></li><li><a href="#_26-垃圾回收机制">26. 垃圾回收机制</a></li><li><a href="#_27-开发过程中遇到的内存泄露情况">27. 开发过程中遇到的内存泄露情况</a><ul><li><a href="#定义">定义</a></li><li><a href="#内存泄露的几种情况">内存泄露的几种情况:</a></li></ul></li><li><a href="#_28-js-事件轮询、微任务和宏任务">28. js 事件轮询、微任务和宏任务</a></li><li><a href="#_29-微信网页版登录机制">29. 微信网页版登录机制</a></li><li><a href="#_30-unicode-utf8-utf16-有什么区别">30. unicode utf8 utf16 有什么区别</a></li><li><a href="#_31-缓存以键值形式存在浏览器，键是什么，值是什么">31. 缓存以键值形式存在浏览器，键是什么，值是什么</a></li><li><a href="#_32-讲解一下-https-对称加密和非对称加密">32. 讲解一下 https 对称加密和非对称加密</a></li><li><a href="#_33-如何优化网页上需要展示的超大图片，从请求和性能来解释">33. 如何优化网页上需要展示的超大图片，从请求和性能来解释</a></li><li><a href="#_34-实现-adblock-的策略">34. 实现 Adblock 的策略</a></li><li><a href="#_35-dom0、dom2、dom3-事件">35. dom0、dom2、dom3 事件</a><ul><li><a href="#_0-级-dom-分为-2-个：">0 级 DOM 分为 2 个：</a></li><li><a href="#_2-级-dom">2 级 DOM</a></li><li><a href="#dom3">DOM3</a></li></ul></li><li><a href="#_36-如何刷新浏览器的应用缓存？">36. 如何刷新浏览器的应用缓存？</a></li><li><a href="#_37-浏览器缓存">37. 浏览器缓存</a><ul><li><a href="#强缓存">强缓存</a></li><li><a href="#协商缓存">协商缓存</a></li></ul></li><li><a href="#_38-cdn-缓存">38. CDN 缓存</a><ul><li><a href="#cdn">CDN</a></li><li><a href="#cdn-缓存策略">CDN 缓存策略</a></li><li><a href="#cdn-缓存的不足">CDN 缓存的不足</a></li></ul></li><li><a href="#_39-本地存储的生命周期是什么？">39. 本地存储的生命周期是什么？</a></li><li><a href="#_40-如何防止-cookie-被盗用？">40. 如何防止 cookie 被盗用？</a></li><li><a href="#_41-举例说明什么是-decodeuri-和-encodeuri-是什么？">41. 举例说明什么是 decodeURI()和 encodeURI()是什么？</a></li><li><a href="#_42-请说说-escape、encodeuri、decodeuri、encodeuricomponent-和-decodeuricomponent-的区别？">42. 请说说 escape、encodeURI、decodeURI、encodeURIComponent 和 decodeURIComponent 的区别？</a></li><li><a href="#_43-如何实现文件拖动上传？">43. 如何实现文件拖动上传？</a></li><li><a href="#_44-通过-useragent-是否包含-micromessenger-来判断是否在微信内置浏览器打开网页">44. 通过 userAgent 是否包含 MicroMessenger 来判断是否在微信内置浏览器打开网页</a></li><li><a href="#_45-ajax-请求中-get-和-post-方式有什么区别呢？分别在哪些场景下使用？">45. Ajax 请求中 get 和 post 方式有什么区别呢？分别在哪些场景下使用？</a></li><li><a href="#_46-get-和-post-区别">46. get 和 post 区别</a></li><li><a href="#_47-简单请求和复杂请求的区别">47. 简单请求和复杂请求的区别</a></li><li><a href="#_48-js-的异步加载">48. js 的异步加载</a></li><li><a href="#_49-localstorage-与-sessionstorage-与-cookie-的区别总结">49. localStorage 与 sessionStorage 与 cookie 的区别总结</a></li><li><a href="#_50-axios、fetch-的区别">50. axios、fetch 的区别</a><ul><li><a href="#axios">axios</a></li><li><a href="#fetch">fetch</a></li></ul></li></ul></div><p></p> <h2 id="_1-在浏览器中输入-url-到页面显示出来的过程发生了什么？"><a href="#_1-在浏览器中输入-url-到页面显示出来的过程发生了什么？" class="header-anchor">#</a> 1. 在浏览器中输入 url 到页面显示出来的过程发生了什么？</h2> <p>主要过程是：<br>
浏览器解析 -&gt; 查询缓存 -&gt; dns 查询 -&gt; 建立链接 -&gt; 服务器处理请求 -&gt; 服务器发送响应 -&gt; 客户端收到页面 -&gt; 解析 HTML -&gt; 构建渲染树 -&gt; 开始显示内容(白屏时间) -&gt; 首屏内容加载完成(首屏时间) -&gt; 用户可交户(DOMContentLoaded) -&gt; 加载完成(load)</p> <p><strong>大致可以分为如下 8 步</strong></p> <ol><li>输入网址，浏览器解析构建请求</li> <li>查询缓存<br>
检查强缓存，命中则直接使用，否则检查协商缓存</li> <li>DNS 解析<br>
域名与 IP 地址映射</li> <li>建立 tcp 连接
<ul><li>chrome 限制同一域名下最多 6 个 tcp 连接</li> <li>通过三次握手建立连接, <strong>三次握手过程</strong>:
<ol><li>客户端向服务器发送连接请求，传递一个数据包 syn，此时客户端处于 SYN_SEND 状态</li> <li>服务器接收 syn 报文后，会以自己的 syn 报文作为应答，传递数据包 syn+ack,此时服务器处于 SYN-REVD 状态</li> <li>客户端接收 syn 报文后，发送一个数据包 ack，此时客户端处于 ESTABLISHED 状态，双方已建立连接</li></ol></li> <li>通过四次挥手断开连接, <strong>四次挥手过程</strong>:
<ol><li>客户端发送一个 FIN 报文，报文中指定一个序列号，此时客户端处于 FIN_WAIT1 状态，等待服务器确认</li> <li>服务器接收到 FIN 后，会发送 ACK 确认报文，表明已经收到客户端报文，此时服务端处于 CLOSE_WAIT2 状态</li> <li>服务器发送 FIN，告诉客户端想断开连接，此时服务端处于 LAST_CHECK 阶段</li> <li>客户端收到 FIN 后，一样发送一个 ACK 作为应答，此时客户端处于 TIME_WAIT 阶段。需要过一段时间确认服务端收到自己的 ACK 报文后才会进入 CLOSED 状态</li></ol></li></ul></li> <li>发送 http 请求</li> <li>网络响应</li> <li>浏览器解析和渲染<br>
分为构建 dom 树、样式计算、生成布局树</li> <li>生成布局</li></ol> <p><strong>详细过程</strong></p> <ol><li>在浏览器地址栏输入 URL</li> <li>浏览器查看 缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤
<ul><li>如果资源未缓存，发起新请求</li> <li>如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。</li> <li>检验新鲜通常有两个 HTTP 头进行控制 Expires 和 Cache-Control：
<ul><li>HTTP1.0 提供 Expires，值为一个绝对时间表示缓存新鲜日期</li> <li>HTTP1.1 增加了 Cache-Control: max-age=,值为以秒为单位的最大新鲜时间</li></ul></li></ul></li> <li>浏览器<code>解析URL</code>获取协议，主机，端口，path</li> <li>浏览器<code>组装一个HTTP（GET）请求报文</code></li> <li>浏览器获取主机 ip 地址，过程如下：
<ul><li>浏览器缓存</li> <li>本机缓存</li> <li>hosts 文件</li> <li>路由器缓存</li> <li>ISP DNS 缓存</li> <li>DNS 递归查询（可能存在负载均衡导致每次 IP 不一样）</li></ul></li> <li><code>打开一个socket与目标IP地址，端口建立TCP链接</code>，三次握手如下：
<ul><li>客户端发送一个 TCP 的 SYN=1，Seq=X 的包到服务器端口</li> <li>服务器发回 SYN=1， ACK=X+1， Seq=Y 的响应包</li> <li>客户端发送 ACK=Y+1， Seq=Z</li></ul></li> <li>TCP 链接建立后发送 HTTP 请求</li> <li>服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用 HTTP Host 头部判断请求的服务程序</li> <li>服务器检查 HTTP 请求头是否包含缓存验证信息如果验证缓存新鲜，返回<code>304</code>等对应状态码</li> <li>处理程序读取完整请求并准备 HTTP 响应，可能需要查询数据库等操作</li> <li>服务器将<code>响应报文通过TCP连接发送回浏览器</code></li> <li>浏览器接收 HTTP 响应，然后根据情况选择 <code>关闭TCP连接或者保留重用</code>，关闭 TCP 连接的四次握手如下：
<ul><li>主动方发送 Fin=1， Ack=Z， Seq= X 报文</li> <li>被动方发送 ACK=X+1， Seq=Z 报文</li> <li>被动方发送 Fin=1， ACK=X， Seq=Y 报文</li> <li>主动方发送 ACK=Y， Seq=X 报文</li></ul></li> <li>浏览器检查响应状态吗：是否为 1XX，3XX， 4XX， 5XX，这些情况处理与 2XX 不同</li> <li>如果资源可缓存，<code>进行缓存</code></li> <li>对响应进行<code>解码</code>（例如 gzip 压缩）</li> <li>根据资源类型决定如何处理（假设资源为 HTML 文档）</li> <li><code>解析HTML文档，构建DOM树，下载资源，构造CSSOM树，执行js脚本</code>，这些操作没有严格的先后顺序，以下分别解释</li> <li><code>构建DOM树</code>：
<ul><li>Tokenizing：根据 HTML 规范将字符流解析为标记</li> <li>Lexing：词法分析将标记转换为对象并定义属性和规则</li> <li>DOM construction：根据 HTML 标记关系将对象组成 DOM 树</li></ul></li> <li>解析过程中遇到图片、样式表、js 文件，启动下载</li> <li>构建 CSSOM 树：
<ul><li>Tokenizing：字符流转换为标记流</li> <li>Node：根据标记创建节点</li> <li>CSSOM：节点创建 CSSOM 树</li></ul></li> <li>根据 DOM 树和 CSSOM 树构建渲染树:
<ul><li>从 DOM 树的根节点遍历所有可见节点，不可见节点包括：1）script,meta 这样本身不可见的标签。2)被 css 隐藏的节点，如 display: none</li> <li>对每一个可见节点，找到恰当的 CSSOM 规则并应用</li> <li>发布可视节点的内容和计算样式</li></ul></li> <li><strong>js 解析如下</strong>：
<ul><li>浏览器创建 Document 对象并解析 HTML，将解析到的元素和文本节点添加到文档中，此时<code>document.readystate为loading</code></li> <li>HTML 解析器遇到没有 <code>async</code> 和 <code>defer</code> 的 script 时，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用 document.write()把文本插入到输入流中。<strong>同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作 script 和他们之前的文档内容</strong></li> <li>当解析器遇到设置了 <strong><code>async</code></strong> 属性的 script 时，开始<code>下载脚本并继续解析文档</code>。脚本会在它下载完成后尽快执行，但是<code>解析器不会停下来等它下载</code>。异步脚本禁止使用 document.write()，它们可以访问自己 script 和之前的文档元素</li> <li>当文档完成解析，document.readState 变成 interactive</li> <li>所有 <strong><code>defer</code></strong> 脚本会<code>按照在文档出现的顺序执行</code>，延迟脚本能访问完整文档树，禁止使用 <code>document.write()</code></li> <li>浏览器在 <code>Document</code> 对象上触发 <code>DOMContentLoaded</code> 事件</li> <li>此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，<code>document.readState</code> 变为 <code>complete</code>, <code>window</code> 触发 <code>load</code> 事件</li></ul></li> <li>显示页面（HTML 解析过程中会逐步显示页面）</li></ol> <h2 id="_2-浏览器的渲染机制"><a href="#_2-浏览器的渲染机制" class="header-anchor">#</a> 2. 浏览器的渲染机制</h2> <p>浏览器的渲染机制一般分为以下几个步骤</p> <ol><li>解析 html 生产 DOM 树。</li> <li>解析 CSS 规则。</li> <li>根据 DOM Tree 和 CSS Tree 生成 Render Tree。</li> <li>根据 Render 树进行 layout，负责各个元素节点的尺寸、位置计算。</li> <li>绘制 Render 树(painting)，绘制页面像素信息。</li> <li>浏览器会将各层的信息发送给 GPU，GPU 会将各层合成（composite），显示在屏幕上。</li></ol> <img src="/lutest/images/prepare/require/04.png" alt="images/prepare/require/04.png"> <p>在构建 CSSOM 树时，会阻塞渲染，直至 CSSOM 树构建完成。并且构建 CSSOM 树是一个十分消耗性能的过程，所以应该尽量保证层级扁平，减少过度层叠，越是具体的 CSS 选择器，执行速度越慢。</p> <p>当 HTML 解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件。并且 CSS 也会影响 JS 的执行，只有当解析完样式表才会执行 JS，所以也可以认为这种情况下，CSS 也会暂停构建 DOM。</p> <img src="/lutest/images/prepare/require/05.png" alt="images/prepare/require/05.png"> <h2 id="_3-浏览器允许的并发请求资源数"><a href="#_3-浏览器允许的并发请求资源数" class="header-anchor">#</a> 3. 浏览器允许的并发请求资源数</h2> <p>浏览器的并发请求数目限制是针对同一域名的（例如向 www.baidu.com 发送请求）。即一时间针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞。</p> <p><strong>浏览器的并发请求数目限制是针对同一域名的（例如向 www.baidu.com 发送请求）。即一时间针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞。</strong></p> <p>这个问题实际上涉及非常多的考虑和因此而发生的优化技术：<br>
首先，是基于端口数量和线程切换开销的考虑，浏览器不可能无限量的并发请求，因此衍生出来了并发限制和 HTTP/1.1 的 Keep alive。 所以，IE6/7 在 HTTP/1.1 下的并发才 2，但 HTTP/1.0 却是 4。 而随着技术的发展，负载均衡和各类 NoSQL 的大量应用，基本已经足以应对 C10K 的问题。 但却并不是每个网站都懂得利用 domain hash 也就是多域名来加速访问。因此，新的浏览器加大了并发数的限制，但却仍控制在 8 以内。<br>
后端的保护</p> <h2 id="_4-浏览器的机制你了解多少"><a href="#_4-浏览器的机制你了解多少" class="header-anchor">#</a> 4. 浏览器的机制你了解多少</h2> <ol><li><strong>解析 HTML</strong><br>
在这一步浏览器执行了所有的加载解析逻辑，在解析 HTML 的过程中发出了页面渲染所需的各种外部资源请求。</li> <li><strong>计算样式</strong><br>
浏览器将识别并加载所有的 CSS 样式信息与 DOM 树合并，最终生成页面 render 树（:after :before 这样的伪元素会在这个环节被构建到 DOM 树中）。</li> <li><strong>计算图层布局</strong><br>
页面中所有元素的相对位置信息，大小等信息均在这一步得到计算。</li> <li><strong>绘制图层</strong><br>
在这一步中浏览器会根据我们的 DOM 代码结果，把每一个页面图层转换为像素，并对所有的媒体文件进行解码。</li> <li><strong>整合图层，得到页面</strong><br>
最后一步浏览器会合并合各个图层，将数据由 CPU 输出给 GPU 最终绘制在屏幕上。（复杂的视图层会给这个阶段的 GPU 计算带来一些压力，在实际应用中为了优化动画性能，我们有时会手动区分不同的图层）。</li></ol> <h2 id="_5-浏览器内核"><a href="#_5-浏览器内核" class="header-anchor">#</a> 5. 浏览器内核</h2> <p>浏览器内核，即我们的<code>渲染进程</code>，又名 <code>Renderer</code> 进程，我们页面的渲染，js 的执行，事件的循环都在这一进程内进行，也就是说，该<code>进程下面拥有着多个线程</code>，靠着这些线程共同完成渲染任务。那么这些线程是什么呢，如下：</p> <ol><li><strong>图形用户界面 GUI 渲染线程</strong> <ul><li>负责渲染浏览器界面，包括解析 HTML、CSS、构建 DOM 树、Render 树、布局与绘制等</li> <li>当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行</li></ul></li> <li><strong>JS 引擎线程</strong> <ul><li>JS 内核，也称 JS 引擎，负责处理执行 javascript 脚本</li> <li>等待任务队列的任务的到来，然后加以处理，浏览器无论什么时候都只有一个 JS 引擎在运行 JS 程序</li></ul></li> <li><strong>事件触发线程</strong> <ul><li>听起来像 JS 的执行，但是其实归属于浏览器，而不是 JS 引擎，用来控制事件循环（可以理解，JS 引擎自己都忙不过来，需要浏览器另开线程协助）</li> <li>当 JS 引擎执行代码块如 setTimeout 时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX 异步请求等），会将对应任务添加到事件线程中</li> <li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理</li> <li>注意：由于 JS 的单线程关系，所以这些待处理队列中的事件都得排队等待 JS 引擎处理（当 JS 引擎空闲时才会去执行）</li></ul></li> <li><strong>定时触发器线程</strong> <ul><li>setInterval 与 setTimeout 所在线程</li> <li>定时计时器并不是由 JS 引擎计时的，因为如果 JS 引擎是单线程的，如果 JS 引擎处于堵塞状态，那会影响到计时的准确</li> <li>当计时完成被触发，事件会被添加到事件队列，等待 JS 引擎空闲了执行</li> <li>注意：W3C 的 HTML 标准中规定，setTimeout 中低与 4ms 的时间间隔算为 4ms</li></ul></li> <li><strong>异步 HTTP 请求线程</strong> <ul><li>在 XMLHttpRequest 在连接后新启动的一个线程</li> <li>线程如果检测到请求的状态变更，如果设置有回调函数，该线程会把回调函数添加到事件队列，同理，等待 JS 引擎空闲了执行</li></ul></li></ol> <p>浏览器内核，放图加强记忆：</p> <div align="center"><img src="/lutest/images/prepare/new/2020061901.jpg" alt="images/prepare/new/2020061901.jpg"></div> <p><strong>浏览器内核拿到响应报文之后，渲染大概分为以下步骤</strong></p> <ol><li>解析 html 生产 DOM 树。</li> <li>解析 CSS 规则。</li> <li>根据 DOM Tree 和 CSS Tree 生成 Render Tree。</li> <li>根据 Render 树进行 layout，负责各个元素节点的尺寸、位置计算。</li> <li>绘制 Render 树(painting)，绘制页面像素信息。</li> <li>浏览器会将各层的信息发送给 GPU，GPU 会将各层合成（composite），显示在屏幕上。</li></ol> <h2 id="_6-浏览器内核中线程之间的关系"><a href="#_6-浏览器内核中线程之间的关系" class="header-anchor">#</a> 6. 浏览器内核中线程之间的关系</h2> <ol><li>GUI 渲染线程与 JS 引擎线程互斥</li> <li>JS 引擎线程与事件触发线程、定时触发器线程、异步 HTTP 请求线程<br>
事件触发线程、定时触发器线程、异步 HTTP 请求线程三个线程有一个共同点，那就是使用回调函数的形式，当满足了特定的条件，这些回调函数会被执行。这些回调函数被浏览器内核理解成事件，在浏览器内核中拥有一个事件队列，这三个线程当满足了内部特定的条件，会将这些回调函数添加到事件队列中，等待 JS 引擎空闲执行。例如异步 HTTP 请求线程，线程如果检测到请求的状态变更，如果设置有回调函数，回调函数会被添加事件队列中，等待 JS 引擎空闲了执行。<br>
但是，JS 引擎对事件队列（宏任务）与 JS 引擎内的任务（微任务）执行存在着先后循序，当每执行完一个事件队列的时间，JS 引擎会检测内部是否有未执行的任务，如果有，将会优先执行（微任务）。</li> <li>WebWorker
<ul><li>Web Workers 使得一个 Web 应用程序可以在与主执行线程分离的后台线程中运行一个脚本操作。这样做的好处是可以在一个单独的线程中执行费时的处理任务，从而允许主（通常是 UI）线程运行而不被阻塞/放慢。</li> <li>WebWorker 可以向浏览器申请一个子线程，该子线程服务于主线程，完全受主线程控制。</li> <li>JS 引擎线程与 worker 线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）</li> <li>所以，如果需要进行一些高耗时的计算时，可以单独开启一个 WebWorker 线程，这样不管这个 WebWorker 子线程怎么密集计算、怎么阻塞，都不会影响 JS 引擎主线程，只需要等计算结束，将结果通过 postMessage 传输给主线程就可以了。</li></ul></li> <li>SharedWorker<br>
另外，还有个东西叫 SharedWorker，与 WebWorker 在概念上所不同。
<ul><li>WebWorker 只属于某一个页面，不会和其他标签页的 Renderer 进程共享，WebWorker 是属于 Renderer 进程创建的进程。</li> <li>SharedWorker 是由浏览器单独创建的进程来运行的 JS 程序，它被所有的 Renderer 进程所共享，在浏览器中，最多只能存在一个 SharedWorker 进程。</li></ul></li></ol> <h2 id="_7-webwork"><a href="#_7-webwork" class="header-anchor">#</a> 7. webwork</h2> <p>webwork -- 浏览器实现的多进程</p> <p>Web Worker 为 Web 内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面。此外，他们可以使用 XMLHttpRequest 执行 I/O (尽管 responseXML 和 channel 属性总是为空)。一旦创建， 一个 worker 可以将消息发送到创建它的 JavaScript 代码, 通过将消息发布到该代码指定的事件处理程序（反之亦然）。</p> <p>Web Worker 使用要点</p> <ul><li><strong>同源限制</strong>：分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。</li> <li><strong>DOM 限制</strong>：Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用 document、window、parent 这些对象。但是，Worker 线程可以 navigator 对象和 location 对象。</li> <li><strong>通信联系</strong>：Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。</li> <li><strong>脚本限制</strong>：Worker 线程不能执行 alert()方法和 confirm()方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。</li> <li><strong>文件限制</strong>：Worker 线程无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自网络。后面我们允许会做处理。</li></ul> <p>web 端：</p> <ul><li>主进程 ui 进程， 唯一只有一个</li> <li>子进程(工作进程) 看不见；只能完成计算、数据请求操作</li></ul> <p>优点：</p> <ol><li>充分利用资源(多个进程同时工作)</li> <li>防止主进程卡住</li></ol> <p>如何终止 WebWork？</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 关闭worker</span>
work<span class="token punctuation">.</span><span class="token function">terminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token doctype">&lt;!DOCTYPE html&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>en<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>UTF-8<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>webworker<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
      window<span class="token punctuation">.</span><span class="token function-variable function">onload</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> oTxt1 <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;txt1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">let</span> oTxt2 <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;txt2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">let</span> oBtn <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;btn1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        oBtn<span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">let</span> n1 <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>oTxt1<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">let</span> n2 <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>oTxt2<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>

          <span class="token comment">// 1.创建子进程</span>
          <span class="token keyword">let</span> work <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token string">&quot;w1.js&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token comment">// 2.发送</span>
          work<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token punctuation">{</span> n1<span class="token punctuation">,</span> n2 <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

          <span class="token comment">// 6.接收结果</span>
          work<span class="token punctuation">.</span><span class="token function-variable function">onmessage</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">ev</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ev<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">;</span>
    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>text<span class="token punctuation">&quot;</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>txt1<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>text<span class="token punctuation">&quot;</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>txt2<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>button<span class="token punctuation">&quot;</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>计算<span class="token punctuation">&quot;</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>btn1<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// w1.js</span>
<span class="token comment">// 3. 接收</span>
<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">onmessage</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">ev</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// console.log('我得到了' + ev.data)</span>
  <span class="token comment">// 4. 处理任务</span>
  <span class="token keyword">let</span> sum <span class="token operator">=</span> ev<span class="token punctuation">.</span>data<span class="token punctuation">.</span>n1 <span class="token operator">+</span> ev<span class="token punctuation">.</span>data<span class="token punctuation">.</span>n2<span class="token punctuation">;</span>

  <span class="token comment">// 5. 返回</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h2 id="_8-load-和-domcontentloaded-区别"><a href="#_8-load-和-domcontentloaded-区别" class="header-anchor">#</a> 8. Load 和 DOMContentLoaded 区别</h2> <p>Load 事件触发代表页面中的 DOM，CSS，JS，图片已经全部加载完毕。</p> <p>DOMContentLoaded 事件触发代表初始的 HTML 被完全加载和解析，不需要等待 CSS，JS，图片加载。</p> <h2 id="_9-重绘（repaint）和回流（reflow）"><a href="#_9-重绘（repaint）和回流（reflow）" class="header-anchor">#</a> 9. 重绘（Repaint）和回流（Reflow）</h2> <p><strong>触发重排（回流）: 页面布局和元素几何属性的改变就会导致重排</strong></p> <p>重绘和回流是渲染步骤中的一小节，但是这两个步骤对于性能影响很大。</p> <ul><li>重绘是当节点需要更改外观而不会影响布局的，比如改变 color, background-color 就叫称为重绘</li> <li>回流是布局或者几何属性需要改变就称为回流。</li></ul> <p>回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流。</p> <p>会触发回流的操作:</p> <ul><li>页面初次渲染</li> <li>浏览器窗口大小改变</li> <li>元素尺寸、位置、内容发生改变</li> <li>元素字体大小变化</li> <li>添加或者删除可见的 dom 元素</li> <li>激活 CSS 伪类（例如：:hover）</li> <li>查询某些属性或调用某些方法</li> <li>clientWidth、clientHeight、clientTop、clientLeft</li> <li>offsetWidth、offsetHeight、offsetTop、offsetLeft</li> <li>scrollWidth、scrollHeight、scrollTop、scrollLeft</li> <li>getComputedStyle()</li> <li>getBoundingClientRect()</li> <li>scrollTo()</li></ul> <p>所以以下几个动作可能会导致性能问题：</p> <ul><li>改变 window 大小</li> <li>改变字体</li> <li>添加或删除样式</li> <li>文字改变</li> <li>定位或者浮动</li> <li>盒模型</li></ul> <p>很多人不知道的是，重绘和回流其实和 Event loop 有关。</p> <ol><li>当 Event loop 执行完 Microtasks 后，会判断 document 是否需要更新。因为浏览器是 60Hz 的刷新率，每 16ms 才会更新一次。</li> <li>然后判断是否有 resize 或者 scroll ，有的话会去触发事件，所以 resize 和 scroll 事件也是至少 16ms 才会触发一次，并且自带节流功能。</li> <li>判断是否触发了 media query</li> <li>更新动画并且发送事件</li> <li>判断是否有全屏操作事件</li> <li>执行 requestAnimationFrame 回调</li> <li>执行 IntersectionObserver 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好</li> <li>更新界面</li> <li>以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 requestIdleCallback 回调。</li></ol> <h2 id="_10-减少重绘和回流"><a href="#_10-减少重绘和回流" class="header-anchor">#</a> 10. 减少重绘和回流</h2> <ol><li>使用 <code>translate</code> 替代 <code>top</code><div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>test<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">
  <span class="token selector">.test</span> <span class="token punctuation">{</span>
    <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
    <span class="token property">top</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
    <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
    <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 引起回流</span>
    document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">&quot;.test&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>top <span class="token operator">=</span> <span class="token string">&quot;100px&quot;</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div></li> <li>使用 <code>visibility</code> 替换<code>display: none</code> ，因为前者只会引起重绘，后者会引发回流（改变了布局）</li> <li>把 DOM 离线后修改，比如：先把 DOM 给 <code>display:none</code> (有一次 Reflow)，然后你修改 100 次，然后再把它显示出来</li> <li>不要把 DOM 结点的属性值放在一个循环里当成循环里的变量<div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 获取 offsetTop 会导致回流，因为需要去获取正确的值</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">&quot;.test&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>offsetTop<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></li> <li>不要使用 <code>table</code> 布局，可能很小的一个小改动会造成整个 table 的重新布局</li> <li>动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 <code>requestAnimationFrame</code></li> <li>CSS 选择符从右往左匹配查找，避免 DOM 深度过深</li> <li>将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 <code>video</code> 标签，浏览器会自动将该节点变为图层。</li></ol> <h2 id="_11-事件触发三阶段"><a href="#_11-事件触发三阶段" class="header-anchor">#</a> 11. 事件触发三阶段</h2> <p>事件触发有三个阶段</p> <ul><li><code>window</code> 往事件触发处传播，遇到注册的捕获事件会触发</li> <li>传播到事件触发处时触发注册的事件</li> <li>从事件触发处往 <code>window</code> 传播，遇到注册的冒泡事件会触发</li></ul> <p>事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个目标节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 以下会先打印冒泡然后是捕获</span>
node<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>
  <span class="token string">&quot;click&quot;</span><span class="token punctuation">,</span>
  <span class="token parameter">event</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;冒泡&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token boolean">false</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
node<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>
  <span class="token string">&quot;click&quot;</span><span class="token punctuation">,</span>
  <span class="token parameter">event</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;捕获 &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token boolean">true</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h2 id="_12-注册事件"><a href="#_12-注册事件" class="header-anchor">#</a> 12. 注册事件</h2> <p>通常我们使用 <code>addEventListener</code> 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 <code>useCapture</code> 参数来说，该参数默认值为 <code>false</code> 。 <code>useCapture</code> 决定了注册的事件是捕获事件还是冒泡事件。对于对象参数来说，可以使用以下几个属性</p> <ul><li><code>capture</code>，布尔值，和 <code>useCapture</code> 作用一样</li> <li><code>once</code>，布尔值，值为 <code>true</code> 表示该回调只会调用一次，调用后会移除监听</li> <li><code>passive</code>，布尔值，表示永远不会调用 <code>preventDefault</code></li></ul> <p>一般来说，我们只希望事件只触发在目标上，这时候可以使用 <code>stopPropagation</code> 来阻止事件的进一步传播。通常我们认为 <code>stopPropagation</code> 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。<code>stopImmediatePropagation</code> 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件。</p> <p><strong><code>事件冒泡</code></strong>：即事件开始时由最具体的元素接收，然后逐级向上传播到较为不具体的节点<br> <strong><code>事件捕获</code></strong>: 是不太具体的 DOM 节点应该更早接收到事件，而最具体的节点应该最后接收到事件</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>node<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>
  <span class="token string">&quot;click&quot;</span><span class="token punctuation">,</span>
  <span class="token parameter">event</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    event<span class="token punctuation">.</span><span class="token function">stopImmediatePropagation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;冒泡&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token boolean">false</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 点击 node 只会执行上面的函数，该函数不会执行</span>
node<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>
  <span class="token string">&quot;click&quot;</span><span class="token punctuation">,</span>
  <span class="token parameter">event</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;捕获 &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token boolean">true</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h2 id="_13-事件代理"><a href="#_13-事件代理" class="header-anchor">#</a> 13. 事件代理</h2> <p><strong><code>事件委托</code><strong>还有一个名字叫</strong>事件代理</strong>，JS 高程上讲：<strong>事件委托就是利用事件冒泡，只制定一个事件处理程序，就可以管理某一类型的所有事件</strong>。我用取快递来解释这个现象： 有三个同事预计会在周一收到快递。为签收快递，有两种办法：一是三个人在公司门口等快递；二是委托给前台代为签收。现实当中，我们大都采用委托的方案。前台收到快递后，她会判断收件人是谁，然后按照收件人的要求签收，甚至代为付款。这种方案还有一个优势，那就是即使公司里来了新员工（不管多少），前台也会在收到寄给新员工的快递后核实并代为签收。</p> <p>事件代理作用主要是 2 个</p> <ol><li>将事件处理程序代理到父节点，减少内存占用率</li> <li>动态生成子节点时能自动绑定事件处理程序到父节点</li></ol> <p>如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>ul<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
  <span class="token keyword">let</span> ul <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">&quot;##ul&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  ul<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;click&quot;</span><span class="token punctuation">,</span> <span class="token parameter">event</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>事件代理的方式相对于直接给目标注册事件来说，有以下优点</p> <ul><li>节省内存</li> <li>不需要给子节点注销事件</li></ul> <h2 id="_14-预加载、预渲染"><a href="#_14-预加载、预渲染" class="header-anchor">#</a> 14. 预加载、预渲染</h2> <h3 id="预加载"><a href="#预加载" class="header-anchor">#</a> 预加载</h3> <p>在开发中，可能会遇到这样的情况。有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载。</p> <p>预加载其实是声明式的 <code>fetch</code> ，强制浏览器请求资源，并且不会阻塞 <code>onload</code> 事件，可以使用以下代码开启预加载</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>preload<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>http://example.com<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好。</p> <h3 id="预渲染"><a href="#预渲染" class="header-anchor">#</a> 预渲染</h3> <p>可以通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>prerender<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>http://example.com<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>预渲染虽然可以提高页面的加载速度，但是要确保该页面百分百会被用户在之后打开，否则就白白浪费资源去渲染</p> <h2 id="_15-介绍下-http1-0、1-1、2-0-协议的区别？"><a href="#_15-介绍下-http1-0、1-1、2-0-协议的区别？" class="header-anchor">#</a> 15. 介绍下 http1.0、1.1、2.0 协议的区别？</h2> <h3 id="http-0-9"><a href="#http-0-9" class="header-anchor">#</a> HTTP/0.9</h3> <p>已过时。只接受 GET 一种请求方法，没有在通讯中指定版本号，且不支持请求头。由于该版本不支持 POST 方法，因此客户端无法向服务器传递太多信息。</p> <h3 id="http-1-0"><a href="#http-1-0" class="header-anchor">#</a> HTTP/1.0</h3> <p>这是第一个在通讯中指定版本号的 HTTP 协议版本，至今仍被广泛采用，特别是在代理服务器中。</p> <ul><li>构建可扩展性</li></ul> <h3 id="http-1-1"><a href="#http-1-1" class="header-anchor">#</a> HTTP/1.1</h3> <p>持久连接被默认采用，并能很好地配合代理服务器工作。还支持以管道方式在同时发送多个请求，以便降低线路负载，提高传输速度。</p> <p>HTTP/1.1 相较于 HTTP/1.0 协议的区别主要体现在：</p> <ul><li>缓存处理</li> <li>带宽优化及网络连接的使用</li> <li>错误通知的管理</li> <li>消息在网络中的发送</li> <li>互联网地址的维护</li> <li>安全性及完整性</li></ul> <p><strong>标准化的协议</strong></p> <ul><li>连接可以复用，允许在第一个应答被完全发送之前就发送第二个请求，以降低通信延迟。</li> <li>增加流水线操作</li> <li>支持响应分块</li> <li>引入额外的缓存控制机制</li> <li>引入内容协商机制，包括语言，编码，类型等，并允许客户端和服务器之间约定以最合适的内容进行交换</li> <li>感谢 Host 头，能够使不同域名配置在同一个 IP 地址的服务器上</li></ul> <h3 id="http-2"><a href="#http-2" class="header-anchor">#</a> HTTP/2</h3> <p>在 HTTP/2 的第一版草案（对 SPDY 协议的复刻）中，新增的性能改进不仅包括 HTTP/1.1 中已有的多路复用，修复队头阻塞问题，允许设置设定请求优先级，还包含了一个头部压缩算法(HPACK)[15][16]。此外， HTTP/2 采用了二进制而非明文来打包、传输客户端—服务器间的数据。[12]</p> <ul><li>加密传输层</li> <li>Server-sent events，服务器可以偶尔推送消息到浏览器</li> <li>WebSocket，一个新协议，可以通过升级现有 HTTP 协议来建立</li> <li>多路复用，一个 Tcp 中多个 http 请求是并行的 (雪碧图、多域名散列等优化手段 http/2 中将变得多余)</li> <li>二进制格式编码传输</li> <li><strong>header 压缩</strong>: 通过压缩，头部大小可以减少一半之多，如果后面重复发送请求，那么可能压缩后的头部大小只有原始大小的 1/10。</li> <li>服务端推送</li></ul> <h3 id="帧、消息、流和-tcp-连接"><a href="#帧、消息、流和-tcp-连接" class="header-anchor">#</a> 帧、消息、流和 TCP 连接</h3> <p>有别于 HTTP/1.1 在连接中的明文请求，HTTP/2 与 SPDY 一样，将一个 TCP 连接分为若干个流（Stream），每个流中可以传输若干消息（Message），每个消息由若干最小的二进制帧（Frame）组成。[12]这也是 HTTP/1.1 与 HTTP/2 最大的区别所在。 HTTP/2 中，每个用户的操作行为被分配了一个流编号(stream ID)，这意味着用户与服务端之间创建了一个 TCP 通道；协议将每个请求分割为二进制的控制帧与数据帧部分，以便解析。这个举措在 SPDY 中的实践表明，相比 HTTP/1.1，新页面加载可以加快 11.81% 到 47.7%[17]</p> <h3 id="hpack-算法"><a href="#hpack-算法" class="header-anchor">#</a> HPACK 算法</h3> <p>HPACK 算法是新引入 HTTP/2 的一个算法，用于对 HTTP 头部做压缩。其原理在于：</p> <ul><li>客户端与服务端根据 RFC 7541 的附录 A，维护一份共同的静态字典（Static Table），其中包含了常见头部名及常见头部名称与值的组合的代码；</li> <li>客户端和服务端根据先入先出的原则，维护一份可动态添加内容的共同动态字典（Dynamic Table）；</li> <li>客户端和服务端根据 RFC 7541 的附录 B，支持基于该静态哈夫曼码表的哈夫曼编码（Huffman Coding）。</li></ul> <h3 id="服务器推送"><a href="#服务器推送" class="header-anchor">#</a> 服务器推送</h3> <p>网站为了使请求数减少，通常采用对页面上的图片、脚本进行极简化处理。但是，这一举措十分不方便，也不高效，依然需要诸多 HTTP 链接来加载页面和页面资源。</p> <p>HTTP/2 引入了服务器推送，即服务端向客户端发送比客户端请求更多的数据。这允许服务器直接提供浏览器渲染页面所需资源，而无须浏览器在收到、解析页面后再提起一轮请求，节约了加载时间。</p> <h2 id="_16-简单讲解一下-http2-的多路复用"><a href="#_16-简单讲解一下-http2-的多路复用" class="header-anchor">#</a> 16. 简单讲解一下 http2 的多路复用</h2> <p>HTTP2 采用二进制格式传输，取代了 HTTP1.x 的文本格式，二进制格式解析更高效。
多路复用代替了 HTTP1.x 的序列和阻塞机制，所有的相同域名请求都通过同一个 TCP 连接并发完成。在 HTTP1.x 中，并发多个请求需要多个 TCP 连接，浏览器为了控制资源会有 6-8 个 TCP 连接都限制。</p> <p>HTTP2 中</p> <ul><li>同域名下所有通信都在单个连接上完成，消除了因多个 TCP 连接而带来的延时和内存消耗。</li> <li>单个连接上可以并行交错的请求和响应，之间互不干扰</li></ul> <p>在 HTTP/1 中，每次请求都会建立一次 HTTP 连接，也就是我们常说的 3 次握手 4 次挥手，这个过程在一次请求过程中占用了相当长的时间，即使开启了 <code>Keep-Alive</code> ，解决了多次连接的问题，但是依然有两个效率上的问题：</p> <ul><li>第一个：串行的文件传输。当请求 a 文件时，b 文件只能等待，等待 a 连接到服务器、服务器处理文件、服务器返回文件，这三个步骤。我们假设这三步用时都是 1 秒，那么 a 文件用时为 3 秒，b 文件传输完成用时为 6 秒，依此类推。（注：此项计算有一个前提条件，就是浏览器和服务器是单通道传输）</li> <li>第二个：连接数过多。我们假设 Apache 设置了最大并发数为 300，因为浏览器限制，浏览器发起的最大请求数为 6，也就是服务器能承载的最高并发为 50，当第 51 个人访问时，就需要等待前面某个请求处理完成。</li></ul> <p>HTTP/2 的多路复用就是为了解决上述的两个性能问题。<br>
在 HTTP/2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。<br>
帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。</p> <p><strong>多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求</strong>。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。</p> <p><strong>简单来说， 就是在同一个 TCP 连接，同一时刻可以传输多个 HTTP 请求</strong><br>
之前是同一个连接只能用一次， 如果开启了<code>keep-alive</code>，虽然可以用多次，但是同一时刻只能有一个 HTTP 请求</p> <p style="color:red;">为什么 HTTP1.1 不能实现多路复用</p> <ol><li>HTTP1.x 是序列和阻塞机制</li> <li>HTTP 2.0 是多工复用 TCP 连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了&quot;队头堵塞&quot;。
<ul><li>举例来说，在一个 TCP 连接里面，服务器同时收到了 A 请求和 B 请求，于是先回应 A 请求，结果发现处理过程非常耗时，于是就发送 A 请求已经处理好的部分， 接着回应 B 请求，完成后，再发送 A 请求剩下的部分。</li> <li>旧的 http1.1 是会等 A 请求完全处理完后在 处理 B 请求，会阻塞</li> <li>另：http1.1 已经实现了管道机制：即 在同一个 TCP 连接里面，客户端可以同时发送多个请求。http 1.0 并做不到，所以效率很低</li></ul></li></ol> <p style="color:red;"> HTTP2 </p> <ol><li>强制 https</li> <li>性能更高 - 面向流、头压缩、 多路复用</li> <li>双向通信 - 服务器推送</li></ol> <h2 id="_17-http-状态码"><a href="#_17-http-状态码" class="header-anchor">#</a> 17. HTTP 状态码</h2> <ul><li><strong>1xx 初始化</strong> <ul><li>信息状态码，接收的请求正在处理</li> <li>http2.0 已经么有 1xx 了{websocket 例外}</li></ul></li> <li><strong>2xx 客户端成功</strong> <ul><li>200：成功；</li> <li>202：接受;</li> <li>204：No Content;</li> <li>206：Partial Content</li></ul></li> <li><strong>3xx 重定向缓存</strong> <ul><li>301：永久重定向；</li> <li>302：临时转移；</li> <li>303：See Other, 永久重定向</li> <li>304：缓存；</li> <li>307：临时重定向；</li></ul></li> <li><strong>4xx 客户端失败</strong> <ul><li>400：参数错误；</li> <li>401：未认证登陆，无权限访问；</li> <li>403：禁止访问；</li> <li>404：未找到；</li> <li>417：发送资源过大</li></ul></li> <li><strong>5xx 服务器端失败</strong> <ul><li>500：服务器内部错误；</li> <li>503：连接数过多，服务器超负载，</li> <li>504：网关超时</li></ul></li></ul> <h2 id="_18-http-相关"><a href="#_18-http-相关" class="header-anchor">#</a> 18 HTTP 相关</h2> <p>Web 使用一种名为 HTTP (HyperText Transfer Protocol，<strong>超文本传输协议</strong>)的协议作为规范，完成从客户端到服务器端等一系列运作流程</p> <ul><li>HTTP 协议用于客户端和服务器端之间的通信，</li> <li>通过请求和响应的交换达成通信，</li> <li>HTTP 是不保存状态的协议，即无状态(stateless)协议</li></ul> <p>HTTP 方法</p> <ul><li>GET：获取资源</li> <li>POST：传输实体主体</li> <li>PUT: 传输文件</li> <li>HEAD：获得报文首部</li> <li>OPTIONS：询问支持额方法</li> <li>TRACE：追踪路径</li> <li>CONNECT: 要求用隧道协议连接代理</li></ul> <p>HTTP 缺点：</p> <ul><li>通信使用明文（不加密），内容可能会被窃听</li> <li>不验证通信方的身份，因此有可能遭遇伪装</li> <li>无法验证报文的完整性，所以有可能已遭篡改</li></ul> <h2 id="_19-tcp-三次握手和四次挥手"><a href="#_19-tcp-三次握手和四次挥手" class="header-anchor">#</a> 19. TCP 三次握手和四次挥手</h2> <ol><li>客户端发送 syn 包到服务器，等待服务器确认接收。</li> <li>服务器确认接收 syn 包并确认客户的 syn，并发送回来一个 syn+ack 的包给客户端。</li> <li>客户端确认接收服务器的 syn+ack 包，并向服务器发送确认包 ack，二者相互建立联系后，完成 tcp 三次握手。</li> <li>四次握手就是中间多了一层 等待服务器再一次响应回复相关数据的过程</li></ol> <p><strong>三次握手过程</strong></p> <ol><li>客户端向服务器发送连接请求，传递一个数据包 syn，此时客户端处于 SYN_SEND 状态</li> <li>服务器接收 syn 报文后，会以自己的 syn 报文作为应答，传递数据包 syn+ack,此时服务器处于 SYN-REVD 状态</li> <li>客户端接收 syn 报文后，发送一个数据包 ack，此时客户端处于 ESTABLISHED 状态，双方已建立连接</li></ol> <p>通过四次挥手断开连接<br> <strong>四次挥手过程</strong>:</p> <ol><li>客户端发送一个 FIN 报文，报文中指定一个序列号，此时客户端处于 FIN_WAIT1 状态，等待服务器确认</li> <li>服务器接收到 FIN 后，会发送 ACK 确认报文，表明已经收到客户端报文，此时服务端处于 CLOSE_WAIT2 状态</li> <li>服务器发送 FIN，告诉客户端想断开连接，此时服务端处于 LAST_CHECK 阶段</li> <li>客户端收到 FIN 后，一样发送一个 ACK 作为应答，此时客户端处于 TIME_WAIT 阶段。需要过一段时间确认服务端收到自己的 ACK 报文后才会进入 CLOSED 状态</li></ol> <h2 id="_20-tcp-怎么保证可靠性"><a href="#_20-tcp-怎么保证可靠性" class="header-anchor">#</a> 20. tcp 怎么保证可靠性</h2> <ol><li>超时重传机制</li> <li>对失序数据进行重排序</li> <li>应答机制</li> <li>滑动窗口： 用于网络数据传输时的流量控制，以避免拥塞的发生<br>
所谓滑动窗口，可以理解成接收端所能提供的缓冲区大小。TCP 利用一个滑动的窗口来告诉发送端对它所发送的数据能提供多大的缓冲区。</li> <li>拥塞控制</li></ol> <h2 id="_21-tcp-和-udp-区别"><a href="#_21-tcp-和-udp-区别" class="header-anchor">#</a> 21. tcp 和 udp 区别</h2> <ol><li>tcp 只能一对一通信，udp 可以一对一、一对多、多对多通信，即支持多播和广播</li> <li>tcp 首部开销消耗 32 字节，udp 仅消耗 8 个字节</li> <li>tcp 适合对数据安全性要求高的场景，比如文件传输，udp 适合对数据实时性要求高的场景，比如视频通话、语音通话</li> <li>tcp 是有状态连接，udp 是无状态的连接</li> <li>tcp-可靠传输 udp-不可靠传输</li> <li>tcp-面向字节流 udp-面向报文</li></ol> <h2 id="_22-https-的传输过程"><a href="#_22-https-的传输过程" class="header-anchor">#</a> 22. https 的传输过程</h2> <p>HTTP + 加密 + 认证 + 完整性保护 = HTTPS</p> <ol><li>在服务器端存在一个公钥及私钥</li> <li>客户端从服务器取得这个公钥</li> <li>客户端产生一个随机的密钥</li> <li>客户端通过公钥对密钥加密（非对称加密）</li> <li>客户端发送到服务器端</li> <li>服务器端接受这个密钥并且以后的服务器端和客户端的数据全部通过这个密钥加密</li></ol> <h2 id="_23-http-连接请求与线程"><a href="#_23-http-连接请求与线程" class="header-anchor">#</a> 23. HTTP 连接请求与线程</h2> <p>HTTP 连接是复杂，有状态的对象，所以它必须被妥善管理。一个 HTTP 连接请求在同一时间只能被一个线程访问。</p> <p>HttpClient 的使用一个叫做的 Http 连接管理器的特殊实体类来管理的 Http 连接.Http 连接管理器在新建的 HTTP 连接时，作为工厂类;管理持久的 http 连接的生命周期;同步持久连接（确保线程安全，即一个 HTTP 连接同一时间只能被一个线程访问）。</p> <p>如果一个的 Http 连接被释放或者被它的消费者明确表示要关闭，那么底层的连接就会和它的代理进行分离，并且该连接会被交还给连接管理器。这是，即使服务消费者仍然持有代理的引用，它也不能再执行 I / O 操作，或者更改的 Http 连接的状态。</p> <h2 id="_24-介绍下-https-中间人攻击"><a href="#_24-介绍下-https-中间人攻击" class="header-anchor">#</a> 24. 介绍下 HTTPS 中间人攻击</h2> <p>https 协议由 http + ssl 协议构成，具体的链接过程可参考 SSL 或 TLS 握手的概述</p> <p>中间人攻击过程如下：</p> <ol><li>服务器向客户端发送公钥。</li> <li>攻击者截获公钥，保留在自己手上。</li> <li>然后攻击者自己生成一个【伪造的】公钥，发给客户端。</li> <li>客户端收到伪造的公钥后，生成加密 hash 值发给服务器。</li> <li>攻击者获得加密 hash 值，用自己的私钥解密获得真秘钥。</li> <li>同时生成假的加密 hash 值，发给服务器。</li> <li>服务器用私钥解密获得假秘钥。</li> <li>服务器用加秘钥加密传输信息</li></ol> <p>防范方法：</p> <ul><li>服务端在发送浏览器的公钥中加入 CA 证书，浏览器可以验证 CA 证书的有效性</li></ul> <h2 id="_25-跨域时如何处理-cookie"><a href="#_25-跨域时如何处理-cookie" class="header-anchor">#</a> 25. 跨域时如何处理 cookie</h2> <p>服务端可以根据实际需求修改下面设置，以 Java 代码为做示例：</p> <div class="language-js line-numbers-mode"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlighted"> </div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre class="language-js"><code><span class="token comment">//允许跨域的域名，*号为允许所有,存在被 DDoS攻击的可能。</span>
<span class="token function">getResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">&quot;Access-Control-Allow-Origin&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;*&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//表明服务器支持的所有头信息字段</span>
<span class="token function">getResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span>
  <span class="token string">&quot;Access-Control-Allow-Headers&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;Origin, No-Cache, X-Requested-With, If-Modified-Since, Pragma,Last-Modified, Cache-Control, Expires, Content-Type, X-E4M-With,userId,token&quot;</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/** 目前测试来看为了兼容所有请求方式，上面2个必须设 **/</span>

<span class="token comment">//如果需要把Cookie发到服务端，需要指定Access-Control-Allow-Credentials字段为true;</span>
<span class="token function">getResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">&quot;Access-Control-Allow-Credentials&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;true&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 首部字段 Access-Control-Allow-Methods 表明服务器允许客户端使用 POST, GET 和 OPTIONS 方法发起请求。</span>
<span class="token comment">//该字段与 HTTP/1.1 Allow: response header 类似，但仅限于在需要访问控制的场景中使用。</span>
<span class="token function">getResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span>
  <span class="token string">&quot;Access-Control-Allow-Methods&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;POST, GET, OPTIONS, DELETE&quot;</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//表明该响应的有效时间为 86400 秒，也就是 24 小时。在有效时间内，浏览器无须为同一请求再次发起预检请求。</span>
<span class="token comment">//请注意，浏览器自身维护了一个最大有效时间，如果该首部字段的值超过了最大有效时间，将不会生效。</span>
<span class="token function">getResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">&quot;Access-Control-Max-Age&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;86400&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// IE8 引入XDomainRequest跨站数据获取功能,也就是说为了兼容IE</span>
<span class="token function">getResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">&quot;XDomainRequestAllowed&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p><strong>跨域请求携带 Cookie</strong></p> <p>服务端可以根据实际需求修改下面设置，以 Java 代码为做示例：</p> <div class="language-js line-numbers-mode"><div class="highlight-lines"><br><div class="highlighted"> </div><br><br><br><br><br><br><br></div><pre class="language-js"><code><span class="token comment">//如果需要把Cookie发到服务端，需要指定Access-Control-Allow-Credentials字段为true;</span>
response<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">&quot;Access-Control-Allow-Credentials&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;true&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//允许跨域的域名，*号为允许所有,存在被 DDoS攻击的可能。</span>
response<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">&quot;Access-Control-Allow-Origin&quot;</span><span class="token punctuation">,</span> request<span class="token punctuation">.</span><span class="token function">getHeader</span><span class="token punctuation">(</span><span class="token string">&quot;Origin&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//表明服务器支持的头信息字段</span>
response<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">&quot;Access-Control-Allow-Headers&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;content-type&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>前端根据实际情况修改发起请求的 ajax，示例：</p> <div class="language-js line-numbers-mode"><div class="highlight-lines"><br><br><br><br><br><div class="highlighted"> </div><div class="highlighted"> </div><div class="highlighted"> </div><div class="highlighted"> </div><br><br><br><br></div><pre class="language-js"><code>$<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    type<span class="token operator">:</span> <span class="token string">&quot;POST&quot;</span><span class="token punctuation">,</span>
    url<span class="token operator">:</span> <span class="token string">&quot;实际的请求地址&quot;</span><span class="token punctuation">,</span>
    data<span class="token operator">:</span> <span class="token punctuation">{</span>参数：参数值<span class="token punctuation">}</span><span class="token punctuation">,</span>
    dataType<span class="token operator">:</span> <span class="token string">&quot;json&quot;</span><span class="token punctuation">,</span>
    crossDomain<span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">//设置跨域为true</span>
    xhrFields<span class="token operator">:</span> <span class="token punctuation">{</span>
      withCredentials<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token comment">//默认情况下，标准的跨域请求是不会发送cookie的</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function-variable function">success</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;请求成功&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p><strong>Add</strong>
如果要实现 cookie 的共享，也有两种方案</p> <ol><li><p>前端的请求用 jsonp 的形式</p></li> <li><p>前端加上配置：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>xhrFields<span class="token operator">:</span> <span class="token punctuation">{</span>
   withCredentials<span class="token operator">:</span> <span class="token boolean">true</span> 
<span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>服务端加上配置：<code>header('Access-Control-Allow-Credentials: true')</code>;</p></li> <li><p>设置 Nginx 代理服务器，将两个服务器域名统一到一个反向代理服务器。</p></li></ol> <h2 id="_26-垃圾回收机制"><a href="#_26-垃圾回收机制" class="header-anchor">#</a> 26. 垃圾回收机制</h2> <p>js 的 垃圾回收机制，常用的有两种方法：标记清除，引用计数；</p> <ul><li><p><strong>标记清除</strong>：当变量进入环境时标记为“进入环境”，当变量离开环境时标记为“离开环境”；然后垃圾收集器会定时去清除，销毁被标记为离开环境的变量，释放其内存；</p> <p>工作流程：</p> <ol><li>垃圾回收器，在运行的时候会给存储在内存中的所有变量都加上标记。</li> <li>去掉环境中的变量以及被环境中的变量引用的变量的标记。</li> <li>再被加上标记的会被视为准备删除的变量。</li> <li>垃圾回收器完成内存清除工作，销毁那些带标记的值并回收他们所占用的内存空间。</li></ol></li></ul> <ul><li><p><strong>引用计数</strong>：跟踪记录每一个引用的值被引用的次数。即变量每被引用一次，引用计数加 1，相反当包含这个值的 引用变量又取得了另外一个值（另外一个值赋给了引用这个值的变量），引用计数减 1；当引用计数变为 0 时，则说明没有值引用这个值了，此时（你已经猜到了）这个变量就可以被垃圾回收机制回收了，（因为没有在被引用了）；一个对象不被其他对象引用时会被回收</p> <p>工作流程：</p> <ol><li>声明了一个变量并将一个引用类型的值赋值给这个变量，这个引用类型值的引用次数就是 1。</li> <li>同一个值又被赋值给另一个变量，这个引用类型值的引用次数加 1.</li> <li>当包含这个引用类型值的变量又被赋值成另一个值了，那么这个引用类型值的引用次数减 1.</li> <li>当引用次数变成 0 时，说明没办法访问这个值了。</li> <li>当垃圾收集器下一次运行时，它就会释放引用次数是 0 的值所占的内存。</li></ol></li></ul> <h2 id="_27-开发过程中遇到的内存泄露情况"><a href="#_27-开发过程中遇到的内存泄露情况" class="header-anchor">#</a> 27. 开发过程中遇到的内存泄露情况</h2> <h3 id="定义"><a href="#定义" class="header-anchor">#</a> 定义</h3> <p>内存泄露是指一块被分配的内存既不能使用，又不能回收，直到浏览器进程结束。C#和 Java 等语言采用了自动垃圾回收方法管理内存，几乎不会发生内存泄露。我们知道，浏览器中也是采用自动垃圾回收方法管理内存，但由于浏览器垃圾回收方法有 bug，会产生内存泄露。</p> <p>由于每次的垃圾回收开销都相对较大，并且由于机制的一些不完善的地方，可能会导致内存泄露。我们可以利用一些方法减少垃圾回收，并且尽量避免循环引用的问题。</p> <p>例如，在对象结束使用后 ，令 obj = null。这样利于解除循环引用，使得无用变量及时被回收。</p> <p>再如，js 中开辟空间的操作有 <code>new()</code>, <code>[ ]</code>, <code>{ }</code>, <code>function (){..}</code>。在创建新对象的时候要尽量考虑增大对象的复用性。</p> <h3 id="内存泄露的几种情况"><a href="#内存泄露的几种情况" class="header-anchor">#</a> 内存泄露的几种情况:</h3> <ol><li><strong>意外的全局变量引起的内存泄漏</strong><br>
原因：全局变量，不会被回收。<br>
解决：使用严格模式避免。</li> <li><strong>闭包引起的内存泄漏</strong><br>
原因：闭包可以维持函数内局部变量，使其得不到释放。<br>
解决：将事件处理函数定义在外部，解除闭包,或者在定义事件处理函数的外部函数中，删除对 dom 的引用。</li> <li><strong>没有清理的 DOM 元素引用</strong><br>
原因：虽然别的地方删除了，但是对象中还存在对 dom 的引用<br>
解决：手动删除。</li> <li><strong>被遗忘的定时器或者回调</strong><br>
原因：定时器中有 dom 的引用，即使 dom 删除了，但是定时器还在，所以内存中还是有这个 dom。<br>
解决：手动删除定时器和 dom。</li> <li><strong>子元素存在引用引起的内存泄漏</strong><br>
原因：div 中的 ul li 得到这个 div，会间接引用某个得到的 li，那么此时因为 div 间接引用 li，即使 li 被清空，也还是在内存中，并且只要 li 不被删除，他的父元素都不会被删除。<br>
解决：手动删除清空</li></ol> <h2 id="_28-js-事件轮询、微任务和宏任务"><a href="#_28-js-事件轮询、微任务和宏任务" class="header-anchor">#</a> 28. js 事件轮询、微任务和宏任务</h2> <p>JavaScript 是单线程语言，也就是说同一个事件只能做一件事。JavaScript 的单线程，与它的用途有关，作为浏览器脚本语言，JavaScript 的主要用途是与用户交互，以及操作 DOM。这决定了它只能是单线程，否则会带来很多复杂的同步问题。为了利用多核 CPU 的计算能力，虽然 HTML5 提出了 Web Worker，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM 和 BOM。所以，依然没有改变 JavaScript 是单线程的本质。</p> <p>为了解决单线程导致的线程等待资源，cpu 空闲，而其他任务一直等待的问题。将所有的任务分为两种，<code>一种是同步任务</code>，<code>一种是异步任务</code>。</p> <ul><li><strong>同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行下一个任务。</strong></li> <li><strong>异步任务指的是，不进入主线程，而进入“任务队列”的任务，自由“任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</strong></li></ul> <ol><li><strong>微任务</strong>包括 <code>process.nextTick</code> ，<code>promise</code> ，<code>Object.observe</code> ，<code>MutationObserver</code></li> <li><strong>宏任务</strong>包括 <code>script</code> ， <code>setTimeout</code> ，<code>setInterval</code> ，<code>setImmediate</code> ，<code>I/O</code> ，<code>UI rendering</code></li></ol> <p>主任务和任务队列示意图：</p> <div align="center"><img src="/lutest/images/prepare/require/01041.png" alt="images/prepare/require/01041.png"></div> <p><strong>执行过程：</strong></p> <ol><li>所有的同步任务都在主线程上指向，形成一个执行栈</li> <li>主线程之外，还存在一个“任务队列”。只要异步任务有了运行结果，就在“任务队列”之中放置一个事件。</li> <li>一旦“执行栈”中的所有同步任务执行完毕，系统就会读取“任务队列”，将可执行的任务放在主线程执行。任务队列是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。</li> <li>主线程不断重复上面的第三步。</li></ol> <p>只要主线程空了，就会去读取“任务队列”。</p> <p>Event Loop（事件轮询）<br>
主线程从“任务队列”中读取事件，这个过程是循环不断的，所以整个过程的这种运行机制又称为 Event Loop（事件循环）</p> <ul><li>执行机制：
<ol><li>执行一个宏任务（栈中没有就从事件队列中获取）</li> <li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li> <li>宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）</li> <li>当前宏任务执行完毕，开始检查渲染，然后 GUI 线程接管渲染</li> <li>渲染完毕后，JS 引擎线程继续，开始下一个宏任务（从宏任务队列中获取）</li></ol></li></ul> <ul><li><p>JavaScript 是单线程语言，决定于它的设计最初是用来处理浏览器网页的交互。浏览器负责解释和执行 JavaScript 的线程只有一个（所有说是单线程），即 JS 引擎线程，但是浏览器同样提供其他线程，如：事件触发线程、定时器触发线程等。</p></li> <li><p>异步一般是指：</p> <ul><li>网络请求</li> <li>计时器</li> <li>DOM 事件监听</li></ul></li> <li><p>事件循环机制：</p> <ul><li>JS 引擎线程会维护一个执行栈，同步代码会依次加入到执行栈中依次执行并出栈。</li> <li>JS 引擎线程遇到异步函数，会将异步函数交给相应的 Webapi，而继续执行后面的任务。</li> <li>Webapi 会在条件满足的时候，将异步对应的回调加入到消息队列中，等待执行。</li> <li>执行栈为空时，JS 引擎线程会去取消息队列中的回调函数（如果有的话），并加入到执行栈中执行。</li> <li>完成后出栈，执行栈再次为空，重复上面的操作，这就是事件循环(event loop)机制。</li></ul></li></ul> <p>下面代码可以帮助理解上面的内容：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;3&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;4&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;5&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;6&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;7&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;8&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;9&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;10&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;11&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;12&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><p>js 代码都是从上到下，一行一行指向，首先遇到第一行 console.log(‘1’)；执行输出 1，然后第二行<code>setTimeout异步任务</code>，放入任务队列。下面遇到<code>process.nextTick是微任务</code>放到本轮循环的结尾，之后遇到<code>new Promise</code>直接指向输出 7，<code>then</code>被放到本轮循环的结尾，接着执行又遇到的<code>setTimeout</code>放到任务队列，本轮代码执行完，开始依次执行本轮结尾的代码，输出 6,8。然后主线程的任务执行完毕，无任务队列中取出一个<code>setTimeout</code>放入主线程开始执行，输出 2，然后遇到<code>process.nextTick</code>，放到本轮循环的结尾，执行<code>new Promise</code>输出 4,<code>then</code>放入本轮循环结尾，主线程代码执行完，开始执行本轮结尾输出 3,5。然后再去任务队列中取第二个<code>setTimeout</code>执行输出 9,11,10,12。</p> <p>所以输出的顺序为 1，7，6，8，2，4，3，5，9，11，10，12。</p> <p>因为 settimeout 是宏任务，虽然先执行的他，但是他被放到了宏任务的 eventqueue 里面，然后代码继续往下检查看有没有微任务，检测到 Promise 的 then 函数把他放入了微任务序列。等到主线进程的所有代码执行结束后。先从微任务 queue 里拿回掉函数，然后微任务 queue 空了后再从宏任务的 queue 拿函数。</p> <h2 id="_29-微信网页版登录机制"><a href="#_29-微信网页版登录机制" class="header-anchor">#</a> 29. 微信网页版登录机制</h2> <p>用 google 浏览器打开网页版微信：https://wx.qq.com/，F12打开开发者工具，选择Network，F5刷新页面，可以看到此网页一直有一个请求处于等待相应状态</p> <p>请求参数如下：</p> <div style="word-break:break-all;">https://login.wx.qq.com/cgi-bin/mmwebwx-bin/login?loginicon=true&amp;<span style="color:red;">uuid=gcWrz8np0Q==</span>&amp;tip=0&amp;r=-1942477294&amp;_=1513770915130</div> <p>该请求会一直处于等待相应状态，除非等到 25s 左右自动重新请求，或二维码被扫描，二维码被扫描的情况下，页面会加载出用户头像，并等待用户在手机上进行确认登录，确认后就能加载出微信主界面</p> <ol><li>打开网页版微信，会向微信服务器发送请求得到一个 uuid，用户生成登录二维码</li> <li>页面用此 uuid 作为参数发送请求，查看该 uuid 被扫描的情况，如果已经被扫描，则返回扫描者的信息，如果没有被扫描，等待一段时间后，继续查看，直到请求超时或找到扫描者信息</li> <li>用户用手机扫描二维码时，就是向服务器发送请求，用扫描到的二维码 uuid 作为 key，生成扫描记录和授权记录，方便网页版使用该 uuid 查找扫描记录</li></ol> <p>问题总结
实现的关键在于一个一直处于等待回应状态的请求(长轮询)，该请求保证只要二维码被扫描，就能实时的获取到用户信息</p> <h2 id="_30-unicode-utf8-utf16-有什么区别"><a href="#_30-unicode-utf8-utf16-有什么区别" class="header-anchor">#</a> 30. unicode utf8 utf16 有什么区别</h2> <ul><li>Unicode 是一个巨大的字符集，给世界上所有的字符定义了一个唯一编码。其仅仅规定了每个符号的二进制代码，没有制定细化的存储规则。UTF-8、UTF-16、UTF-32 才是 Unicode 的存储格式定义。</li> <li>Unicode 是「字符集」</li> <li>UTF-8 是「编码规则」</li></ul> <h2 id="_31-缓存以键值形式存在浏览器，键是什么，值是什么"><a href="#_31-缓存以键值形式存在浏览器，键是什么，值是什么" class="header-anchor">#</a> 31. 缓存以键值形式存在浏览器，键是什么，值是什么</h2> <p>键值对存储通常都有如下接口：</p> <p>Get( key ): 获取之前存储于某标示符“key”之下的一些数据，或者“key”下没有数据时报错。</p> <p>Set( key, value ): 将“value”存储到存储空间中某标示符“key”下，使得我们可以通过调用相同的“key”来访问它。如果“key”下已经有了一些数据，旧的数据将被替换。</p> <p>Delete( key ): 删除存储在“key”下的数据。</p> <p>大部分低层实现都是使用哈希表或者某种自平衡树（例如 B-树或者红黑树）。有时候数据太大而不装不进内存，或者必须维持数据谨防系统因为未知原因而崩溃。在这些情况下，就必须使用到文件系统。</p> <h2 id="_32-讲解一下-https-对称加密和非对称加密"><a href="#_32-讲解一下-https-对称加密和非对称加密" class="header-anchor">#</a> 32. 讲解一下 https 对称加密和非对称加密</h2> <p><strong>对称加密</strong>：<br>
发送方和接收方需要持有同一把密钥，发送消息和接收消息均使用该密钥。相对于非对称加密，对称加密具有更高的加解密速度，但双方都需要事先知道密钥，密钥在传输过程中可能会被窃取，因此安全性没有非对称加密高。</p> <p><strong>非对称加密</strong>：<br>
接收方在发送消息前需要事先生成公钥和私钥，然后将公钥发送给发送方。发送方收到公钥后，将待发送数据用公钥加密，发送给接收方。接收方收到数据后，用私钥解密。<br>
在这个过程中，公钥负责加密，私钥负责解密，数据在传输过程中即使被截获，攻击者由于没有私钥，因此也无法破解。<br>
非对称加密算法的加解密速度低于对称加密算法，但是安全性更高。</p> <p>几个名词要理清</p> <ul><li>RSA：非对称加密</li> <li>AES：对称加密 生成一个随机字符串 key 只有客户端和服务端有 他们两个通过这个 key 对数据加密和传输跟解密 这一个统称对称加密</li> <li>CA：权威认证机构 服务器在建站的时候 去 CA 认证机构认证 得到对应的数字签名 相当于身份证号 客户端每次安装浏览器的时候 都会下载最新的 CA 列表 这个列表有对应的数字签名和服务器 IP 一一对应的列表 这就是为什么我们自己搭建的 localhost 没法发 https 的原因 因为没法进行 CA 认证</li> <li>数字证书：包含了数字签名跟 RSA 公钥</li> <li>数字签名：保证数字证书一定是服务器传给客户端的 相当于服务器的身份证 ID</li> <li>对称密钥： 对数据进行加密的 key</li> <li>非对称密钥： （k1， k2） k1 加密的数据 只有 k2 能解开 k1 位非对称公钥 k2 为非对称私钥</li> <li>非对称公钥：RSA 公钥 k1 加密的数据 只有 k2 能解开</li> <li>非对称私钥：RSA 私钥 k1 加密的数据 只有 k2 能解开</li></ul> <h2 id="_33-如何优化网页上需要展示的超大图片，从请求和性能来解释"><a href="#_33-如何优化网页上需要展示的超大图片，从请求和性能来解释" class="header-anchor">#</a> 33. 如何优化网页上需要展示的超大图片，从请求和性能来解释</h2> <ol><li>图片格式的选择</li> <li>图片压缩</li> <li>图片懒加载</li></ol> <h2 id="_34-实现-adblock-的策略"><a href="#_34-实现-adblock-的策略" class="header-anchor">#</a> 34. 实现 Adblock 的策略</h2> <ol><li>对 URL 请求的拦截，这种 URL 广告一般是网页中 div 元素嵌入了一个 iframe/image 元素，然后加载一个广告链接或者 GIF 图片。</li> <li>对于页面 DOM 嵌入广告内容的处理，这种一般是通过 CSS3 Selector 定位到这些 DOM 元素，然后设置其 display 等于 none !important</li> <li>模拟点击，对于有些可以叉掉的广告，而又没有 cookie，每次访问都会出现，可以写脚本让浏览器帮你进行网页模拟点击，直接帮点击那个叉，但碰到网速不好，特别是移动端很可能出现广告出现一下就消失的效果，用户体验可能不是很好。</li></ol> <h2 id="_35-dom0、dom2、dom3-事件"><a href="#_35-dom0、dom2、dom3-事件" class="header-anchor">#</a> 35. dom0、dom2、dom3 事件</h2> <h3 id="_0-级-dom-分为-2-个："><a href="#_0-级-dom-分为-2-个：" class="header-anchor">#</a> 0 级 DOM 分为 2 个：</h3> <ol><li>一是在标签内写 <code>onclick</code> 事件<div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span>
  <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>myButton<span class="token punctuation">&quot;</span></span>
  <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>button<span class="token punctuation">&quot;</span></span>
  <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>Press Me<span class="token punctuation">&quot;</span></span>
  <span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>alert('thanks');<span class="token punctuation">&quot;</span></span>
<span class="token punctuation">/&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li> <li>二是在 JS 写 <code>onlicke=function(){}</code>函数<div class="language-js line-numbers-mode"><pre class="language-js"><code>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;myButton&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;thanks&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li></ol> <p><strong>优点</strong></p> <ul><li>不需要操作 DOM 来完成事件的绑定
<strong>缺点</strong></li> <li>HTML 和 JS 耦合太强</li> <li>一个元素无法同时绑定多个处理函数</li> <li>DOM0 事件解绑的方式：给事件处理属性赋值 null 来解绑事件如： btn.onclick = null</li></ul> <h3 id="_2-级-dom"><a href="#_2-级-dom" class="header-anchor">#</a> 2 级 DOM</h3> <p>只有一个：监听方法，原生有两个方法用来添加和移除事件处理程序：<code>addEventListener()</code>和<code>removeEventListener()</code>。</p> <p>它们都有三个参数：</p> <ul><li>第一个参数是事件名（如 click）；</li> <li>第二个参数是事件处理程序函数；</li> <li>第三个参数如果是 true 则表示在捕获阶段调用，为 false 表示在冒泡阶段调用。</li></ul> <p><code>addEventListener()</code>:可以为元素添加多个事件处理程序，触发时会按照添加顺序依次调用。
<code>removeEventListener()</code>:不能移除匿名添加的函数。</p> <p>只有 2 级 DOM 包含 3 个事件：<code>事件捕获阶段</code>、<code>处于目标阶段</code>和<code>事件冒泡阶段</code></p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>点击 a 后 capturing(捕捉)阶段事件传播会从 document -&gt; span -&gt; a，然后发生在 a，最后 bubbling(冒泡)阶段事件传播会从 a -&gt; span -&gt; document 。</p> <p>区别：</p> <ul><li>如果定义了两个 dom0 级事件，dom0 级事件会覆盖</li> <li>dom2 不会覆盖，会依次执行</li> <li>dom0 和 dom2 可以共存，不互相覆盖，但是 dom0 之间依然会覆盖</li></ul> <h3 id="dom3"><a href="#dom3" class="header-anchor">#</a> DOM3</h3> <p>DOM3 级事件是在 DOM2 级事件的基础上添加很多事件类型。</p> <ul><li>UI 事件，当用户与页面上的元素交互时触发，如：load、scroll</li> <li>焦点事件，当元素获得或失去焦点时触发，如：blur、focus</li> <li>鼠标事件，当用户通过鼠标在页面执行操作时触发如：dbclick、mouseup</li> <li>滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel</li> <li>文本事件，当在文档中输入文本时触发，如：textInput</li> <li>键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress</li> <li>合成事件，当为 IME（输入法编辑器）输入字符时触发，如：compositionstart</li> <li>变动事件，当底层 DOM 结构发生变化时触发，如：DOMsubtreeModified</li> <li>同时 DOM3 级事件也允许使用者自定义一些事件。</li></ul> <h2 id="_36-如何刷新浏览器的应用缓存？"><a href="#_36-如何刷新浏览器的应用缓存？" class="header-anchor">#</a> 36. 如何刷新浏览器的应用缓存？</h2> <p>浏览器缓存可分为<code>强缓存</code>和<code>协商缓存</code>。</p> <ul><li><strong>强缓存</strong>指的是设置了 <code>expires</code> 或者 <code>cache-control:max-age</code> 的请求，此类缓存在设定的过期时间之前刷新不会再次向浏览器发起请求，直接由客户端决定使用缓存进行页面展示。</li> <li><strong>协商缓存</strong>指的是未设置强缓存对应字段的缓存，浏览器会向服务器发送请求，并带 <code>IF-Modified-Since</code> 和 <code>IF-None-Match</code> 字段，服务器对应的返回字段为 <code>Last-Modified</code> 或 <code>Etag</code>，如果在 <code>etag</code> 未更改 或 <code>last-modified</code> 的时间早于 <code>IF-Modified-Since</code> 则服务器不返回文件，使用浏览器本地缓存。</li></ul> <p>回到问题，如何刷新应用缓存。<br>
当你直接点击浏览器的刷新按钮或者 F5 刷新时，浏览器会忽略强缓存，必定向服务器发起请求，但是如果服务器返回 304 则会继续使用本地缓存。<br>
当点击 Ctrl+F5 浏览器会忽略一切缓存（cache-control:no-cache），向服务器发起请求，并且一定会使用服务器的返回来渲染页面。</p> <ol><li>ctrl+F5</li> <li>浏览器隐私模式开发</li> <li>chrome 开发者工具里将 Disable cache 选项打勾，阻止缓存</li> <li>在开发阶段，给资源加上一个动态的参数，由于每次资源的修改都要更新引用的位置，同时修改参数的值，所以操作起来不是很方便，除非是在动态页面比如 jsp 里开发就可以用服务器变量来解决，或者用前端构建工具来处理这个参数修改的问题。</li> <li>如果资源引用的页面被嵌入到了一个 iframe 里面，可以在 iframe 的区域右键重新加载该页面</li> <li>如果缓存问题出现在 ajax 请求中，最有效的解决办法就是 ajax 的请求地址追加随机数</li> <li>动态设置 iframe 的 src 时，有可能因为缓存问题导致看不到最新效果，在 src 后面添加随机数即可</li> <li>通过前端开发工具 grunt gulp 等的插件来启动一个静态服务器，则在这个服务器下所有资源返回的 response header 中，Cache-Control 始终被设置为不缓存</li></ol> <h2 id="_37-浏览器缓存"><a href="#_37-浏览器缓存" class="header-anchor">#</a> 37. 浏览器缓存</h2> <p>分为<code>强缓存</code>和<code>协商缓存</code></p> <ol><li>浏览器在加载资源时，先根据这个资源的一些 http header 判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。比如某个 css 文件，如果浏览器在加载它所在的网页时，这个 css 文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个 css，连请求都不会发送到网页所在服务器。</li> <li>当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些 http header 验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源。</li></ol> <p>区别：</p> <ul><li>强缓存与协商缓存的共同点是：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；</li> <li>区别是：强缓存不发请求到服务器，协商缓存会发请求到服务器。</li></ul> <p>当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。</p> <div align="center"><img src="/lutest/images/prepare/require/cache.jpeg" alt="images/prepare/require/cache.jpeg"></div> <h3 id="强缓存"><a href="#强缓存" class="header-anchor">#</a> 强缓存</h3> <div align="center"><img src="/lutest/images/prepare/require/2020070603.png" alt="images/prepare/require/2020070603.png"></div> <p>强缓存不向 http 发送请求，返回状态码 200.</p> <ul><li>不会向服务器发送请求，直接从缓存中读取资源</li> <li>请求返回 200 的状态码</li> <li>在 chrome 控制台的 network 选项中可以看到 size 显示 from disk cache 或 from memory cache。</li></ul> <blockquote><p>from memory cache 代表使用内存中的缓存，from disk cache 则代表使用的是硬盘中的缓存，浏览器读取缓存的顺序为 memory –&gt; disk。<br>
在浏览器中，浏览器会在 js 和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；<br>
而 css 文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。</p></blockquote> <p>强缓存是利用 <code>Expires</code> 或者 <code>Cache-Control</code> 这两个 http response header 实现的，它们都用来表示资源在客户端缓存的有效期。</p> <p>检查强缓存有两个字段: http1.0 使用 expires，代表过期时间，但是服务器时间和客户端时间可能不一致。为了弥补这个缺点，http1.1 使用 <code>cache-control</code> 的 <code>max-age</code> 字段，<code>cache-control</code> 有多个指令</p> <ul><li>public 允许客户端和代理服务器缓存</li> <li>private 允许客户端缓存</li> <li>no-store 不使用缓存</li> <li>no-cache 使用协商缓存 两个字段都存在，cache-control 优先级高于 expires</li></ul> <p><strong>缓存过程</strong>：</p> <ul><li><p><strong>Expires 缓存原理</strong></p> <ol><li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 response 的 header 加上 Expires 的 header</li> <li>浏览器在接收到这个资源后，会把这个资源连同所有的 response header 一起缓存下来，所以缓存命中的请求返回的 header 并不是来自服务器，而是来自之前缓存的 header</li> <li>浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出 Expires 跟当前的请求时间比较，如果请求时间在 Expires 指定的时间之前，就能命中缓存，否则就不行。</li> <li>如果缓存没有命中，浏览器直接从服务器加载资源时，Expires Header 在重新加载的时候会被更新</li></ol> <p><code>Expires</code> 是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改下客户端时间，就能影响缓存命中的结果，所以在 http1.1 的时候，提出了一个新的 header，也就是 <code>Cache-Control</code>，这是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，因此更有效安全一些，在配置缓存的时候，以秒为单位，用数值表示：如：Cache-Control：max-age=315360000，</p></li> <li><p><strong>Cache-Control 缓存过程 缓存原理</strong></p> <ol><li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 response 的 header 加上 Cache-Control 的 header</li> <li>浏览器在接收到这个资源的时候，会把这个资源连同所有 response header 一起缓存下来</li> <li>浏览器再次请求这个资源的时候，先从缓存中寻找，找到这个资源之后，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行。</li> <li>如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control 在重新加载的时候会被更新
这两个 header 可以只用一个，也可以同时用两个，同时存在时，Cache-Control 优先级高于 Expires</li></ol></li></ul> <p><strong>强缓存的管理</strong></p> <p>两种方式来设置是否启用强缓存：</p> <ol><li>通过代码的方式，在 web 服务器返回的响应中添加 <code>Expires</code> 和 <code>Cache-Control</code> Header</li> <li>通过配置 web 服务器的方式，让 web 服务器在响应资源的时候统一添加 <code>Expires</code> 和 <code>Cache-Control</code> Header</li></ol> <p><strong>强缓存的应用</strong></p> <p>强缓存是前端性能优化最有力的工具，对于有大量静态资源的网页，一定要利用强缓存，提高响应速度，通常是为这些静态资源全部配置一个超时时间超长的 Expires 或 Cache-Control，这样用户只会在第一次访问网站时加载静态资源，其他时间只要缓存没有失效并且用户没有强制刷新的条件下都会从缓存中加载。<br>
然而这种缓存配置方式会带来一个问题，就是当资源更新时，客户端由于有缓存不会向服务器请求最新的资源，这个问题已有解决方案：<br>
通过更新页面中引用的资源路径，让浏览器主动放弃缓存，加载新资源。<br>
但要实现有更新的文件才需要浏览器重新加载，因此必须让 url 的修改与文件内容相关联，利用数据摘要算法对文件求摘要信息，摘要信息与文件内容一一对应，这一点许多前端构建工具都做到了，如 webpack</p> <p><strong>浏览器默认缓存使开发环境下常因为资源没有及时更新而看不到效果</strong>, 解决方法：</p> <ol><li>ctrl+F5</li> <li>浏览器隐私模式开发</li> <li>chrome 开发者工具里将 Disable cache 选项打勾，阻止缓存</li> <li>在开发阶段，给资源加上一个动态的参数，由于每次资源的修改都要更新引用的位置，同时修改参数的值，所以操作起来不是很方便，除非是在动态页面比如 jsp 里开发就可以用服务器变量来解决，或者用前端构建工具来处理这个参数修改的问题。</li> <li>如果资源引用的页面被嵌入到了一个 iframe 里面，可以在 iframe 的区域右键重新加载该页面</li> <li>如果缓存问题出现在 ajax 请求中，最有效的解决办法就是 ajax 的请求地址追加随机数</li> <li>动态设置 iframe 的 src 时，有可能因为缓存问题导致看不到最新效果，在 src 后面添加随机数即可</li> <li>通过前端开发工具 grunt gulp 等的插件来启动一个静态服务器，则在这个服务器下所有资源返回的 response header 中，Cache-Control 始终被设置为不缓存</li></ol> <p><strong>发布问题</strong></p> <ul><li>发布问题：若页面和它引用的资源路径同时更新了，不管是先部署页面还是先部署资源都会带来各种问题，这是由于资源是覆盖式发布的，即用待发布资源覆盖已发布资源。</li> <li>解决办法就是实现非覆盖式发布：把有修改的资源文件作为一个新的文件发布，不对已有的资源文件进行覆盖，这样用户还可以请求旧的资源文件，不至于发生页面错乱的问题，这样先部署静态资源，再覆盖式部署页面，等到用户访问新页面的时候，新的资源文件也已发布，就可以正确请求，即可解决问题。</li></ul> <h3 id="协商缓存"><a href="#协商缓存" class="header-anchor">#</a> 协商缓存</h3> <p>如果命中协商缓存，请求响应返回的 http 状态为 304 以及一个 Not Modified 字符串，协商缓存利用的是【<code>Last-Modified</code>、<code>If-Modified-Since</code>】、【<code>ETag</code>、<code>If-None-Match</code>】这两对 header 来管理的。</p> <p>协商缓存生效，返回 304 和 Not Modified</p> <div align="center"><img src="/lutest/images/prepare/require/2020070602.png" alt="images/prepare/require/2020070602.png"></div> <ol><li><p><strong><code>Last-Modified</code> 和 <code>If-Modified-Since</code></strong></p> <ol><li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源时，在 response 的 header 加上 <code>Last-Modified</code> 的 header，表示这个资源在服务器上的最后修改时间</li> <li>浏览器再次向服务器请求这个资源时，在 request 的 header 加上 <code>If-Modified-Since</code> 的 header，这个 header 的值就是上一次请求时返回的 <code>Last-Modified</code> 的值</li> <li>服务器再次收到资源请求时，根据浏览器传过来 <code>If-Modified-Since</code> 和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回 304 Not Modified，但是不会返回资源内容，如果有变化就返回资源内容，当服务器返回 304 Not Modified 的响应时，response header 中不会再添加 <code>Last-Modified</code> 的 header，因为资源没有变化，<code>Last-Modified</code> 的值也不变</li> <li>浏览器收到 304 的响应后，就会从缓存中加载资源</li> <li>如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modofied header 在重新加载的时候会被更新，下次请求时，<code>If-Modified-Since</code> 会采用上一次返回的 <code>Last-Modified</code> 的值</li></ol> <p>这一对 header 都是根据服务器时间返回的，有时候会有服务器资源有变化，但最后修改时间却没有变化的情况，因此有了</p> <blockquote><p>缺点：1、某些服务端不能获取精确的修改时间 2、文件修改时间改了，但文件内容却没有变</p></blockquote></li> <li><p><strong><code>ETag</code> 和 <code>If-None-Match</code></strong><br>
Etag 是上一次加载资源时，服务器返回的 response header，是对该资源的一种唯一标识，只要资源有变化，Etag 就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的 Etag 值放到 request header 里的 If-None-Match 里，服务器只需要比较客户端传来的 If-None-Match 跟自己服务器上该资源的 ETag 是否一致，就能很好地判断资源相对客户端而言是否被修改过了。如果服务器发现 ETag 匹配不上，那么直接以常规 GET 200 回包形式将新的资源（当然也包括了新的 ETag）发给客户端；如果 ETag 是一致的，则直接返回 304 知会客户端直接使用本地缓存即可。</p> <ol><li>浏览器第一次向服务器请求一个资源，服务器在返回这个资源的同时，在 response 的 header 加上 <code>ETag</code> 的 header，这个 header 是服务器根据当前请求的资源生成的一个唯一标识，是一个字符串，只要资源内容发生改变，这个字符串也会改变，跟时间没有关系</li> <li>浏览器再次请求这个资源的时候，在 request 的 header 上加上 <code>If-None-Match</code> 的 header。这个 header 的值是上一次请求返回的 ETag 的值</li> <li>服务器再次收到资源请求时，根据客户端传过来的 <code>If-None-Match</code> 和重新生成的该资源的新的 ETag 做比较，相同则返回 304 Not Modified，不会返回资源内容，如果不同则返回资源内容，但这里即使资源没有发生变化，也会返回 ETag，因为这个 ETag 重新生成过，即使没有 ETag 没有变化</li> <li>浏览器收到 304 响应后，就从缓存中加载资源</li></ol></li> <li><p>协商缓存两种方式的对比</p> <ol><li>首先在精确度上，Etag 要优于 Last-Modified，Last-Modified 的时间单位是秒，如果某个文件在 1 秒内改变了多次，那么他们的 Last-Modified 其实并没有体现出来修改，但是 Etag 每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的 Last-Modified 也有可能不一致。</li> <li>性能上，Etag 要逊于 Last-Modified，毕竟 Last-Modified 只需要记录时间，而 Etag 需要服务器通过算法来计算出一个 hash 值。</li> <li>优先级上，服务器校验优先考虑 Etag</li></ol></li></ol> <p>检查协商缓存有两个字段: http1.0 使用 <code>last-modified</code>，即最后修改时间。</p> <ol><li>在浏览器向服务器发送请求后，服务器会在响应头上加上这个字段</li> <li>浏览器接收后，如果再次请求，会在请求头上携带 <code>If-Modified-Since</code></li> <li>服务器拿到 <code>If-Modified-Since</code> 字段后，会和服务器中该资源的最后修改时间对比,如果请求头中这个值小于最后修改时间，更新资源；否则返回 304，告诉浏览器直接使用缓存</li></ol> <p>http1.1 使用 etag，etag 是服务器根据当前文件内容，给文件生成的唯一标识，只要内容改变，这个值就会变。<code>etag 优先级高于 last-modifed</code></p> <p>缓存位置，按优先级从高到低分别是:</p> <ul><li>service worker</li> <li>memory cache</li> <li>disk cache</li> <li>push cache</li></ul> <h2 id="_38-cdn-缓存"><a href="#_38-cdn-缓存" class="header-anchor">#</a> 38. CDN 缓存</h2> <h3 id="cdn"><a href="#cdn" class="header-anchor">#</a> CDN</h3> <p>CDN：Content Delivery Network/Content Ddistribute Network，即内容分发网络</p> <p>客户端访问网站的过程：</p> <ul><li>没有 CDN：
<ol><li>用户在浏览器访问栏中输入要访问的域名；</li> <li>浏览器向 DNS 服务器请求对该域名的解析；</li> <li>DNS 服务器返回该域名的 IP 地址给浏览器</li> <li>浏览器使用该 IP 地址向服务器请求内容。</li> <li>服务器将用户请求的内容返回给浏览器。</li></ol></li> <li>使用了 CDN：
<ol><li>用户在浏览器中输入要访问的域名。</li> <li>浏览器向 DNS 服务器请求对域名进行解析。由于 CDN 对域名解析进行了调整，DNS 服务器会最终将域名的解析权交给 CNAME 指向的 CDN 专用 DNS 服务器。</li> <li>CDN 的 DNS 服务器将 CDN 的负载均衡设备 IP 地址返回给用户。</li> <li>用户向 CDN 的负载均衡设备发起内容 URL 访问请求。</li> <li>CDN 负载均衡设备会为用户选择一台合适的缓存服务器提供服务。<br>
选择的依据包括：根据用户 IP 地址，判断哪一台服务器距离用户最近；根据用户所请求的 URL 中携带的内容名称，判断哪一台服务器上有用户所需内容；查询各个服务器的负载情况，判断哪一台服务器的负载较小。
基于以上这些依据的综合分析之后，负载均衡设置会把缓存服务器的 IP 地址返回给用户。</li> <li>用户向缓存服务器发出请求。</li> <li>缓存服务器响应用户请求，将用户所需内容传送到用户。</li></ol></li></ul> <p>如果这台缓存服务器上并没有用户想要的内容，而负载均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉取到本地。</p> <p>当服务接入了 CDN 之后，浏览器本地缓存的资源过期之后，浏览器不是直接向源服务器请求资源，而是转而向 CDN 边缘节点请求资源。CDN 边缘节点中将用户的数据缓存起来，如果 CDN 中的缓存也过期了，CDN 边缘节点会向源服务器发出回源请求，从而来获取最新资源。</p> <h3 id="cdn-缓存策略"><a href="#cdn-缓存策略" class="header-anchor">#</a> CDN 缓存策略</h3> <p>CDN 节点缓存策略一般都会遵循 HTTP 标准协议，又拍云在没有匹配到自定义缓存规则且源服务器也没有返回任何有效缓存头的情况下，默认配置策略如下：</p> <ol><li>针对静态资源，所有正常状态码（大于等于 200 小于 400）均缓存 8 天。特别地，301 响应缓存 2 小时，302 响应缓存 20 分钟；</li> <li>针对动态资源，程序会自动识别，则不进行缓存；</li> <li>对于其他大于等于 400 的不正常响应，则不进行缓存；</li></ol> <h3 id="cdn-缓存的不足"><a href="#cdn-缓存的不足" class="header-anchor">#</a> CDN 缓存的不足</h3> <p>CDN 缓存不仅减少了用户的访问延时，相应的也减少了源服务器的负载，但这里需要注意，当源服务器资源更新后，如果 CDN 节点上缓存数据还未过期，用户访问到的依旧是过期的缓存资源，这会导致用户最终访问出现偏差。因此，开发者需要手动刷新相关资源，使 CDN 缓存保持为最新的状态。</p> <h2 id="_39-本地存储的生命周期是什么？"><a href="#_39-本地存储的生命周期是什么？" class="header-anchor">#</a> 39. 本地存储的生命周期是什么？</h2> <ul><li><code>cookie</code>: <code>expire</code> 和 <code>max-age</code> 都能控制数据的存储时间。<code>expire</code> 是一个绝对的过期时间，<code>max-age</code> 是文档被访问之后的存活时间（是相对时间）。默认是 <code>session</code>。</li> <li><code>sessionStorage</code>: 当会话被关闭后（浏览器、标签页被关闭），就会被清除。与 localStorage 用法一样。</li> <li><code>localStorage</code>: 除非被主动清除，不然永久储存在浏览器中。</li> <li><code>IndexedDB</code>: 没有过期时间，除非主动清除。</li></ul> <h2 id="_40-如何防止-cookie-被盗用？"><a href="#_40-如何防止-cookie-被盗用？" class="header-anchor">#</a> 40. 如何防止 cookie 被盗用？</h2> <ol><li>使用 https</li> <li>加 IP 判断</li> <li>缩短有效时间</li> <li>使用 Token 验证</li> <li>为 cookie 设置 HttpOnly</li> <li>cookie 带上用户 ip 加密</li> <li>使用 Referer 验证</li> <li>禁止网页内嵌</li> <li>每次请求需要输入图形验证码</li></ol> <h2 id="_41-举例说明什么是-decodeuri-和-encodeuri-是什么？"><a href="#_41-举例说明什么是-decodeuri-和-encodeuri-是什么？" class="header-anchor">#</a> 41. 举例说明什么是 decodeURI()和 encodeURI()是什么？</h2> <ul><li>encodeURI 编码</li> <li>decodeURI 解码</li></ul> <ol><li><code>encodeURI()</code>：将 URI 中的每个字符编码为 1-4 个格式为 <code>%xx</code> 的转义序列（xx 为十六进制数），但不包括 ASCII 数字、字母、URL 分隔符（<code>/</code>、<code>?</code>、<code>,</code>、<code>&amp;</code>、...）、以及其他部分 ASCII 字符。具体见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURI" target="_blank" rel="noopener noreferrer">MDN<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。
<ul><li>Example: <code>encodeURI('http://example.com/端点?键=值')</code> =&gt; <code>'http://example.com/%E7%AB%AF%E7%82%B9?%E9%94%AE=%E5%80%BC'</code></li></ul></li> <li><code>decodeURI()</code>：将已经编码的 URI 中的转义序列解码为它们表示的字符，但除了 <code>encodeURI()</code> 不会编码的字符。</li> <li><code>encodeURIComponent()</code>：用于编码 URI 中的组成部分。它除了转义 <code>encodeURI()</code> 指定的字符，还会转义 URL 分隔符（<code>/</code>、<code>?</code>、<code>,</code>、<code>&amp;</code>、...）
<ul><li><span style="word-break:break-all;">Example: <code>encodeURIComponent('测试/测试?测试=测试')</code> =&gt; <code>'%E6%B5%8B%E8%AF%95%2F%E6%B5%8B%E8%AF%95%3F%E6%B5%8B%E8%AF%95%3D%E6%B5%8B%E8%AF%95'</code></span></li></ul></li> <li><code>decodeURIComponent()</code>：将已经编码的 URI 组成部分中的转义序列解码为它们表示的字符，但除了 <code>encodeURIComponent()</code> 不会编码的字符。</li></ol> <h2 id="_42-请说说-escape、encodeuri、decodeuri、encodeuricomponent-和-decodeuricomponent-的区别？"><a href="#_42-请说说-escape、encodeuri、decodeuri、encodeuricomponent-和-decodeuricomponent-的区别？" class="header-anchor">#</a> 42. 请说说 escape、encodeURI、decodeURI、encodeURIComponent 和 decodeURIComponent 的区别？</h2> <ol><li><code>escape()</code> 将会把字符串中除了字母、数字以及一部分符号以外的所有转义为 %XX 格式的转义序列，可以通过 <code>unescape()</code> 转回。它们是已经被弃用的方法，不建议使用。</li> <li><code>encodeURI()</code>：将 URI 中的每个字符编码为 1-4 个格式为 <code>%xx</code> 的转义序列（xx 为十六进制数），但不包括 ASCII 数字、字母、URL 分隔符（<code>/</code>、<code>?</code>、<code>,</code>、<code>&amp;</code>、...）、以及其他部分 ASCII 字符。具体见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURI" target="_blank" rel="noopener noreferrer">MDN<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。
<ul><li>Example: <code>encodeURI('http://example.com/端点?键=值')</code> =&gt; <code>'http://example.com/%E7%AB%AF%E7%82%B9?%E9%94%AE=%E5%80%BC'</code></li></ul></li> <li><code>decodeURI()</code>：将已经编码的 URI 中的转义序列解码为它们表示的字符，但除了 <code>encodeURI()</code> 不会编码的字符。</li> <li><code>encodeURIComponent()</code>：用于编码 URI 中的组成部分。它除了转义 <code>encodeURI()</code> 指定的字符，还会转义 URL 分隔符（<code>/</code>、<code>?</code>、<code>,</code>、<code>&amp;</code>、...）
<ul><li><span style="word-break:break-all;">Example: <code>encodeURIComponent('测试/测试?测试=测试')</code> =&gt; <code>'%E6%B5%8B%E8%AF%95%2F%E6%B5%8B%E8%AF%95%3F%E6%B5%8B%E8%AF%95%3D%E6%B5%8B%E8%AF%95'</code></span></li></ul></li> <li><code>decodeURIComponent()</code>：将已经编码的 URI 组成部分中的转义序列解码为它们表示的字符，但除了 <code>encodeURIComponent()</code> 不会编码的字符。</li></ol> <h2 id="_43-如何实现文件拖动上传？"><a href="#_43-如何实现文件拖动上传？" class="header-anchor">#</a> 43. 如何实现文件拖动上传？</h2> <p>利用 HTML5 的 <code>drag &amp; drop</code> API 来实现。需要注意的是，必须要设置 <code>dragover</code> 事件，不然不会触发 <code>drop</code> 事件。</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>file<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>dragUpload<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>drag-upload<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  Drag File to Upload
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><div class="language-css line-numbers-mode"><pre class="language-css"><code><span class="token selector">.drag-upload</span> <span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span>
  <span class="token property">font-size</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>
  <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>
  <span class="token property">line-height</span><span class="token punctuation">:</span> 80px<span class="token punctuation">;</span>
  <span class="token property">border-radius</span><span class="token punctuation">:</span> 5px<span class="token punctuation">;</span>
  <span class="token property">border</span><span class="token punctuation">:</span> 1px dashed lightblue<span class="token punctuation">;</span>
  <span class="token property">cursor</span><span class="token punctuation">:</span> grab<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> dragUpload <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;dragUpload&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
dragUpload<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;dragover&quot;</span><span class="token punctuation">,</span> <span class="token parameter">e</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  e<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 必须要有 dragover 同时需要 preventDefault，否则不会触发 drop 事件</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

dragUpload<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;drop&quot;</span><span class="token punctuation">,</span> <span class="token parameter">e</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  e<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 获取到拖拽进来的文件</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span> dataTransfer<span class="token operator">:</span> <span class="token punctuation">{</span> files <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token operator">=</span> e <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment">// console.log(e.dataTransfer.files);</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;dropped: &quot;</span><span class="token punctuation">,</span> files<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 获取到文件后就可以做上传的操作了</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h2 id="_44-通过-useragent-是否包含-micromessenger-来判断是否在微信内置浏览器打开网页"><a href="#_44-通过-useragent-是否包含-micromessenger-来判断是否在微信内置浏览器打开网页" class="header-anchor">#</a> 44. 通过 userAgent 是否包含 MicroMessenger 来判断是否在微信内置浏览器打开网页</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">isWeiXin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> ua <span class="token operator">=</span> window<span class="token punctuation">.</span>navigator<span class="token punctuation">.</span>userAgent<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 不加window部分Android机会显示不了提示图，即判断不了是否是微信</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>ua<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex">/MicroMessenger/i</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">&quot;micromessenger&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="_45-ajax-请求中-get-和-post-方式有什么区别呢？分别在哪些场景下使用？"><a href="#_45-ajax-请求中-get-和-post-方式有什么区别呢？分别在哪些场景下使用？" class="header-anchor">#</a> 45. Ajax 请求中 get 和 post 方式有什么区别呢？分别在哪些场景下使用？</h2> <p><strong>get：</strong></p> <ol><li>GET 请求会将参数跟在 URL 后进行传递，也就是会在 url 中显示</li> <li>GET 请求有数据长度限制，一般在 2000 个字符，而 POST 没有。</li> <li>GET 方式请求的数据会被浏览器缓存起来，POST 没有</li> <li>GET 在某些情况下会有安全问题，POST 没有。</li> <li>在客户端使用 get 请求时,服务器端使用 Request.QueryString 来获取参数</li> <li>get 请求参数会在 url 中显示，容易被他人窃取，post 在请求体中，不会被窃取</li></ol> <p><strong>post：</strong></p> <ol><li>POST 请求是作为 HTTP 消息的实体内容发送给 WEB 服务器。</li> <li>客户端使用 post 请求时,服务器端使用 Request.Form 来获取参数。</li> <li>post 一般用于修改服务器上的资源，对所发送的信息没有限制</li> <li>post 比 get 更加安全</li> <li>post 需要设置请求头</li></ol> <h2 id="_46-get-和-post-区别"><a href="#_46-get-和-post-区别" class="header-anchor">#</a> 46. get 和 post 区别</h2> <ol><li>首先是语义上的区别，GET 为获取，POST 为提交</li> <li>其次是 GET 请求只请求服务器一次，但 POST 会请求两次，第一次是 OPTIONS 方式请求为了确定服务器是否能够接收数据，第二次才是真的 POST 请求，将数据提交到服务器；</li> <li>首先是语义上的区别，GET 参数有长度限制（受限于 url 长度，具体的数值取决于浏览器和服务器的限制，最长 2048 字节），而 POST 无限制。</li> <li>首先是语义上的区别，GET 请求的数据会附加在 url 之 ，以 &quot; ？ &quot;分割 url 和传输数据，多个参数用 &quot;&amp;&quot;连接，而 POST 请求会把请求的数据放在 http 请求体中。</li> <li>首先是语义上的区别，GET 是明文传输，POST 是放在请求体中，但是开发者可以通过抓包工具看到，也相当于是明文的</li> <li>首先是语义上的区别，GET 请求会保存在浏览器历史记录中，还可能保存在 web 服务器的日志中</li> <li>从缓存角度 首先是语义上的区别，GET 请求是可以被缓存的， POST 请求是不可以被缓存的</li> <li>GET 和 POST 本质没有区别，都是 tcp 连接</li></ol> <h2 id="_47-简单请求和复杂请求的区别"><a href="#_47-简单请求和复杂请求的区别" class="header-anchor">#</a> 47. 简单请求和复杂请求的区别</h2> <p><strong>简单请求</strong></p> <blockquote><p>满足一下两个条件的请求。</p></blockquote> <ol><li>请求方法是以下三种方法之一
<ul><li>HEAD</li> <li>GET</li> <li>POST</li></ul></li> <li>HTTP 的头信息不超出以下几种字段:
<ul><li>Accept</li> <li>Accept-Language</li> <li>Content-Language</li> <li>Content-Type：只限于三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain</li></ul></li></ol> <p><strong>复杂请求</strong></p> <blockquote><p>非简单请求就是复杂请求</p></blockquote> <p>复杂请求在正式请求前都会有预检请求，在浏览器中都能看到有 <code>OPTIONS</code> 请求，用于向服务器请求权限信息的。</p> <h2 id="_48-js-的异步加载"><a href="#_48-js-的异步加载" class="header-anchor">#</a> 48. js 的异步加载</h2> <p>异步加载 js： 使 js 文件脱离 html 解析的瀑布流加载，从而使 js 可以并行下载。</p> <p style="color:red;">为什么要异步加载</p> <p>一般写法将 js 放在 head 中，而且默认方式是同步加载，这就会导致在进行 js 加载的过程中，无法在其加载完成前对后续的内容进行操作，造成页面内阻塞，对用户体验很不友好。</p> <p><b style="color:red;">什么是阻塞</b>：在页面中我们通常会引用外部文件，而浏览器在解析 HTML 页面是从上到下依次解析、渲染，如果<code>&lt;head&gt;</code>中引用了一个 a.js 文件，而这个文件很大或者有问题，需要 2 秒加载，那么浏览器会停止渲染页面（此时是白屏显示，就是页面啥都没有），2 秒后加载完成才会继续渲染，这个就是阻塞。</p> <p><b style="color:red;">为什么会阻塞</b>：因为浏览器不知道 a.js 中执行了哪些脚本，会对页面造成什么影响，所以浏览器会等 js 文件下载并执行完成后才继续渲染，如果这个时间过长，会白屏。<br>
CSS 文件也一样，因为 CSS 文件会对 DOM 的样式，布局，色彩，效果产生影响，所以浏览器会等 CSS 文件下载并执行完成后继续。为了页面的性能，要避免阻塞。</p> <p>异步加载的方式</p> <ol><li><p><strong>动态脚本加载</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">//立即执行函数</span>
<span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//创建一个script标签</span>
  <span class="token keyword">var</span> scriptTag <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">creatElement</span><span class="token punctuation">(</span><span class="token string">&quot;script&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">//h4前type必须加上，h5可以不加</span>
  scriptTag<span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token string">&quot;text/javascript&quot;</span><span class="token punctuation">;</span>
  <span class="token comment">//h5新增的，用这种方法可以不写</span>
  scriptTag<span class="token punctuation">.</span>async <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token comment">//你的地址</span>
  scriptTag<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">&quot;js地址&quot;</span><span class="token punctuation">;</span>
  <span class="token comment">//获取head标签</span>
  <span class="token keyword">var</span> headTag <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">&quot;head&quot;</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment">//在已有子节点前插入该标签，其实也可以用appendChild</span>
  headTag<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>scriptTag<span class="token punctuation">,</span> headTag<span class="token punctuation">.</span>firstChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div></li> <li><p><strong>defer</strong><br>
defer 是在 HTML 解析完成之后就会执行，如果有多个，按照加载的顺序依次执行<br> <strong>带有 defer 属性的 script 标签可以放置在文档的任何位置。对应的 JavaScript 文件将在页面解析到 script 标签时开始下载，但不会执行，直到 DOM 加载完成，即 onload 事件触发前才会被执行。当一个带有 defer 属性的 JavaScript 文件下载时，它不会阻塞浏览器的其他进程，因此这类文件可以与其他资源文件一起并行下载</strong></p> <p>有 3 点需要注意:</p> <ol><li>defer 只适用于外联脚本，如果 script 标签没有指定 src 属性，只是内联脚本，不要使用 defer</li> <li>如果有多个声明了 defer 的脚本，则会按顺序下载和执行</li> <li>defer 脚本会在 DOMContentLoaded 和 load 事件之前执行</li></ol></li> <li><p><strong>async</strong><br>
在有 async 的情况下，JavaScript 脚本一旦下载好了就会执行，所以很有可能不是按照原本的顺序来执行的。如果 JavaScript 脚本前后有依赖性，使用 async 就很有可能出现错误。</p> <p>有 3 点需要注意：</p> <ol><li>只适用于外联脚本，这一点和 defer 一致</li> <li>如果有多个声明了 async 的脚本，其下载和执行也是异步的，不能确保彼此的先后顺序</li> <li>async 会在 load 事件之前执行，但并不能确保与 DOMContentLoaded 的执行先后顺序</li></ol></li></ol> <h2 id="_49-localstorage-与-sessionstorage-与-cookie-的区别总结"><a href="#_49-localstorage-与-sessionstorage-与-cookie-的区别总结" class="header-anchor">#</a> 49. localStorage 与 sessionStorage 与 cookie 的区别总结</h2> <ul><li>共同点: 都保存在浏览器端, 且同源</li> <li>localStorage 与 sessionStorage 统称 webStorage,保存在浏览器,不参与服务器通信,大小为 5M</li> <li>生命周期不同: localStorage 永久保存, sessionStorage 当前会话, 都可手动清除</li> <li>作用域不同: 不同浏览器不共享 local 和 session, 不同会话不共享 session</li> <li>Cookie: 设置的过期时间前一直有效, 大小 4K.有个数限制, 各浏览器不同, 一般为 20 个.携带在 HTTP 头中, 过多会有性能问题.可自己封装, 也可用原生</li></ul> <h2 id="_50-axios、fetch-的区别"><a href="#_50-axios、fetch-的区别" class="header-anchor">#</a> 50. axios、fetch 的区别</h2> <h3 id="axios"><a href="#axios" class="header-anchor">#</a> axios</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token function">axios</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  method<span class="token operator">:</span> <span class="token string">&quot;post&quot;</span><span class="token punctuation">,</span>
  url<span class="token operator">:</span> <span class="token string">&quot;/user/12345&quot;</span><span class="token punctuation">,</span>
  data<span class="token operator">:</span> <span class="token punctuation">{</span>
    firstName<span class="token operator">:</span> <span class="token string">&quot;Fred&quot;</span><span class="token punctuation">,</span>
    lastName<span class="token operator">:</span> <span class="token string">&quot;Flintstone&quot;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>axios 是一个基于 Promise 用于浏览器和 nodejs 的 HTTP 客户端，本质上也是对原生 XHR 的封装，只不过它是 Promise 的实现版本，符合最新的 ES 规范，它本身具有以下特征：</p> <ol><li>从浏览器中创建 XMLHttpRequest</li> <li>支持 Promise API</li> <li>客户端支持防止 CSRF</li> <li>提供了一些并发请求的接口（重要，方便了很多的操作）</li> <li>从 node.js 创建 http 请求</li> <li>拦截请求和响应</li> <li>转换请求和响应数据</li> <li>取消请求</li> <li>自动转换 JSON 数据</li></ol> <blockquote><p>防止 CSRF:就是让你的每个请求都带一个从 cookie 中拿到的 key, 根据浏览器同源策略，假冒的网站是拿不到你 cookie 中得 key 的，这样，后台就可以轻松辨别出这个请求是否是用户在假冒网站上的误导输入，从而采取正确的策略。</p></blockquote> <h3 id="fetch"><a href="#fetch" class="header-anchor">#</a> fetch</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">try</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> response <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> data <span class="token operator">=</span> response<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Oops, error&quot;</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>fetch 号称是 AJAX 的替代品，是在 ES6 出现的，使用了 ES6 中的 promise 对象。Fetch 是基于 promise 设计的。Fetch 的代码结构比起 ajax 简单多了，参数有点像 jQuery ajax。但是，一定记住 fetch 不是 ajax 的进一步封装，而是原生 js，没有使用 XMLHttpRequest 对象。</p> <p>fetch 的优点：</p> <ol><li>符合关注分离，没有将输入、输出和用事件来跟踪的状态混杂在一个对象里</li> <li>更好更方便的写法</li> <li>语法简洁，更加语义化</li> <li>基于标准 Promise 实现，支持 async/await</li> <li>同构方便，使用 <a href="https://github.com/matthew-andrews/isomorphic-fetch" target="_blank" rel="noopener noreferrer">isomorphic-fetch<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li>更加底层，提供的 API 丰富（request, response）</li> <li>脱离了 XHR，是 ES 规范里新的实现方式</li></ol> <p>fetch 是一个低层次的 API，你可以把它考虑成原生的 XHR，所以使用起来并不是那么舒服，需要进行封装。</p> <p>例如：</p> <ol><li>fetch 只对网络请求报错，对 400，500 都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。</li> <li>fetch 默认不会带 cookie，需要添加配置项： fetch(url, {credentials: 'include'})</li> <li>fetch 不支持 abort，不支持超时控制，使用 setTimeout 及 Promise.reject 的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费</li> <li>fetch 没有办法原生监测请求的进度，而 XHR 可以</li></ol> <p>总结：axios 既提供了并发的封装，也没有 fetch 的各种问题，而且体积也较小，当之无愧现在最应该选用的请求的方式。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/lutest/prepare/Require/04-ES6.html" class="prev">04-ES6</a></span> <span class="next"><a href="/lutest/prepare/Require/06-服务端与网络.html">06-服务端与网络</a>
      →
    </span></p></div> </main> <span data-v-2ae0ee72></span></div><div class="global-ui"></div></div>
    <script src="/lutest/assets/js/app.f0f4e5ba.js" defer></script><script src="/lutest/assets/js/2.9740266b.js" defer></script><script src="/lutest/assets/js/3.fe54688f.js" defer></script><script src="/lutest/assets/js/37.d850614d.js" defer></script>
  </body>
</html>
